<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/client/src/components/NewPlayerPopup.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/components/NewPlayerPopup.tsx" />
              <option name="updatedContent" value="import React, { useEffect, useState } from &quot;react&quot;;&#10;&#10;type NewPlayerPopupProps = {&#10;    playerName: string | null;&#10;    onClose: () =&gt; void;&#10;};&#10;&#10;export default function NewPlayerPopup({ playerName, onClose }: NewPlayerPopupProps) {&#10;    const [visible, setVisible] = useState(false);&#10;&#10;    useEffect(() =&gt; {&#10;        if (playerName) {&#10;            setVisible(true);&#10;            const timer = setTimeout(() =&gt; {&#10;                setVisible(false);&#10;                setTimeout(onClose, 300);&#10;            }, 3000);&#10;            return () =&gt; clearTimeout(timer);&#10;        }&#10;    }, [playerName, onClose]);&#10;&#10;    if (!playerName) return null;&#10;&#10;    return (&#10;        &lt;div className={`new-player-popup ${visible ? 'visible' : ''}`}&gt;&#10;            &lt;div className=&quot;new-player-content&quot;&gt;&#10;                &lt;div className=&quot;new-player-icon&quot;&gt;️&lt;/div&gt;&#10;                &lt;div className=&quot;new-player-text&quot;&gt;&#10;                    &lt;strong&gt;{playerName}&lt;/strong&gt; entrou na corrida!&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/package.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/package.json" />
              <option name="originalContent" value="{&#10;  &quot;name&quot;: &quot;formula-js-server&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;Servidor multiplayer para jogo de Fórmula 1&quot;,&#10;  &quot;main&quot;: &quot;server.js&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;start&quot;: &quot;node server.js&quot;,&#10;    &quot;dev&quot;: &quot;nodemon server.js&quot;&#10;  },&#10;  &quot;dependencies&quot;: {&#10;    &quot;ws&quot;: &quot;^8.14.2&quot;,&#10;    &quot;uuid&quot;: &quot;^9.0.1&quot;&#10;  },&#10;  &quot;devDependencies&quot;: {&#10;    &quot;nodemon&quot;: &quot;^3.0.1&quot;&#10;  }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;name&quot;: &quot;formula-js-server&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;Servidor multiplayer para jogo de Fórmula 1&quot;,&#10;  &quot;main&quot;: &quot;server.js&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;start&quot;: &quot;node server.js&quot;,&#10;    &quot;dev&quot;: &quot;nodemon server.js&quot;&#10;  },&#10;  &quot;dependencies&quot;: {&#10;    &quot;ws&quot;: &quot;^8.14.2&quot;,&#10;    &quot;uuid&quot;: &quot;^9.0.1&quot;&#10;  },&#10;  &quot;devDependencies&quot;: {&#10;    &quot;nodemon&quot;: &quot;^3.0.1&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/App.jsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/App.jsx" />
              <option name="originalContent" value="import React, { useRef, useState } from &quot;react&quot;;&#10;import { Canvas } from &quot;@react-three/fiber&quot;;&#10;import Car from &quot;./components/Car&quot;;&#10;import Track from &quot;./components/Track&quot;;&#10;import Camera from &quot;./components/Camera&quot;;&#10;import Timer from &quot;./components/Timer&quot;;&#10;import PlayerName from &quot;./components/PlayerName&quot;;&#10;import PlayerNameLabel from &quot;./components/PlayerNameLabel&quot;;&#10;&#10;function App() {&#10;    const carRef = useRef();&#10;    const [playerName, setPlayerName] = useState(&quot;&quot;);&#10;    const [carPosition, setCarPosition] = useState([0, 1, 0]);&#10;&#10;    return (&#10;        &lt;div style={{ width: &quot;100vw&quot;, height: &quot;100vh&quot;, backgroundColor: &quot;white&quot; }}&gt;&#10;            &lt;PlayerName onNameSet={setPlayerName} /&gt;&#10;            &lt;Timer /&gt;&#10;            &lt;Canvas shadows camera={{ position: [0, 8, 15], fov: 60 }}&gt;&#10;                {/* Iluminação */}&#10;                &lt;ambientLight intensity={0.6} /&gt;&#10;                &lt;directionalLight&#10;                    position={[20, 20, 10]}&#10;                    intensity={1.5}&#10;                    castShadow&#10;                    shadow-mapSize-width={2048}&#10;                    shadow-mapSize-height={2048}&#10;                    shadow-camera-left={-50}&#10;                    shadow-camera-right={50}&#10;                    shadow-camera-top={50}&#10;                    shadow-camera-bottom={-50}&#10;                /&gt;&#10;&#10;                {/* Componentes do jogo */}&#10;                &lt;Track /&gt;&#10;                &lt;Car&#10;                    ref={carRef}&#10;                    position={[0, 1, 0]}&#10;                    onPositionChange={setCarPosition}&#10;                /&gt;&#10;                &lt;Camera target={carRef} /&gt;&#10;&#10;                {/* Label do jogador */}&#10;                {playerName &amp;&amp; (&#10;                    &lt;PlayerNameLabel&#10;                        position={carPosition}&#10;                        playerName={playerName}&#10;                    /&gt;&#10;                )}&#10;            &lt;/Canvas&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;export default App;" />
              <option name="updatedContent" value="import React, { useRef, useState } from &quot;react&quot;;&#10;import { Canvas } from &quot;@react-three/fiber&quot;;&#10;import Car from &quot;./components/Car&quot;;&#10;import Track from &quot;./components/Track&quot;;&#10;import Camera from &quot;./components/Camera&quot;;&#10;import Timer from &quot;./components/Timer&quot;;&#10;import PlayerName from &quot;./components/PlayerName&quot;;&#10;import PlayerNameLabel from &quot;./components/PlayerNameLabel&quot;;&#10;&#10;function App() {&#10;    const carRef = useRef();&#10;    const [playerName, setPlayerName] = useState(&quot;&quot;);&#10;    const [carPosition, setCarPosition] = useState([0, 1, 0]);&#10;    const [carRotation, setCarRotation] = useState(0);&#10;&#10;    const handlePositionChange = (position, rotation) =&gt; {&#10;        setCarPosition(position);&#10;        setCarRotation(rotation);&#10;    };&#10;&#10;    return (&#10;        &lt;div style={{ width: &quot;100vw&quot;, height: &quot;100vh&quot;, backgroundColor: &quot;white&quot; }}&gt;&#10;            &lt;PlayerName onNameSet={setPlayerName} /&gt;&#10;            &lt;Timer /&gt;&#10;            &lt;Canvas shadows camera={{ position: [0, 8, 15], fov: 60 }}&gt;&#10;                {/* Iluminação */}&#10;                &lt;ambientLight intensity={0.6} /&gt;&#10;                &lt;directionalLight&#10;                    position={[20, 20, 10]}&#10;                    intensity={1.5}&#10;                    castShadow&#10;                    shadow-mapSize-width={2048}&#10;                    shadow-mapSize-height={2048}&#10;                    shadow-camera-left={-50}&#10;                    shadow-camera-right={50}&#10;                    shadow-camera-top={50}&#10;                    shadow-camera-bottom={-50}&#10;                /&gt;&#10;&#10;                {/* Componentes do jogo */}&#10;                &lt;Track /&gt;&#10;                &lt;Car&#10;                    ref={carRef}&#10;                    position={[0, 1, 0]}&#10;                    onPositionChange={handlePositionChange}&#10;                /&gt;&#10;                &lt;Camera target={carRef} /&gt;&#10;&#10;                {/* Label do jogador */}&#10;                {playerName &amp;&amp; (&#10;                    &lt;PlayerNameLabel&#10;                        position={carPosition}&#10;                        playerName={playerName}&#10;                        carRotation={carRotation}&#10;                    /&gt;&#10;                )}&#10;            &lt;/Canvas&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;export default App;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/Camera.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/Camera.tsx" />
              <option name="originalContent" value="import { useFrame, useThree } from &quot;@react-three/fiber&quot;;&#10;import React, { useRef } from &quot;react&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type CameraProps = {&#10;    target: React.RefObject&lt;THREE.Group&gt;;&#10;};&#10;&#10;export default function Camera({ target }: CameraProps) {&#10;    const { camera } = useThree();&#10;    const tempPos = new THREE.Vector3();&#10;    const tempTarget = new THREE.Vector3();&#10;    const currentFov = useRef(50); // FOV atual da câmera&#10;&#10;    useFrame(() =&gt; {&#10;        if (!target.current) return;&#10;&#10;        const carPos = target.current.position;&#10;        const carRot = target.current.rotation.y;&#10;&#10;        // Calcula velocidade aproximada baseada na posição anterior&#10;        const velocity = target.current.userData.velocity || new THREE.Vector3();&#10;        const speed = velocity.length();&#10;&#10;        // Ajusta FOV baseado na velocidade (zoom out quando acelera)&#10;        const baseFov = 50;&#10;        const maxSpeedFov = 85; // FOV máximo quando em alta velocidade&#10;        const targetFov = baseFov + (speed * 1); // multiplicador mais suave&#10;        const clampedFov = Math.min(targetFov, maxSpeedFov);&#10;&#10;        // Suaviza a transição do FOV&#10;        currentFov.current = THREE.MathUtils.lerp(currentFov.current, clampedFov, 0.05);&#10;        camera.fov = currentFov.current;&#10;        camera.updateProjectionMatrix();&#10;&#10;        // Ajusta distância da câmera baseada na velocidade&#10;        const baseDistance = 8;&#10;        const speedDistance = speed * 1; // distância adicional por velocidade&#10;        const totalDistance = baseDistance + speedDistance;&#10;&#10;        // offset atrás do carro com distância dinâmica&#10;        const offset = new THREE.Vector3(0, 5, -totalDistance);&#10;        const rotatedOffset = offset.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), carRot);&#10;        tempPos.copy(carPos).add(rotatedOffset);&#10;&#10;        // suaviza movimento da câmera&#10;        camera.position.lerp(tempPos, 0.1); // lerp mais suave&#10;&#10;        // olha para o carro&#10;        camera.lookAt(carPos);&#10;    });&#10;&#10;    return null;&#10;}&#10;" />
              <option name="updatedContent" value="import { useFrame, useThree } from &quot;@react-three/fiber&quot;;&#10;import React, { useRef } from &quot;react&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type CameraProps = {&#10;    target: React.RefObject&lt;THREE.Group&gt;;&#10;};&#10;&#10;export default function Camera({ target }: CameraProps) {&#10;    const { camera } = useThree();&#10;    const tempPos = new THREE.Vector3();&#10;    const tempTarget = new THREE.Vector3();&#10;    const currentFov = useRef(45); // FOV base menor (era 50)&#10;&#10;    useFrame(() =&gt; {&#10;        if (!target.current) return;&#10;&#10;        const carPos = target.current.position;&#10;        const carRot = target.current.rotation.y;&#10;&#10;        // Calcula velocidade aproximada baseada na posição anterior&#10;        const velocity = target.current.userData.velocity || new THREE.Vector3();&#10;        const speed = velocity.length();&#10;&#10;        // Ajusta FOV baseado na velocidade com menos variação&#10;        const baseFov = 45; // FOV base menor&#10;        const maxSpeedFov = 55; // FOV máximo menor (era 85)&#10;        const targetFov = baseFov + (speed * 0.5); // multiplicador muito mais suave (era 1)&#10;        const clampedFov = Math.min(targetFov, maxSpeedFov);&#10;&#10;        // Suaviza a transição do FOV ainda mais&#10;        currentFov.current = THREE.MathUtils.lerp(currentFov.current, clampedFov, 0.02); // mais suave (era 0.05)&#10;        camera.fov = currentFov.current;&#10;        camera.updateProjectionMatrix();&#10;&#10;        // Ajusta distância da câmera com menos variação&#10;        const baseDistance = 10; // distância base maior&#10;        const speedDistance = speed * 0.5; // menos variação por velocidade (era 1)&#10;        const totalDistance = baseDistance + speedDistance;&#10;&#10;        // offset atrás do carro&#10;        const offset = new THREE.Vector3(0, 4, -totalDistance); // altura menor (era 5)&#10;        const rotatedOffset = offset.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), carRot);&#10;        tempPos.copy(carPos).add(rotatedOffset);&#10;&#10;        // movimento da câmera muito mais suave&#10;        camera.position.lerp(tempPos, 0.05); // muito mais suave (era 0.1)&#10;&#10;        // olha para o carro&#10;        camera.lookAt(carPos);&#10;    });&#10;&#10;    return null;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/Car.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/Car.tsx" />
              <option name="originalContent" value="import React, { useRef, useEffect, useState, forwardRef, useMemo } from &quot;react&quot;;&#10;import { useFrame } from &quot;@react-three/fiber&quot;;&#10;import { useGLTF } from &quot;@react-three/drei&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type CarProps = {&#10;    position?: [number, number, number];&#10;    onPositionChange?: (position: [number, number, number], rotation: number) =&gt; void;&#10;};&#10;&#10;const Car = forwardRef&lt;THREE.Group, CarProps&gt;(({ position = [0, 0.5, 0], onPositionChange }, ref) =&gt; {&#10;    const groupRef = useRef&lt;THREE.Group&gt;(null);&#10;    const [keys, setKeys] = useState&lt;{ [key: string]: boolean }&gt;({});&#10;    const velocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const angleRef = useRef(0);&#10;    const fallingRef = useRef(false);&#10;    const fallTimeRef = useRef(0);&#10;    const rotationVelocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const initialPosition = useRef(new THREE.Vector3(...position));&#10;    const [selectedCar, setSelectedCar] = useState(() =&gt; {&#10;        const carNumber = Math.floor(Math.random() * 4) + 1;&#10;        console.log(`Carro selecionado: car${carNumber}.glb`);&#10;        return `/models/car${carNumber}.glb`;&#10;    });&#10;&#10;    // Carrega o modelo GLB randomizado&#10;    const { scene } = useGLTF(selectedCar);&#10;&#10;    useEffect(() =&gt; {&#10;        if (!ref || !groupRef.current) return;&#10;        if (typeof ref === &quot;function&quot;) ref(groupRef.current);&#10;        else ref.current = groupRef.current;&#10;    }, [ref]);&#10;&#10;    useEffect(() =&gt; {&#10;        const down = (e: KeyboardEvent) =&gt; setKeys(k =&gt; ({ ...k, [e.key]: true }));&#10;        const up = (e: KeyboardEvent) =&gt; setKeys(k =&gt; ({ ...k, [e.key]: false }));&#10;        window.addEventListener(&quot;keydown&quot;, down);&#10;        window.addEventListener(&quot;keyup&quot;, up);&#10;        return () =&gt; {&#10;            window.removeEventListener(&quot;keydown&quot;, down);&#10;            window.removeEventListener(&quot;keyup&quot;, up);&#10;        };&#10;    }, []);&#10;&#10;    useFrame((state, delta) =&gt; {&#10;        const current = groupRef.current;&#10;        if (!current) return;&#10;&#10;        // Se está caindo, apenas aplica gravidade e rotação&#10;        if (fallingRef.current) {&#10;            velocityRef.current.y -= 9.8 * delta; // gravidade&#10;&#10;            // Continua movimento horizontal durante a queda&#10;            const direction = new THREE.Vector3(&#10;                Math.sin(angleRef.current) * velocityRef.current.z,&#10;                0,&#10;                Math.cos(angleRef.current) * velocityRef.current.z&#10;            );&#10;            current.position.add(direction);&#10;            current.position.add(new THREE.Vector3(0, velocityRef.current.y * delta, 0));&#10;&#10;            // Rotação realista durante a queda (frente cai primeiro)&#10;            rotationVelocityRef.current.x += 2 * delta;&#10;            current.rotation.x += rotationVelocityRef.current.x * delta;&#10;&#10;            fallTimeRef.current += delta;&#10;&#10;            // Respawn após 3 segundos&#10;            if (fallTimeRef.current &gt;= 3) {&#10;                // Posição aleatória na plataforma (evita bordas)&#10;                const randomX = (Math.random() - 0.5) * 120; // 120 de 200 para evitar bordas&#10;                const randomZ = (Math.random() - 0.5) * 120;&#10;                const randomAngle = Math.random() * Math.PI * 2; // rotação aleatória&#10;&#10;                current.position.set(randomX, initialPosition.current.y, randomZ);&#10;                velocityRef.current.set(0, 0, 0);&#10;                rotationVelocityRef.current.set(0, 0, 0);&#10;                angleRef.current = randomAngle;&#10;                current.rotation.set(0, randomAngle, 0);&#10;                fallingRef.current = false;&#10;                fallTimeRef.current = 0;&#10;&#10;                // Muda o carro no respawn&#10;                const carNumber = Math.floor(Math.random() * 4) + 1;&#10;                const newCarPath = `/models/car${carNumber}.glb`;&#10;                console.log(`Novo carro selecionado: car${carNumber}.glb`);&#10;                setSelectedCar(newCarPath);&#10;            }&#10;            return;&#10;        }&#10;&#10;        const velocity = velocityRef.current;&#10;        let angle = angleRef.current;&#10;&#10;        const acceleration = 0.02;&#10;        const maxSpeed = 0.5;&#10;        const turnSpeed = 0.03;&#10;        const friction = 0.99;&#10;        const brakeForce = 0.08; // força do freio (mais fraca que aceleração)&#10;        const reverseAcceleration = 0.01; // aceleração em ré (mais lenta)&#10;        const maxReverseSpeed = 0.2; // velocidade máxima em ré (mais baixa)&#10;&#10;        if (keys[&quot;ArrowUp&quot;] || keys[&quot;w&quot;]) {&#10;            velocity.z = Math.min(velocity.z + acceleration, maxSpeed);&#10;        }&#10;&#10;        if (keys[&quot;ArrowDown&quot;] || keys[&quot;s&quot;]) {&#10;            // Se está indo para frente, aplica freio gradual&#10;            if (velocity.z &gt; 0.8) { // threshold mínimo para considerar &quot;parado&quot;&#10;                velocity.z = Math.max(velocity.z - brakeForce, 0);&#10;            }&#10;            // Só permite ré quando realmente parou&#10;            else if (velocity.z &lt;= 0.2 &amp;&amp; velocity.z &gt;= -0.1) {&#10;                velocity.z = Math.max(velocity.z - reverseAcceleration, -maxReverseSpeed);&#10;            }&#10;        }&#10;&#10;        const speedFactor = Math.abs(velocity.z) / maxSpeed;&#10;        if ((keys[&quot;ArrowLeft&quot;] || keys[&quot;a&quot;]) &amp;&amp; speedFactor &gt; 0.1) {&#10;            angle += turnSpeed * speedFactor;&#10;        }&#10;        if ((keys[&quot;ArrowRight&quot;] || keys[&quot;d&quot;]) &amp;&amp; speedFactor &gt; 0.1) {&#10;            angle -= turnSpeed * speedFactor;&#10;        }&#10;&#10;        velocity.multiplyScalar(friction);&#10;&#10;        const direction = new THREE.Vector3(&#10;            Math.sin(angle) * velocity.z,&#10;            0,&#10;            Math.cos(angle) * velocity.z&#10;        );&#10;&#10;        current.position.add(direction);&#10;        current.rotation.y = angle;&#10;&#10;        // Verifica se a frente do carro saiu da plataforma (física mais realista)&#10;        const trackSize = 200;&#10;        const carLength = 3; // comprimento aproximado do carro&#10;&#10;        // Calcula posição da frente do carro&#10;        const frontX = current.position.x + Math.sin(angle) * carLength;&#10;        const frontZ = current.position.z + Math.cos(angle) * carLength;&#10;&#10;        if (Math.abs(frontX) &gt; trackSize/2 || Math.abs(frontZ) &gt; trackSize/2) {&#10;            if (!fallingRef.current) {&#10;                fallingRef.current = true;&#10;                velocityRef.current.y = 0; // inicia queda&#10;                rotationVelocityRef.current.set(0, 0, 0);&#10;            }&#10;        }&#10;&#10;        // Armazena velocidade para a câmera acessar&#10;        current.userData.velocity = velocity.clone();&#10;&#10;        // Atualiza posição para o label do jogador&#10;        if (onPositionChange) {&#10;            onPositionChange([current.position.x, current.position.y, current.position.z], angle);&#10;        }&#10;&#10;        angleRef.current = angle;&#10;    });&#10;&#10;    return (&#10;        &lt;group ref={groupRef} position={position} castShadow&gt;&#10;            &lt;primitive object={scene.clone()} scale={[5, 5, 5]} rotation={[0, Math.PI / 2, 0]} /&gt;&#10;        &lt;/group&gt;&#10;    );&#10;});&#10;&#10;for (let i = 1; i &lt;= 4; i++) {&#10;    useGLTF.preload(`/models/car${i}.glb`);&#10;}&#10;&#10;export default Car;&#10;&#10;" />
              <option name="updatedContent" value="import React, { useRef, useEffect, useState, forwardRef, useMemo } from &quot;react&quot;;&#10;import { useFrame } from &quot;@react-three/fiber&quot;;&#10;import { useGLTF } from &quot;@react-three/drei&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type CarProps = {&#10;    position?: [number, number, number];&#10;    onPositionChange?: (position: [number, number, number], rotation: number) =&gt; void;&#10;};&#10;&#10;const Car = forwardRef&lt;THREE.Group, CarProps&gt;(({ position = [0, 0.5, 0], onPositionChange }, ref) =&gt; {&#10;    const groupRef = useRef&lt;THREE.Group&gt;(null);&#10;    const [keys, setKeys] = useState&lt;{ [key: string]: boolean }&gt;({});&#10;    const velocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const angleRef = useRef(0);&#10;    const fallingRef = useRef(false);&#10;    const fallTimeRef = useRef(0);&#10;    const rotationVelocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const initialPosition = useRef(new THREE.Vector3(...position));&#10;    const [selectedCar, setSelectedCar] = useState(() =&gt; {&#10;        const carNumber = Math.floor(Math.random() * 4) + 1;&#10;        console.log(`Carro selecionado: car${carNumber}.glb`);&#10;        return `/models/car${carNumber}.glb`;&#10;    });&#10;&#10;    // Carrega o modelo GLB randomizado&#10;    const { scene } = useGLTF(selectedCar);&#10;&#10;    useEffect(() =&gt; {&#10;        if (!ref || !groupRef.current) return;&#10;        if (typeof ref === &quot;function&quot;) ref(groupRef.current);&#10;        else ref.current = groupRef.current;&#10;    }, [ref]);&#10;&#10;    useEffect(() =&gt; {&#10;        const down = (e: KeyboardEvent) =&gt; setKeys(k =&gt; ({ ...k, [e.key]: true }));&#10;        const up = (e: KeyboardEvent) =&gt; setKeys(k =&gt; ({ ...k, [e.key]: false }));&#10;        window.addEventListener(&quot;keydown&quot;, down);&#10;        window.addEventListener(&quot;keyup&quot;, up);&#10;        return () =&gt; {&#10;            window.removeEventListener(&quot;keydown&quot;, down);&#10;            window.removeEventListener(&quot;keyup&quot;, up);&#10;        };&#10;    }, []);&#10;&#10;    useFrame((state, delta) =&gt; {&#10;        const current = groupRef.current;&#10;        if (!current) return;&#10;&#10;        // Se está caindo, apenas aplica gravidade e rotação&#10;        if (fallingRef.current) {&#10;            velocityRef.current.y -= 9.8 * delta; // gravidade&#10;&#10;            // Continua movimento horizontal durante a queda&#10;            const direction = new THREE.Vector3(&#10;                Math.sin(angleRef.current) * velocityRef.current.z,&#10;                0,&#10;                Math.cos(angleRef.current) * velocityRef.current.z&#10;            );&#10;            current.position.add(direction);&#10;            current.position.add(new THREE.Vector3(0, velocityRef.current.y * delta, 0));&#10;&#10;            // Rotação realista durante a queda (frente cai primeiro)&#10;            rotationVelocityRef.current.x += 2 * delta;&#10;            current.rotation.x -= rotationVelocityRef.current.x * delta; // mudança aqui: menos ao invés de mais&#10;&#10;            fallTimeRef.current += delta;&#10;&#10;            // Respawn após 3 segundos&#10;            if (fallTimeRef.current &gt;= 3) {&#10;                // Posição aleatória na plataforma (evita bordas)&#10;                const randomX = (Math.random() - 0.5) * 120; // 120 de 200 para evitar bordas&#10;                const randomZ = (Math.random() - 0.5) * 120;&#10;                const randomAngle = Math.random() * Math.PI * 2; // rotação aleatória&#10;&#10;                current.position.set(randomX, initialPosition.current.y, randomZ);&#10;                velocityRef.current.set(0, 0, 0);&#10;                rotationVelocityRef.current.set(0, 0, 0);&#10;                angleRef.current = randomAngle;&#10;                current.rotation.set(0, randomAngle, 0);&#10;                fallingRef.current = false;&#10;                fallTimeRef.current = 0;&#10;&#10;                // Muda o carro no respawn&#10;                const carNumber = Math.floor(Math.random() * 4) + 1;&#10;                const newCarPath = `/models/car${carNumber}.glb`;&#10;                console.log(`Novo carro selecionado: car${carNumber}.glb`);&#10;                setSelectedCar(newCarPath);&#10;            }&#10;            return;&#10;        }&#10;&#10;        const velocity = velocityRef.current;&#10;        let angle = angleRef.current;&#10;&#10;        const acceleration = 0.02;&#10;        const maxSpeed = 0.5;&#10;        const turnSpeed = 0.03;&#10;        const friction = 0.99;&#10;        const brakeForce = 0.08; // força do freio (mais fraca que aceleração)&#10;        const reverseAcceleration = 0.01; // aceleração em ré (mais lenta)&#10;        const maxReverseSpeed = 0.2; // velocidade máxima em ré (mais baixa)&#10;&#10;        if (keys[&quot;ArrowUp&quot;] || keys[&quot;w&quot;]) {&#10;            velocity.z = Math.min(velocity.z + acceleration, maxSpeed);&#10;        }&#10;&#10;        if (keys[&quot;ArrowDown&quot;] || keys[&quot;s&quot;]) {&#10;            // Se está indo para frente, aplica freio gradual&#10;            if (velocity.z &gt; 0.8) { // threshold mínimo para considerar &quot;parado&quot;&#10;                velocity.z = Math.max(velocity.z - brakeForce, 0);&#10;            }&#10;            // Só permite ré quando realmente parou&#10;            else if (velocity.z &lt;= 0.2 &amp;&amp; velocity.z &gt;= -0.1) {&#10;                velocity.z = Math.max(velocity.z - reverseAcceleration, -maxReverseSpeed);&#10;            }&#10;        }&#10;&#10;        const speedFactor = Math.abs(velocity.z) / maxSpeed;&#10;        if ((keys[&quot;ArrowLeft&quot;] || keys[&quot;a&quot;]) &amp;&amp; speedFactor &gt; 0.1) {&#10;            angle += turnSpeed * speedFactor;&#10;        }&#10;        if ((keys[&quot;ArrowRight&quot;] || keys[&quot;d&quot;]) &amp;&amp; speedFactor &gt; 0.1) {&#10;            angle -= turnSpeed * speedFactor;&#10;        }&#10;&#10;        velocity.multiplyScalar(friction);&#10;&#10;        const direction = new THREE.Vector3(&#10;            Math.sin(angle) * velocity.z,&#10;            0,&#10;            Math.cos(angle) * velocity.z&#10;        );&#10;&#10;        current.position.add(direction);&#10;        current.rotation.y = angle;&#10;&#10;        // Verifica se a frente do carro saiu da plataforma (física mais realista)&#10;        const trackSize = 200;&#10;        const carLength = 3; // comprimento aproximado do carro&#10;&#10;        // Calcula posição da frente do carro&#10;        const frontX = current.position.x + Math.sin(angle) * carLength;&#10;        const frontZ = current.position.z + Math.cos(angle) * carLength;&#10;&#10;        if (Math.abs(frontX) &gt; trackSize/2 || Math.abs(frontZ) &gt; trackSize/2) {&#10;            if (!fallingRef.current) {&#10;                fallingRef.current = true;&#10;                velocityRef.current.y = 0; // inicia queda&#10;                rotationVelocityRef.current.set(0, 0, 0);&#10;            }&#10;        }&#10;&#10;        // Armazena velocidade para a câmera acessar&#10;        current.userData.velocity = velocity.clone();&#10;&#10;        // Atualiza posição para o label do jogador&#10;        if (onPositionChange) {&#10;            onPositionChange([current.position.x, current.position.y, current.position.z], angle);&#10;        }&#10;&#10;        angleRef.current = angle;&#10;    });&#10;&#10;    return (&#10;        &lt;group ref={groupRef} position={position} castShadow&gt;&#10;            &lt;primitive object={scene.clone()} scale={[5, 5, 5]} rotation={[0, Math.PI / 2, 0]} /&gt;&#10;        &lt;/group&gt;&#10;    );&#10;});&#10;&#10;for (let i = 1; i &lt;= 4; i++) {&#10;    useGLTF.preload(`/models/car${i}.glb`);&#10;}&#10;&#10;export default Car;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/PlayerName.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/PlayerName.tsx" />
              <option name="updatedContent" value="import React, { useState, useEffect } from &quot;react&quot;;&#10;&#10;type PlayerNameProps = {&#10;    onNameSet: (name: string) =&gt; void;&#10;};&#10;&#10;export default function PlayerName({ onNameSet }: PlayerNameProps) {&#10;    const [name, setName] = useState(&quot;&quot;);&#10;    const [showInput, setShowInput] = useState(false);&#10;&#10;    useEffect(() =&gt; {&#10;        const savedName = localStorage.getItem(&quot;playerName&quot;);&#10;        if (savedName) {&#10;            onNameSet(savedName);&#10;        } else {&#10;            setShowInput(true);&#10;        }&#10;    }, [onNameSet]);&#10;&#10;    const handleSubmit = (e: React.FormEvent) =&gt; {&#10;        e.preventDefault();&#10;        if (name.trim()) {&#10;            localStorage.setItem(&quot;playerName&quot;, name.trim());&#10;            onNameSet(name.trim());&#10;            setShowInput(false);&#10;        }&#10;    };&#10;&#10;    if (!showInput) return null;&#10;&#10;    return (&#10;        &lt;div style={{&#10;            position: &quot;fixed&quot;,&#10;            top: 0,&#10;            left: 0,&#10;            width: &quot;100vw&quot;,&#10;            height: &quot;100vh&quot;,&#10;            backgroundColor: &quot;rgba(0, 0, 0, 0.7)&quot;,&#10;            display: &quot;flex&quot;,&#10;            alignItems: &quot;center&quot;,&#10;            justifyContent: &quot;center&quot;,&#10;            zIndex: 1000&#10;        }}&gt;&#10;            &lt;div style={{&#10;                backgroundColor: &quot;white&quot;,&#10;                padding: &quot;30px&quot;,&#10;                borderRadius: &quot;10px&quot;,&#10;                textAlign: &quot;center&quot;,&#10;                minWidth: &quot;300px&quot;&#10;            }}&gt;&#10;                &lt;h2 style={{ marginBottom: &quot;20px&quot;, color: &quot;#333&quot; }}&gt;&#10;                    Bem-vindo ao Jogo!&#10;                &lt;/h2&gt;&#10;                &lt;form onSubmit={handleSubmit}&gt;&#10;                    &lt;input&#10;                        type=&quot;text&quot;&#10;                        value={name}&#10;                        onChange={(e) =&gt; setName(e.target.value)}&#10;                        placeholder=&quot;Digite seu nome&quot;&#10;                        style={{&#10;                            padding: &quot;10px&quot;,&#10;                            fontSize: &quot;16px&quot;,&#10;                            border: &quot;2px solid #ddd&quot;,&#10;                            borderRadius: &quot;5px&quot;,&#10;                            marginBottom: &quot;20px&quot;,&#10;                            width: &quot;100%&quot;,&#10;                            outline: &quot;none&quot;&#10;                        }}&#10;                        autoFocus&#10;                    /&gt;&#10;                    &lt;button&#10;                        type=&quot;submit&quot;&#10;                        style={{&#10;                            padding: &quot;10px 20px&quot;,&#10;                            fontSize: &quot;16px&quot;,&#10;                            backgroundColor: &quot;#007bff&quot;,&#10;                            color: &quot;white&quot;,&#10;                            border: &quot;none&quot;,&#10;                            borderRadius: &quot;5px&quot;,&#10;                            cursor: &quot;pointer&quot;&#10;                        }}&#10;                    &gt;&#10;                        Começar Jogo&#10;                    &lt;/button&gt;&#10;                &lt;/form&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/PlayerNameLabel.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/PlayerNameLabel.tsx" />
              <option name="originalContent" value="import React from &quot;react&quot;;&#10;import { Text } from &quot;@react-three/drei&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type PlayerNameLabelProps = {&#10;    position: [number, number, number];&#10;    playerName: string;&#10;    carRotation: number;&#10;};&#10;&#10;export default function PlayerNameLabel({ position, playerName, carRotation }: PlayerNameLabelProps) {&#10;    // @ts-ignore&#10;    return (&#10;        &lt;group position={[position[0], position[1] + 6, position[2]]} rotation={[0, carRotation + Math.PI, 0]}&gt;&#10;            {/* Fundo retangular cinza */}&#10;            &lt;mesh&gt;&#10;                &lt;planeGeometry args={[playerName.length * 0.2 + 0.3, 0.5]} /&gt;&#10;                &lt;meshBasicMaterial color=&quot;#666666&quot; transparent opacity={0.3} /&gt;&#10;            &lt;/mesh&gt;&#10;&#10;            {/* Texto do nome */}&#10;            &lt;Text&#10;                position={[0, 0, 0.01]}&#10;                fontSize={0.3}&#10;                color=&quot;#ffffff&quot;&#10;                anchorX=&quot;center&quot;&#10;                anchorY=&quot;middle&quot;&#10;                material-transparent={true}&#10;                material-opacity={0.9}&#10;            &gt;&#10;                {playerName}&#10;            &lt;/Text&gt;&#10;        &lt;/group&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="import React from &quot;react&quot;;&#10;import { Text } from &quot;@react-three/drei&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type PlayerNameLabelProps = {&#10;    position: [number, number, number];&#10;    playerName: string;&#10;    carRotation: number;&#10;};&#10;&#10;export default function PlayerNameLabel({ position, playerName, carRotation }: PlayerNameLabelProps) {&#10;    // @ts-ignore&#10;    return (&#10;        &lt;group position={[position[0], position[1] + 3, position[2]]} rotation={[0, carRotation + Math.PI, 0]}&gt;&#10;            {/* Fundo retangular cinza */}&#10;            &lt;mesh&gt;&#10;                &lt;planeGeometry args={[playerName.length * 0.2 + 0.3, 0.5]} /&gt;&#10;                &lt;meshBasicMaterial color=&quot;#666666&quot; transparent opacity={0.3} /&gt;&#10;            &lt;/mesh&gt;&#10;&#10;            {/* Texto do nome */}&#10;            &lt;Text&#10;                position={[0, 0, 0.01]}&#10;                fontSize={0.3}&#10;                color=&quot;#ffffff&quot;&#10;                anchorX=&quot;center&quot;&#10;                anchorY=&quot;middle&quot;&#10;                material-transparent={true}&#10;                material-opacity={0.9}&#10;            &gt;&#10;                {playerName}&#10;            &lt;/Text&gt;&#10;        &lt;/group&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/Timer.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/Timer.tsx" />
              <option name="originalContent" value="import React, { useEffect, useState } from &quot;react&quot;;&#10;&#10;export default function Timer() {&#10;    const [time, setTime] = useState(0);&#10;&#10;    useEffect(() =&gt; {&#10;        const interval = setInterval(() =&gt; setTime(prev =&gt; prev + 0.01), 10);&#10;        return () =&gt; clearInterval(interval);&#10;    }, []);&#10;&#10;    const formatTime = (t: number) =&gt; {&#10;        const minutes = Math.floor(t / 60);&#10;        const seconds = (t % 60).toFixed(2);&#10;        return `${minutes}:${seconds.padStart(5, &quot;0&quot;)}`;&#10;    };&#10;&#10;    return (&#10;        &lt;div style={{ position: &quot;absolute&quot;, top: 20, left: 20, color: &quot;white&quot;, fontSize: &quot;24px&quot; }}&gt;&#10;            {formatTime(time)}&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="import React, { useEffect, useState } from &quot;react&quot;;&#10;&#10;export default function Timer() {&#10;    const [time, setTime] = useState(0);&#10;&#10;    useEffect(() =&gt; {&#10;        const interval = setInterval(() =&gt; setTime(prev =&gt; prev + 0.01), 10);&#10;        return () =&gt; clearInterval(interval);&#10;    }, []);&#10;&#10;    const formatTime = (t: number) =&gt; {&#10;        const minutes = Math.floor(t / 60);&#10;        const seconds = (t % 60).toFixed(2);&#10;        return `${minutes}:${seconds.padStart(5, &quot;0&quot;)}`;&#10;    };&#10;&#10;    return (&#10;        &lt;div style={{ position: &quot;absolute&quot;, top: 20, left: 20, color: &quot;black&quot;, fontSize: &quot;24px&quot; }}&gt;&#10;            {formatTime(time)}&#10;        &lt;/div&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/Track.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/Track.tsx" />
              <option name="originalContent" value="import React from &quot;react&quot;;&#10;&#10;export default function Track() {&#10;    const trackSize = 100; // plataforma quadrada 100x100&#10;&#10;    return (&#10;        &lt;group&gt;&#10;            {/* Plataforma principal quadrada */}&#10;            &lt;mesh position={[0, -1, 0]} receiveShadow&gt;&#10;                &lt;boxGeometry args={[trackSize, 2, trackSize]} /&gt;&#10;                &lt;meshStandardMaterial color=&quot;#2c2c2c&quot; /&gt;&#10;            &lt;/mesh&gt;&#10;        &lt;/group&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="import React from &quot;react&quot;;&#10;&#10;export default function Track() {&#10;    const trackSize = 200; // plataforma muito maior: 200x200&#10;&#10;    return (&#10;        &lt;group&gt;&#10;            {/* Plataforma principal quadrada */}&#10;            &lt;mesh position={[0, -1, 0]} receiveShadow&gt;&#10;                &lt;boxGeometry args={[trackSize, 2, trackSize]} /&gt;&#10;                &lt;meshStandardMaterial color=&quot;#808080&quot; /&gt;&#10;            &lt;/mesh&gt;&#10;        &lt;/group&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>