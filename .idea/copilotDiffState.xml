<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/client/src/components/Car.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/components/Car.tsx" />
              <option name="originalContent" value="import React, { useRef, useEffect, useState, forwardRef, useMemo } from &quot;react&quot;;&#10;import { useFrame } from &quot;@react-three/fiber&quot;;&#10;import { useGLTF } from &quot;@react-three/drei&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type CarProps = {&#10;    position?: [number, number, number];&#10;    onPositionChange?: (position: [number, number, number], rotation: number) =&gt; void;&#10;    onSendUpdate?: (position: [number, number, number], rotation: number, carModel: string) =&gt; void;&#10;    onPlayerFell?: () =&gt; void;&#10;    onPlayerRespawn?: (position: [number, number, number], rotation: number, carModel: string) =&gt; void;&#10;    onUpdateSelf?: (position: [number, number, number], rotation: number, carModel: string) =&gt; void;&#10;    onSelfFell?: () =&gt; void;&#10;    otherPlayers?: Map&lt;string, any&gt;;&#10;    currentPlayerId?: string;&#10;};&#10;&#10;const Car = forwardRef&lt;THREE.Group, CarProps&gt;(({&#10;    position = [0, 0.5, 0],&#10;    onPositionChange,&#10;    onSendUpdate,&#10;    onPlayerFell,&#10;    onPlayerRespawn,&#10;    onUpdateSelf,&#10;    onSelfFell,&#10;    otherPlayers,&#10;    currentPlayerId&#10;}, ref) =&gt; {&#10;    const groupRef = useRef&lt;THREE.Group&gt;(null);&#10;    const [keys, setKeys] = useState&lt;{ [key: string]: boolean }&gt;({});&#10;    const velocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const angleRef = useRef(0);&#10;    const fallingRef = useRef(false);&#10;    const fallTimeRef = useRef(0);&#10;    const rotationVelocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const initialPosition = useRef(new THREE.Vector3(...position));&#10;    const [selectedCar, setSelectedCar] = useState(() =&gt; {&#10;        const carNumber = Math.floor(Math.random() * 4) + 1;&#10;        return `/models/car${carNumber}.glb`;&#10;    });&#10;&#10;    const { scene } = useGLTF(selectedCar);&#10;&#10;    const getRandomSpawnPosition = () =&gt; {&#10;        const randomX = (Math.random() - 0.5) * 120;&#10;        const randomZ = (Math.random() - 0.5) * 120;&#10;        const randomAngle = Math.random() * Math.PI * 2;&#10;        return { position: [randomX, initialPosition.current.y, randomZ] as [number, number, number], angle: randomAngle };&#10;    };&#10;&#10;    useEffect(() =&gt; {&#10;        if (!ref || !groupRef.current) return;&#10;        if (typeof ref === &quot;function&quot;) ref(groupRef.current);&#10;        else ref.current = groupRef.current;&#10;    }, [ref]);&#10;&#10;    useEffect(() =&gt; {&#10;        const down = (e: KeyboardEvent) =&gt; setKeys(k =&gt; ({ ...k, [e.key]: true }));&#10;        const up = (e: KeyboardEvent) =&gt; setKeys(k =&gt; ({ ...k, [e.key]: false }));&#10;        window.addEventListener(&quot;keydown&quot;, down);&#10;        window.addEventListener(&quot;keyup&quot;, up);&#10;        return () =&gt; {&#10;            window.removeEventListener(&quot;keydown&quot;, down);&#10;            window.removeEventListener(&quot;keyup&quot;, up);&#10;        };&#10;    }, []);&#10;&#10;    const checkCollision = (pos1: THREE.Vector3, pos2: THREE.Vector3, minDistance = 5.5) =&gt; {&#10;        return pos1.distanceTo(pos2) &lt; minDistance;&#10;    };&#10;&#10;    const handleCollision = (myPos: THREE.Vector3, otherPos: THREE.Vector3, myVelocity: THREE.Vector3) =&gt; {&#10;        const separationDirection = new THREE.Vector3().subVectors(myPos, otherPos);&#10;        const distance = separationDirection.length();&#10;&#10;        if (distance &lt; 0.1) {&#10;            separationDirection.set(&#10;                (Math.random() - 0.5) * 2,&#10;                0,&#10;                (Math.random() - 0.5) * 2&#10;            );&#10;        }&#10;&#10;        separationDirection.normalize();&#10;&#10;        const minDistance = 4.5;&#10;        const separationForce = Math.max(0, (minDistance - distance) / minDistance) * 0.5;&#10;&#10;        const immediateForce = separationDirection.clone().multiplyScalar(separationForce * 2);&#10;        myPos.add(new THREE.Vector3(immediateForce.x, 0, immediateForce.z));&#10;&#10;        const velocityForce = separationDirection.clone().multiplyScalar(0.15);&#10;        myVelocity.add(new THREE.Vector3(velocityForce.x, 0, velocityForce.z));&#10;&#10;        const maxVelocity = 0.5;&#10;        if (myVelocity.length() &gt; maxVelocity) {&#10;            myVelocity.normalize().multiplyScalar(maxVelocity);&#10;        }&#10;&#10;        return separationDirection;&#10;    };&#10;&#10;    const resolveOverlap = (current: THREE.Group) =&gt; {&#10;        if (!otherPlayers || !currentPlayerId) return;&#10;&#10;        const maxIterations = 3;&#10;&#10;        for (let iteration = 0; iteration &lt; maxIterations; iteration++) {&#10;            let hasOverlap = false;&#10;&#10;            Array.from(otherPlayers.values()).forEach(otherPlayer =&gt; {&#10;                if (otherPlayer.id !== currentPlayerId &amp;&amp; !otherPlayer.falling) {&#10;                    const otherPos = new THREE.Vector3(...otherPlayer.position);&#10;                    const distance = current.position.distanceTo(otherPos);&#10;                    const minDistance = 4.5;&#10;&#10;                    if (distance &lt; minDistance) {&#10;                        hasOverlap = true;&#10;&#10;                        const direction = new THREE.Vector3()&#10;                            .subVectors(current.position, otherPos)&#10;                            .normalize();&#10;&#10;                        if (direction.length() &lt; 0.1) {&#10;                            direction.set(&#10;                                (Math.random() - 0.5) * 2,&#10;                                0,&#10;                                (Math.random() - 0.5) * 2&#10;                            ).normalize();&#10;                        }&#10;&#10;                        const pushDistance = (minDistance - distance) * 0.6;&#10;                        const pushVector = direction.multiplyScalar(pushDistance);&#10;                        current.position.add(new THREE.Vector3(pushVector.x, 0, pushVector.z));&#10;                    }&#10;                }&#10;            });&#10;&#10;            if (!hasOverlap) break;&#10;        }&#10;    };&#10;&#10;    useFrame((state, delta) =&gt; {&#10;        const current = groupRef.current;&#10;        if (!current) return;&#10;&#10;        const safeDelta = Math.min(delta, 1/30);&#10;&#10;        if (fallingRef.current) {&#10;            velocityRef.current.y -= 9.8 * safeDelta;&#10;&#10;            const direction = new THREE.Vector3(&#10;                Math.sin(angleRef.current) * velocityRef.current.z,&#10;                0,&#10;                Math.cos(angleRef.current) * velocityRef.current.z&#10;            );&#10;            current.position.add(direction);&#10;            current.position.add(new THREE.Vector3(0, velocityRef.current.y * safeDelta, 0));&#10;&#10;            rotationVelocityRef.current.x += 2 * safeDelta;&#10;            current.rotation.x -= rotationVelocityRef.current.x * safeDelta;&#10;&#10;            fallTimeRef.current += safeDelta;&#10;&#10;            if (fallTimeRef.current &gt;= 3) {&#10;                const spawnData = getRandomSpawnPosition();&#10;&#10;                current.position.set(...spawnData.position);&#10;                velocityRef.current.set(0, 0, 0);&#10;                rotationVelocityRef.current.set(0, 0, 0);&#10;                angleRef.current = spawnData.angle;&#10;                current.rotation.set(0, spawnData.angle, 0);&#10;                fallingRef.current = false;&#10;                fallTimeRef.current = 0;&#10;&#10;                const carNumber = Math.floor(Math.random() * 4) + 1;&#10;                const newCarPath = `/models/car${carNumber}.glb`;&#10;                setSelectedCar(newCarPath);&#10;&#10;                if (onPlayerRespawn) {&#10;                    onPlayerRespawn(&#10;                        spawnData.position,&#10;                        spawnData.angle,&#10;                        newCarPath&#10;                    );&#10;                }&#10;            }&#10;            return;&#10;        }&#10;&#10;        const velocity = velocityRef.current;&#10;        let angle = angleRef.current;&#10;&#10;        const acceleration = 0.02;&#10;        const maxSpeed = 0.4;&#10;        const turnSpeed = 0.03;&#10;        const friction = 0.99;&#10;        const brakeForce = 0.5;&#10;        const reverseAcceleration = 0.01;&#10;        const maxReverseSpeed = 0.2;&#10;&#10;        if (keys[&quot;ArrowUp&quot;] || keys[&quot;w&quot;]) {&#10;            velocity.z = Math.min(velocity.z + acceleration, maxSpeed);&#10;        }&#10;&#10;        if (keys[&quot;ArrowDown&quot;] || keys[&quot;s&quot;]) {&#10;            if (velocity.z &gt; 0.5) {&#10;                velocity.z = Math.max(velocity.z - brakeForce, 0);&#10;            }&#10;            else if (velocity.z &lt;= 0.3 &amp;&amp; velocity.z &gt;= -0.2) {&#10;                velocity.z = Math.max(velocity.z - reverseAcceleration, -maxReverseSpeed);&#10;            }&#10;        }&#10;&#10;        const speedFactor = Math.abs(velocity.z) / maxSpeed;&#10;        if ((keys[&quot;ArrowLeft&quot;] || keys[&quot;a&quot;]) &amp;&amp; speedFactor &gt; 0.1) {&#10;            angle += turnSpeed * speedFactor;&#10;        }&#10;        if ((keys[&quot;ArrowRight&quot;] || keys[&quot;d&quot;]) &amp;&amp; speedFactor &gt; 0.1) {&#10;            angle -= turnSpeed * speedFactor;&#10;        }&#10;&#10;        velocity.multiplyScalar(friction);&#10;&#10;        resolveOverlap(current);&#10;&#10;        if (otherPlayers &amp;&amp; currentPlayerId) {&#10;            Array.from(otherPlayers.values()).forEach(otherPlayer =&gt; {&#10;                if (otherPlayer.id !== currentPlayerId &amp;&amp; !otherPlayer.falling) {&#10;                    const otherPos = new THREE.Vector3(...otherPlayer.position);&#10;&#10;                    if (checkCollision(current.position, otherPos)) {&#10;                        handleCollision(current.position, otherPos, velocity);&#10;                    }&#10;                }&#10;            });&#10;        }&#10;&#10;        const movement = new THREE.Vector3(&#10;            Math.sin(angle) * velocity.z,&#10;            0,&#10;            Math.cos(angle) * velocity.z&#10;        );&#10;&#10;        current.position.add(movement);&#10;        current.rotation.y = angle;&#10;&#10;        const trackSize = 200;&#10;        const carLength = 3;&#10;&#10;        const frontX = current.position.x + Math.sin(angle) * carLength;&#10;        const frontZ = current.position.z + Math.cos(angle) * carLength;&#10;&#10;        if (Math.abs(frontX) &gt; trackSize/2 || Math.abs(frontZ) &gt; trackSize/2) {&#10;            if (!fallingRef.current) {&#10;                fallingRef.current = true;&#10;                velocityRef.current.y = 0;&#10;                rotationVelocityRef.current.set(0, 0, 0);&#10;&#10;                if (onPlayerFell) {&#10;                    onPlayerFell();&#10;                }&#10;&#10;                if (onSelfFell) {&#10;                    onSelfFell();&#10;                }&#10;            }&#10;        }&#10;&#10;        current.userData.velocity = velocity.clone();&#10;&#10;        if (onPositionChange) {&#10;            onPositionChange([current.position.x, current.position.y, current.position.z], angle);&#10;        }&#10;&#10;        if (onUpdateSelf) {&#10;            onUpdateSelf([current.position.x, current.position.y, current.position.z], angle, selectedCar);&#10;        }&#10;&#10;        if (onSendUpdate &amp;&amp; Math.random() &lt; 0.8) {&#10;            onSendUpdate(&#10;                [current.position.x, current.position.y, current.position.z],&#10;                angle,&#10;                selectedCar&#10;            );&#10;        }&#10;&#10;        angleRef.current = angle;&#10;    });&#10;&#10;    return (&#10;        &lt;group ref={groupRef} position={position} castShadow&gt;&#10;            &lt;primitive object={scene.clone()} scale={[3.2, 3.2, 3.2]} rotation={[0, Math.PI / 2, 0]} /&gt;&#10;        &lt;/group&gt;&#10;    );&#10;});&#10;&#10;for (let i = 1; i &lt;= 4; i++) {&#10;    useGLTF.preload(`/models/car${i}.glb`);&#10;}&#10;&#10;export default Car;&#10;" />
              <option name="updatedContent" value="import React, { useRef, useEffect, useState, forwardRef, useMemo } from &quot;react&quot;;&#10;import { useFrame } from &quot;@react-three/fiber&quot;;&#10;import { useGLTF } from &quot;@react-three/drei&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type CarProps = {&#10;    position?: [number, number, number];&#10;    onPositionChange?: (position: [number, number, number], rotation: number) =&gt; void;&#10;    onSendUpdate?: (position: [number, number, number], rotation: number, carModel: string) =&gt; void;&#10;    onPlayerFell?: () =&gt; void;&#10;    onPlayerRespawn?: (position: [number, number, number], rotation: number, carModel: string) =&gt; void;&#10;    onUpdateSelf?: (position: [number, number, number], rotation: number, carModel: string) =&gt; void;&#10;    onSelfFell?: () =&gt; void;&#10;    otherPlayers?: Map&lt;string, any&gt;;&#10;    currentPlayerId?: string;&#10;};&#10;&#10;const Car = forwardRef&lt;THREE.Group, CarProps&gt;(({&#10;    position = [0, 0.5, 0],&#10;    onPositionChange,&#10;    onSendUpdate,&#10;    onPlayerFell,&#10;    onPlayerRespawn,&#10;    onUpdateSelf,&#10;    onSelfFell,&#10;    otherPlayers,&#10;    currentPlayerId&#10;}, ref) =&gt; {&#10;    const groupRef = useRef&lt;THREE.Group&gt;(null);&#10;    const [keys, setKeys] = useState&lt;{ [key: string]: boolean }&gt;({});&#10;    const velocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const angleRef = useRef(0);&#10;    const fallingRef = useRef(false);&#10;    const fallTimeRef = useRef(0);&#10;    const rotationVelocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const initialPosition = useRef(new THREE.Vector3(...position));&#10;    const [selectedCar, setSelectedCar] = useState(() =&gt; {&#10;        const carNumber = Math.floor(Math.random() * 4) + 1;&#10;        return `/models/car${carNumber}.glb`;&#10;    });&#10;    const jumpVelocityRef = useRef(0);&#10;    const isJumpingRef = useRef(false);&#10;    const jumpCooldownRef = useRef(false);&#10;&#10;    const { scene } = useGLTF(selectedCar);&#10;&#10;    const getRandomSpawnPosition = () =&gt; {&#10;        const randomX = (Math.random() - 0.5) * 120;&#10;        const randomZ = (Math.random() - 0.5) * 120;&#10;        const randomAngle = Math.random() * Math.PI * 2;&#10;        return { position: [randomX, initialPosition.current.y, randomZ] as [number, number, number], angle: randomAngle };&#10;    };&#10;&#10;    useEffect(() =&gt; {&#10;        if (!ref || !groupRef.current) return;&#10;        if (typeof ref === &quot;function&quot;) ref(groupRef.current);&#10;        else ref.current = groupRef.current;&#10;    }, [ref]);&#10;&#10;    useEffect(() =&gt; {&#10;        const down = (e: KeyboardEvent) =&gt; setKeys(k =&gt; ({ ...k, [e.key]: true }));&#10;        const up = (e: KeyboardEvent) =&gt; setKeys(k =&gt; ({ ...k, [e.key]: false }));&#10;        window.addEventListener(&quot;keydown&quot;, down);&#10;        window.addEventListener(&quot;keyup&quot;, up);&#10;        return () =&gt; {&#10;            window.removeEventListener(&quot;keydown&quot;, down);&#10;            window.removeEventListener(&quot;keyup&quot;, up);&#10;        };&#10;    }, []);&#10;&#10;    const checkCollision = (pos1: THREE.Vector3, pos2: THREE.Vector3, minDistance = 5.5) =&gt; {&#10;        return pos1.distanceTo(pos2) &lt; minDistance;&#10;    };&#10;&#10;    const handleCollision = (myPos: THREE.Vector3, otherPos: THREE.Vector3, myVelocity: THREE.Vector3) =&gt; {&#10;        const separationDirection = new THREE.Vector3().subVectors(myPos, otherPos);&#10;        const distance = separationDirection.length();&#10;&#10;        if (distance &lt; 0.1) {&#10;            separationDirection.set(&#10;                (Math.random() - 0.5) * 2,&#10;                0,&#10;                (Math.random() - 0.5) * 2&#10;            );&#10;        }&#10;&#10;        separationDirection.normalize();&#10;&#10;        const minDistance = 4.5;&#10;        const separationForce = Math.max(0, (minDistance - distance) / minDistance) * 0.5;&#10;&#10;        const immediateForce = separationDirection.clone().multiplyScalar(separationForce * 2);&#10;        myPos.add(new THREE.Vector3(immediateForce.x, 0, immediateForce.z));&#10;&#10;        const velocityForce = separationDirection.clone().multiplyScalar(0.15);&#10;        myVelocity.add(new THREE.Vector3(velocityForce.x, 0, velocityForce.z));&#10;&#10;        const maxVelocity = 0.5;&#10;        if (myVelocity.length() &gt; maxVelocity) {&#10;            myVelocity.normalize().multiplyScalar(maxVelocity);&#10;        }&#10;&#10;        return separationDirection;&#10;    };&#10;&#10;    const resolveOverlap = (current: THREE.Group) =&gt; {&#10;        if (!otherPlayers || !currentPlayerId) return;&#10;&#10;        const maxIterations = 3;&#10;&#10;        for (let iteration = 0; iteration &lt; maxIterations; iteration++) {&#10;            let hasOverlap = false;&#10;&#10;            Array.from(otherPlayers.values()).forEach(otherPlayer =&gt; {&#10;                if (otherPlayer.id !== currentPlayerId &amp;&amp; !otherPlayer.falling) {&#10;                    const otherPos = new THREE.Vector3(...otherPlayer.position);&#10;                    const distance = current.position.distanceTo(otherPos);&#10;                    const minDistance = 4.5;&#10;&#10;                    if (distance &lt; minDistance) {&#10;                        hasOverlap = true;&#10;&#10;                        const direction = new THREE.Vector3()&#10;                            .subVectors(current.position, otherPos)&#10;                            .normalize();&#10;&#10;                        if (direction.length() &lt; 0.1) {&#10;                            direction.set(&#10;                                (Math.random() - 0.5) * 2,&#10;                                0,&#10;                                (Math.random() - 0.5) * 2&#10;                            ).normalize();&#10;                        }&#10;&#10;                        const pushDistance = (minDistance - distance) * 0.6;&#10;                        const pushVector = direction.multiplyScalar(pushDistance);&#10;                        current.position.add(new THREE.Vector3(pushVector.x, 0, pushVector.z));&#10;                    }&#10;                }&#10;            });&#10;&#10;            if (!hasOverlap) break;&#10;        }&#10;    };&#10;&#10;    useFrame((state, delta) =&gt; {&#10;        const current = groupRef.current;&#10;        if (!current) return;&#10;&#10;        const safeDelta = Math.min(delta, 1/30);&#10;&#10;        if (fallingRef.current) {&#10;            velocityRef.current.y -= 9.8 * safeDelta;&#10;&#10;            const direction = new THREE.Vector3(&#10;                Math.sin(angleRef.current) * velocityRef.current.z,&#10;                0,&#10;                Math.cos(angleRef.current) * velocityRef.current.z&#10;            );&#10;            current.position.add(direction);&#10;            current.position.add(new THREE.Vector3(0, velocityRef.current.y * safeDelta, 0));&#10;&#10;            rotationVelocityRef.current.x += 2 * safeDelta;&#10;            current.rotation.x -= rotationVelocityRef.current.x * safeDelta;&#10;&#10;            fallTimeRef.current += safeDelta;&#10;&#10;            if (fallTimeRef.current &gt;= 3) {&#10;                const spawnData = getRandomSpawnPosition();&#10;&#10;                current.position.set(...spawnData.position);&#10;                velocityRef.current.set(0, 0, 0);&#10;                rotationVelocityRef.current.set(0, 0, 0);&#10;                angleRef.current = spawnData.angle;&#10;                current.rotation.set(0, spawnData.angle, 0);&#10;                fallingRef.current = false;&#10;                fallTimeRef.current = 0;&#10;&#10;                const carNumber = Math.floor(Math.random() * 4) + 1;&#10;                const newCarPath = `/models/car${carNumber}.glb`;&#10;                setSelectedCar(newCarPath);&#10;&#10;                if (onPlayerRespawn) {&#10;                    onPlayerRespawn(&#10;                        spawnData.position,&#10;                        spawnData.angle,&#10;                        newCarPath&#10;                    );&#10;                }&#10;            }&#10;            return;&#10;        }&#10;&#10;        // Lógica do pulo&#10;        if (keys[&quot; &quot;] &amp;&amp; !isJumpingRef.current &amp;&amp; !jumpCooldownRef.current) {&#10;            jumpVelocityRef.current = 0.5; // Força inicial do pulo&#10;            isJumpingRef.current = true;&#10;            jumpCooldownRef.current = true;&#10;            setTimeout(() =&gt; jumpCooldownRef.current = false, 1500); // Cooldown de 1.5 segundos&#10;        }&#10;&#10;        if (isJumpingRef.current) {&#10;            jumpVelocityRef.current -= 1.2 * safeDelta; // Gravidade&#10;            current.position.y += jumpVelocityRef.current;&#10;&#10;            if (current.position.y &lt;= 0.5) { // Altura base do carro&#10;                current.position.y = 0.5;&#10;                isJumpingRef.current = false;&#10;                jumpVelocityRef.current = 0;&#10;            }&#10;        }&#10;&#10;        const velocity = velocityRef.current;&#10;        let angle = angleRef.current;&#10;&#10;        const acceleration = 0.02;&#10;        const maxSpeed = 0.4;&#10;        const turnSpeed = 0.03;&#10;        const friction = 0.99;&#10;        const brakeForce = 0.5;&#10;        const reverseAcceleration = 0.01;&#10;        const maxReverseSpeed = 0.2;&#10;&#10;        if (keys[&quot;ArrowUp&quot;] || keys[&quot;w&quot;]) {&#10;            velocity.z = Math.min(velocity.z + acceleration, maxSpeed);&#10;        }&#10;&#10;        if (keys[&quot;ArrowDown&quot;] || keys[&quot;s&quot;]) {&#10;            if (velocity.z &gt; 0.5) {&#10;                velocity.z = Math.max(velocity.z - brakeForce, 0);&#10;            }&#10;            else if (velocity.z &lt;= 0.3 &amp;&amp; velocity.z &gt;= -0.2) {&#10;                velocity.z = Math.max(velocity.z - reverseAcceleration, -maxReverseSpeed);&#10;            }&#10;        }&#10;&#10;        const speedFactor = Math.abs(velocity.z) / maxSpeed;&#10;        if ((keys[&quot;ArrowLeft&quot;] || keys[&quot;a&quot;]) &amp;&amp; speedFactor &gt; 0.1) {&#10;            angle += turnSpeed * speedFactor;&#10;        }&#10;        if ((keys[&quot;ArrowRight&quot;] || keys[&quot;d&quot;]) &amp;&amp; speedFactor &gt; 0.1) {&#10;            angle -= turnSpeed * speedFactor;&#10;        }&#10;&#10;        velocity.multiplyScalar(friction);&#10;&#10;        resolveOverlap(current);&#10;&#10;        // Modificar a verificação de colisão para considerar a altura&#10;        if (otherPlayers &amp;&amp; currentPlayerId) {&#10;            Array.from(otherPlayers.values()).forEach(otherPlayer =&gt; {&#10;                if (otherPlayer.id !== currentPlayerId &amp;&amp; !otherPlayer.falling) {&#10;                    const otherPos = new THREE.Vector3(...otherPlayer.position);&#10;                    const heightDiff = Math.abs(current.position.y - otherPos.y);&#10;&#10;                    if (checkCollision(current.position, otherPos) &amp;&amp; heightDiff &lt; 2) {&#10;                        handleCollision(current.position, otherPos, velocity);&#10;                    }&#10;                }&#10;            });&#10;        }&#10;&#10;        const movement = new THREE.Vector3(&#10;            Math.sin(angle) * velocity.z,&#10;            0,&#10;            Math.cos(angle) * velocity.z&#10;        );&#10;&#10;        current.position.add(movement);&#10;        current.rotation.y = angle;&#10;&#10;        const trackSize = 200;&#10;        const carLength = 3;&#10;&#10;        const frontX = current.position.x + Math.sin(angle) * carLength;&#10;        const frontZ = current.position.z + Math.cos(angle) * carLength;&#10;&#10;        if (Math.abs(frontX) &gt; trackSize/2 || Math.abs(frontZ) &gt; trackSize/2) {&#10;            if (!fallingRef.current) {&#10;                fallingRef.current = true;&#10;                velocityRef.current.y = 0;&#10;                rotationVelocityRef.current.set(0, 0, 0);&#10;&#10;                if (onPlayerFell) {&#10;                    onPlayerFell();&#10;                }&#10;&#10;                if (onSelfFell) {&#10;                    onSelfFell();&#10;                }&#10;            }&#10;        }&#10;&#10;        current.userData.velocity = velocity.clone();&#10;&#10;        if (onPositionChange) {&#10;            onPositionChange([current.position.x, current.position.y, current.position.z], angle);&#10;        }&#10;&#10;        if (onUpdateSelf) {&#10;            onUpdateSelf([current.position.x, current.position.y, current.position.z], angle, selectedCar);&#10;        }&#10;&#10;        if (onSendUpdate &amp;&amp; Math.random() &lt; 0.8) {&#10;            onSendUpdate(&#10;                [current.position.x, current.position.y, current.position.z],&#10;                angle,&#10;                selectedCar&#10;            );&#10;        }&#10;&#10;        angleRef.current = angle;&#10;    });&#10;&#10;    return (&#10;        &lt;group ref={groupRef} position={position} castShadow&gt;&#10;            &lt;primitive object={scene.clone()} scale={[3.2, 3.2, 3.2]} rotation={[0, Math.PI / 2, 0]} /&gt;&#10;        &lt;/group&gt;&#10;    );&#10;});&#10;&#10;for (let i = 1; i &lt;= 4; i++) {&#10;    useGLTF.preload(`/models/car${i}.glb`);&#10;}&#10;&#10;export default Car;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client/src/components/NewPlayerPopup.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/components/NewPlayerPopup.tsx" />
              <option name="updatedContent" value="import React, { useEffect, useState } from &quot;react&quot;;&#10;&#10;type NewPlayerPopupProps = {&#10;    playerName: string | null;&#10;    onClose: () =&gt; void;&#10;};&#10;&#10;export default function NewPlayerPopup({ playerName, onClose }: NewPlayerPopupProps) {&#10;    const [visible, setVisible] = useState(false);&#10;&#10;    useEffect(() =&gt; {&#10;        if (playerName) {&#10;            setVisible(true);&#10;            const timer = setTimeout(() =&gt; {&#10;                setVisible(false);&#10;                setTimeout(onClose, 300);&#10;            }, 3000);&#10;            return () =&gt; clearTimeout(timer);&#10;        }&#10;    }, [playerName, onClose]);&#10;&#10;    if (!playerName) return null;&#10;&#10;    return (&#10;        &lt;div className={`new-player-popup ${visible ? 'visible' : ''}`}&gt;&#10;            &lt;div className=&quot;new-player-content&quot;&gt;&#10;                &lt;div className=&quot;new-player-icon&quot;&gt;️&lt;/div&gt;&#10;                &lt;div className=&quot;new-player-text&quot;&gt;&#10;                    &lt;strong&gt;{playerName}&lt;/strong&gt; entrou na corrida!&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client/src/components/OtherPlayer.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/components/OtherPlayer.tsx" />
              <option name="originalContent" value="import React, { useRef, useEffect, useState } from &quot;react&quot;;&#10;import { useGLTF, Text } from &quot;@react-three/drei&quot;;&#10;import { useFrame, useThree } from &quot;@react-three/fiber&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type OtherPlayerProps = {&#10;    player: {&#10;        id: string;&#10;        name: string;&#10;        position: [number, number, number];&#10;        rotation: number;&#10;        carModel: string | number;&#10;        falling: boolean;&#10;    };&#10;};&#10;&#10;export default function OtherPlayer({ player }: OtherPlayerProps) {&#10;    const groupRef = useRef&lt;THREE.Group&gt;(null);&#10;    const nameRef = useRef&lt;THREE.Group&gt;(null);&#10;    const { camera } = useThree();&#10;&#10;    const targetPosition = useRef(new THREE.Vector3(...player.position));&#10;    const targetRotation = useRef(player.rotation);&#10;    const fallRotationRef = useRef(0);&#10;    const fallVelocityRef = useRef(0);&#10;    const lastPosition = useRef(new THREE.Vector3(...player.position));&#10;    const [isBeingPushed, setIsBeingPushed] = useState(false);&#10;    const [localFalling, setLocalFalling] = useState(false);&#10;    const rotationVelocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const smoothedPosition = useRef(new THREE.Vector3(...player.position));&#10;&#10;    const carNumber = typeof player.carModel === &quot;string&quot;&#10;        ? player.carModel.match(/car(\d+)\.glb/)?.[1] || &quot;1&quot;&#10;        : String(player.carModel);&#10;    const carPath = `/models/car${carNumber}.glb`;&#10;    const { scene } = useGLTF(carPath);&#10;&#10;    const getRandomSpawnPosition = (): [number, number, number] =&gt; {&#10;        const randomX = (Math.random() - 0.5) * 120;&#10;        const randomZ = (Math.random() - 0.5) * 120;&#10;        return [randomX, 0.5, randomZ];&#10;    };&#10;&#10;    useEffect(() =&gt; {&#10;        const newPos = new THREE.Vector3(...player.position);&#10;        const oldPos = lastPosition.current;&#10;        const distance = newPos.distanceTo(oldPos);&#10;&#10;        if (distance &gt; 50) {&#10;            setLocalFalling(false);&#10;            fallRotationRef.current = 0;&#10;            fallVelocityRef.current = 0;&#10;            rotationVelocityRef.current.set(0, 0, 0);&#10;&#10;            if (player.position[0] === 0 &amp;&amp; player.position[2] === 0) {&#10;                const randomPos = getRandomSpawnPosition();&#10;                targetPosition.current.set(...randomPos);&#10;            } else {&#10;                targetPosition.current.copy(newPos);&#10;            }&#10;        } else {&#10;            if (distance &gt; 0.8) {&#10;                setIsBeingPushed(true);&#10;                setTimeout(() =&gt; setIsBeingPushed(false), 200);&#10;            }&#10;            targetPosition.current.copy(newPos);&#10;        }&#10;&#10;        targetRotation.current = player.rotation;&#10;        lastPosition.current.copy(newPos);&#10;&#10;        if (!player.falling &amp;&amp; localFalling) {&#10;        } else if (player.falling &amp;&amp; !localFalling) {&#10;            setLocalFalling(true);&#10;        }&#10;    }, [player.position, player.rotation, player.falling]);&#10;&#10;    useFrame((state, delta) =&gt; {&#10;        if (!groupRef.current) return;&#10;        const safeDelta = Math.min(delta, 1 / 30);&#10;&#10;        const trackSize = 200;&#10;        const carLength = 3;&#10;        const angle = targetRotation.current;&#10;&#10;        const frontX = targetPosition.current.x + Math.sin(angle) * carLength;&#10;        const frontZ = targetPosition.current.z + Math.cos(angle) * carLength;&#10;&#10;        if ((Math.abs(frontX) &gt; trackSize/2 || Math.abs(frontZ) &gt; trackSize/2) &amp;&amp; !localFalling) {&#10;            setLocalFalling(true);&#10;            fallVelocityRef.current = 0;&#10;            rotationVelocityRef.current.set(0, 0, 0);&#10;        }&#10;&#10;        if (player.falling || localFalling) {&#10;            fallVelocityRef.current += 9.8 * safeDelta;&#10;            groupRef.current.position.y -= fallVelocityRef.current * safeDelta;&#10;&#10;            const horizontalMovement = new THREE.Vector3(&#10;                Math.sin(targetRotation.current) * 0.1,&#10;                0,&#10;                Math.cos(targetRotation.current) * 0.1&#10;            );&#10;            groupRef.current.position.add(horizontalMovement);&#10;&#10;            rotationVelocityRef.current.x += 2 * safeDelta;&#10;            groupRef.current.rotation.x -= rotationVelocityRef.current.x * safeDelta;&#10;&#10;            const currentY = groupRef.current.rotation.y;&#10;            const targetY = targetRotation.current;&#10;            groupRef.current.rotation.y = THREE.MathUtils.lerp(currentY, targetY, 0.8);&#10;        } else {&#10;            const lerpFactor = isBeingPushed ? 0.8 : 0.15;&#10;&#10;            smoothedPosition.current.lerp(targetPosition.current, lerpFactor);&#10;            groupRef.current.position.copy(smoothedPosition.current);&#10;&#10;            const currentY = groupRef.current.rotation.y;&#10;            const targetY = targetRotation.current;&#10;            groupRef.current.rotation.y = THREE.MathUtils.lerp(currentY, targetY, lerpFactor);&#10;&#10;            groupRef.current.rotation.x = THREE.MathUtils.lerp(groupRef.current.rotation.x, 0, 0.1);&#10;        }&#10;&#10;        if (nameRef.current) {&#10;            nameRef.current.position.set(&#10;                groupRef.current.position.x,&#10;                groupRef.current.position.y + 5,&#10;                groupRef.current.position.z&#10;            );&#10;            nameRef.current.lookAt(camera.position);&#10;        }&#10;    });&#10;&#10;    return (&#10;        &lt;group&gt;&#10;            &lt;group ref={groupRef} position={player.position} castShadow&gt;&#10;                &lt;primitive&#10;                    object={scene.clone()}&#10;                    scale={[3.2, 3.2, 3.2]}&#10;                    rotation={[0, Math.PI / 2, 0]}&#10;                /&gt;&#10;            &lt;/group&gt;&#10;&#10;            &lt;group ref={nameRef}&gt;&#10;                &lt;mesh&gt;&#10;                    &lt;planeGeometry args={[player.name.length * 0.5 + 0.5, 0.8]} /&gt;&#10;                    &lt;meshBasicMaterial color=&quot;#666666&quot; transparent opacity={0.8} /&gt;&#10;                &lt;/mesh&gt;&#10;&#10;                &lt;Text&#10;                    position={[0, 0, 0.01]}&#10;                    fontSize={0.8}&#10;                    color=&quot;#ffffff&quot;&#10;                    anchorX=&quot;center&quot;&#10;                    anchorY=&quot;middle&quot;&#10;                &gt;&#10;                    {player.name}&#10;                &lt;/Text&gt;&#10;            &lt;/group&gt;&#10;        &lt;/group&gt;&#10;    );&#10;}&#10;&#10;for (let i = 1; i &lt;= 4; i++) {&#10;    useGLTF.preload(`/models/car${i}.glb`);&#10;}&#10;" />
              <option name="updatedContent" value="import React, { useRef, useEffect, useState } from &quot;react&quot;;&#10;import { useGLTF, Text } from &quot;@react-three/drei&quot;;&#10;import { useFrame, useThree } from &quot;@react-three/fiber&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type OtherPlayerProps = {&#10;    player: {&#10;        id: string;&#10;        name: string;&#10;        position: [number, number, number];&#10;        rotation: number;&#10;        carModel: string | number;&#10;        falling: boolean;&#10;    };&#10;};&#10;&#10;export default function OtherPlayer({ player }: OtherPlayerProps) {&#10;    const groupRef = useRef&lt;THREE.Group&gt;(null);&#10;    const nameRef = useRef&lt;THREE.Group&gt;(null);&#10;    const { camera } = useThree();&#10;&#10;    const targetPosition = useRef(new THREE.Vector3(...player.position));&#10;    const targetRotation = useRef(player.rotation);&#10;    const fallRotationRef = useRef(0);&#10;    const fallVelocityRef = useRef(0);&#10;    const lastPosition = useRef(new THREE.Vector3(...player.position));&#10;    const [isBeingPushed, setIsBeingPushed] = useState(false);&#10;    const [localFalling, setLocalFalling] = useState(false);&#10;    const rotationVelocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const smoothedPosition = useRef(new THREE.Vector3(...player.position));&#10;&#10;    const carNumber = typeof player.carModel === &quot;string&quot;&#10;        ? player.carModel.match(/car(\d+)\.glb/)?.[1] || &quot;1&quot;&#10;        : String(player.carModel);&#10;    const carPath = `/models/car${carNumber}.glb`;&#10;    const { scene } = useGLTF(carPath);&#10;&#10;    const getRandomSpawnPosition = (): [number, number, number] =&gt; {&#10;        const randomX = (Math.random() - 0.5) * 120;&#10;        const randomZ = (Math.random() - 0.5) * 120;&#10;        return [randomX, 0.5, randomZ];&#10;    };&#10;&#10;    useEffect(() =&gt; {&#10;        const newPos = new THREE.Vector3(...player.position);&#10;        const oldPos = lastPosition.current;&#10;        const distance = newPos.distanceTo(oldPos);&#10;&#10;        if (distance &gt; 50) {&#10;            setLocalFalling(false);&#10;            fallRotationRef.current = 0;&#10;            fallVelocityRef.current = 0;&#10;            rotationVelocityRef.current.set(0, 0, 0);&#10;&#10;            if (player.position[0] === 0 &amp;&amp; player.position[2] === 0) {&#10;                const randomPos = getRandomSpawnPosition();&#10;                targetPosition.current.set(...randomPos);&#10;            } else {&#10;                targetPosition.current.copy(newPos);&#10;            }&#10;        } else {&#10;            if (distance &gt; 0.8) {&#10;                setIsBeingPushed(true);&#10;                setTimeout(() =&gt; setIsBeingPushed(false), 200);&#10;            }&#10;            targetPosition.current.copy(newPos);&#10;        }&#10;&#10;        targetRotation.current = player.rotation;&#10;        lastPosition.current.copy(newPos);&#10;&#10;        if (!player.falling &amp;&amp; localFalling) {&#10;        } else if (player.falling &amp;&amp; !localFalling) {&#10;            setLocalFalling(true);&#10;        }&#10;    }, [player.position, player.rotation, player.falling]);&#10;&#10;    useFrame((state, delta) =&gt; {&#10;        if (!groupRef.current) return;&#10;        const safeDelta = Math.min(delta, 1 / 30);&#10;&#10;        const trackSize = 200;&#10;        const carLength = 3;&#10;        const angle = targetRotation.current;&#10;&#10;        const frontX = targetPosition.current.x + Math.sin(angle) * carLength;&#10;        const frontZ = targetPosition.current.z + Math.cos(angle) * carLength;&#10;&#10;        if ((Math.abs(frontX) &gt; trackSize/2 || Math.abs(frontZ) &gt; trackSize/2) &amp;&amp; !localFalling) {&#10;            setLocalFalling(true);&#10;            fallVelocityRef.current = 0;&#10;            rotationVelocityRef.current.set(0, 0, 0);&#10;        }&#10;&#10;        if (player.falling || localFalling) {&#10;            fallVelocityRef.current += 9.8 * safeDelta;&#10;            groupRef.current.position.y -= fallVelocityRef.current * safeDelta;&#10;&#10;            const horizontalMovement = new THREE.Vector3(&#10;                Math.sin(targetRotation.current) * 0.1,&#10;                0,&#10;                Math.cos(targetRotation.current) * 0.1&#10;            );&#10;            groupRef.current.position.add(horizontalMovement);&#10;&#10;            rotationVelocityRef.current.x += 2 * safeDelta;&#10;            groupRef.current.rotation.x -= rotationVelocityRef.current.x * safeDelta;&#10;&#10;            const currentY = groupRef.current.rotation.y;&#10;            const targetY = targetRotation.current;&#10;            groupRef.current.rotation.y = THREE.MathUtils.lerp(currentY, targetY, 0.8);&#10;        } else {&#10;            const lerpFactor = isBeingPushed ? 0.8 : 0.15;&#10;            &#10;            // Agora usamos a altura real do jogador&#10;            smoothedPosition.current.lerp(new THREE.Vector3(&#10;                player.position[0],&#10;                player.position[1], // Altura do pulo é sincronizada&#10;                player.position[2]&#10;            ), lerpFactor);&#10;            &#10;            groupRef.current.position.copy(smoothedPosition.current);&#10;            &#10;            const currentY = groupRef.current.rotation.y;&#10;            const targetY = targetRotation.current;&#10;            groupRef.current.rotation.y = THREE.MathUtils.lerp(currentY, targetY, lerpFactor);&#10;&#10;            groupRef.current.rotation.x = THREE.MathUtils.lerp(groupRef.current.rotation.x, 0, 0.1);&#10;        }&#10;&#10;        // Atualiza a posição do nome para seguir a altura do pulo&#10;        if (nameRef.current) {&#10;            nameRef.current.position.set(&#10;                groupRef.current.position.x,&#10;                groupRef.current.position.y + 5, // Nome segue a altura do carro&#10;                groupRef.current.position.z&#10;            );&#10;            nameRef.current.lookAt(camera.position);&#10;        }&#10;    });&#10;&#10;    return (&#10;        &lt;group&gt;&#10;            &lt;group ref={groupRef} position={player.position} castShadow&gt;&#10;                &lt;primitive&#10;                    object={scene.clone()}&#10;                    scale={[3.2, 3.2, 3.2]}&#10;                    rotation={[0, Math.PI / 2, 0]}&#10;                /&gt;&#10;            &lt;/group&gt;&#10;&#10;            &lt;group ref={nameRef}&gt;&#10;                &lt;mesh&gt;&#10;                    &lt;planeGeometry args={[player.name.length * 0.5 + 0.5, 0.8]} /&gt;&#10;                    &lt;meshBasicMaterial color=&quot;#666666&quot; transparent opacity={0.8} /&gt;&#10;                &lt;/mesh&gt;&#10;&#10;                &lt;Text&#10;                    position={[0, 0, 0.01]}&#10;                    fontSize={0.8}&#10;                    color=&quot;#ffffff&quot;&#10;                    anchorX=&quot;center&quot;&#10;                    anchorY=&quot;middle&quot;&#10;                &gt;&#10;                    {player.name}&#10;                &lt;/Text&gt;&#10;            &lt;/group&gt;&#10;        &lt;/group&gt;&#10;    );&#10;}&#10;&#10;for (let i = 1; i &lt;= 4; i++) {&#10;    useGLTF.preload(`/models/car${i}.glb`);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client/src/hooks/useWebSocket.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/hooks/useWebSocket.js" />
              <option name="originalContent" value="import { useEffect, useRef, useState } from 'react';&#10;&#10;export function useWebSocket(playerName) {&#10;    const ws = useRef(null);&#10;    const [players, setPlayers] = useState(new Map());&#10;    const [connected, setConnected] = useState(false);&#10;    const [currentPlayerId, setCurrentPlayerId] = useState(null);&#10;    const [playerStats, setPlayerStats] = useState(new Map());&#10;    const heartbeatInterval = useRef(null);&#10;    const isWindowFocused = useRef(true);&#10;&#10;    const saveFallsToStorage = (playerId, playerName, falls) =&gt; {&#10;        const playerData = {&#10;            name: playerName,&#10;            falls: falls,&#10;            lastPlayed: Date.now()&#10;        };&#10;        localStorage.setItem(`player_${playerId}`, JSON.stringify(playerData));&#10;&#10;        localStorage.setItem(`playerStats_${playerName}`, JSON.stringify(playerData));&#10;    };&#10;&#10;    const loadFallsFromStorage = (playerName) =&gt; {&#10;        try {&#10;            const saved = localStorage.getItem(`playerStats_${playerName}`);&#10;            if (saved) {&#10;                const data = JSON.parse(saved);&#10;                return data.falls || 0;&#10;            }&#10;        } catch (error) {&#10;            console.error('Erro ao carregar quedas do localStorage:', error);&#10;        }&#10;        return 0;&#10;    };&#10;&#10;    useEffect(() =&gt; {&#10;        const handleFocus = () =&gt; {&#10;            isWindowFocused.current = true;&#10;        };&#10;&#10;        const handleBlur = () =&gt; {&#10;            isWindowFocused.current = false;&#10;            setTimeout(() =&gt; {&#10;                if (!isWindowFocused.current &amp;&amp; ws.current &amp;&amp; ws.current.readyState === WebSocket.OPEN) {&#10;                    ws.current.send(JSON.stringify({ type: 'INACTIVE' }));&#10;                }&#10;            }, 2000);&#10;        };&#10;&#10;        window.addEventListener('focus', handleFocus);&#10;        window.addEventListener('blur', handleBlur);&#10;        window.addEventListener('visibilitychange', () =&gt; {&#10;            if (document.hidden) {&#10;                handleBlur();&#10;            } else {&#10;                handleFocus();&#10;            }&#10;        });&#10;&#10;        return () =&gt; {&#10;            window.removeEventListener('focus', handleFocus);&#10;            window.removeEventListener('blur', handleBlur);&#10;        };&#10;    }, []);&#10;&#10;    useEffect(() =&gt; {&#10;        if (!playerName) return;&#10;&#10;        ws.current = new WebSocket('wss://ioficina.iopoint.com.br/ws/');&#10;&#10;        heartbeatInterval.current = setInterval(() =&gt; {&#10;            if (ws.current &amp;&amp; ws.current.readyState === WebSocket.OPEN) {&#10;                ws.current.send(JSON.stringify({&#10;                    type: 'HEARTBEAT',&#10;                    focused: isWindowFocused.current&#10;                }));&#10;            }&#10;        }, 5000);&#10;&#10;        ws.current.onopen = () =&gt; {&#10;            setConnected(true);&#10;&#10;            const savedFalls = loadFallsFromStorage(playerName);&#10;&#10;            ws.current.send(JSON.stringify({&#10;                type: 'JOIN',&#10;                playerName: playerName,&#10;                roomId: 'default',&#10;                carModel: Math.floor(Math.random() * 4) + 1,&#10;                savedFalls: savedFalls&#10;            }));&#10;        };&#10;&#10;        ws.current.onmessage = (event) =&gt; {&#10;            const data = JSON.parse(event.data);&#10;&#10;            switch (data.type) {&#10;                case 'JOIN_SUCCESS':&#10;                    setCurrentPlayerId(data.playerId);&#10;&#10;                    const savedFalls = loadFallsFromStorage(playerName);&#10;&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        newMap.set(data.playerId, {&#10;                            id: data.playerId,&#10;                            name: playerName,&#10;                            position: [0, 1, 0],&#10;                            rotation: 0,&#10;                            carModel: Math.floor(Math.random() * 4) + 1,&#10;                            falling: false&#10;                        });&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;                        newStats.set(data.playerId, {&#10;                            name: playerName,&#10;                            falls: savedFalls&#10;                        });&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'EXISTING_PLAYERS':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;&#10;                        data.players.forEach(player =&gt; {&#10;                            newMap.set(player.id, player);&#10;                        });&#10;&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;&#10;                        data.players.forEach(player =&gt; {&#10;                            newStats.set(player.id, {&#10;                                name: player.name,&#10;                                falls: player.falls || 0&#10;                            });&#10;                        });&#10;&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'PLAYER_JOINED':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        newMap.set(data.player.id, data.player);&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;                        newStats.set(data.player.id, {&#10;                            name: data.player.name,&#10;                            falls: data.player.falls || 0&#10;                        });&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'PLAYER_UPDATE':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        const player = newMap.get(data.playerId);&#10;                        if (player) {&#10;                            newMap.set(data.playerId, {&#10;                                ...player,&#10;                                position: data.position,&#10;                                rotation: data.rotation,&#10;                                carModel: data.carModel&#10;                            });&#10;                        }&#10;                        return newMap;&#10;                    });&#10;                    break;&#10;&#10;                case 'PLAYER_FELL':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        const player = newMap.get(data.playerId);&#10;                        if (player) {&#10;                            newMap.set(data.playerId, { ...player, falling: true });&#10;                        }&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;                        const playerStat = newStats.get(data.playerId);&#10;                        if (playerStat) {&#10;                            const newFalls = playerStat.falls + 1;&#10;                            newStats.set(data.playerId, {&#10;                                ...playerStat,&#10;                                falls: newFalls&#10;                            });&#10;&#10;                            if (data.playerId === currentPlayerId) {&#10;                                saveFallsToStorage(data.playerId, playerStat.name, newFalls);&#10;                            }&#10;                        }&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'PLAYER_RESPAWN':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        const player = newMap.get(data.playerId);&#10;                        if (player) {&#10;                            newMap.set(data.playerId, {&#10;                                ...player,&#10;                                position: data.position,&#10;                                rotation: data.rotation,&#10;                                carModel: data.carModel,&#10;                                falling: false&#10;                            });&#10;                        }&#10;                        return newMap;&#10;                    });&#10;                    break;&#10;&#10;                case 'PLAYER_LEFT':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        newMap.delete(data.playerId);&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;                        newStats.delete(data.playerId);&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'KICKED':&#10;                    alert('Você foi desconectado por inatividade!');&#10;                    window.location.reload();&#10;                    break;&#10;&#10;                case 'PONG':&#10;                    break;&#10;            }&#10;        };&#10;&#10;        ws.current.onclose = () =&gt; {&#10;            setConnected(false);&#10;        };&#10;&#10;        ws.current.onerror = (error) =&gt; {&#10;            console.error('Erro WebSocket:', error);&#10;        };&#10;&#10;        return () =&gt; {&#10;            if (heartbeatInterval.current) {&#10;                clearInterval(heartbeatInterval.current);&#10;            }&#10;            if (ws.current) {&#10;                ws.current.close();&#10;            }&#10;        };&#10;    }, [playerName]);&#10;&#10;    const sendPositionUpdate = (position, rotation, carModel) =&gt; {&#10;        if (ws.current &amp;&amp; ws.current.readyState === WebSocket.OPEN) {&#10;            ws.current.send(JSON.stringify({&#10;                type: 'UPDATE_POSITION',&#10;                position,&#10;                rotation,&#10;                carModel&#10;            }));&#10;        }&#10;    };&#10;&#10;    const sendPlayerFell = () =&gt; {&#10;        if (ws.current &amp;&amp; ws.current.readyState === WebSocket.OPEN) {&#10;            ws.current.send(JSON.stringify({&#10;                type: 'PLAYER_FELL'&#10;            }));&#10;        }&#10;    };&#10;&#10;    const sendPlayerRespawn = (position, rotation, carModel) =&gt; {&#10;        if (ws.current &amp;&amp; ws.current.readyState === WebSocket.OPEN) {&#10;            ws.current.send(JSON.stringify({&#10;                type: 'RESPAWN',&#10;                position,&#10;                rotation,&#10;                carModel&#10;            }));&#10;        }&#10;    };&#10;&#10;    const updateSelfPlayer = (position, rotation, carModel) =&gt; {&#10;        if (currentPlayerId) {&#10;            setPlayers(prev =&gt; {&#10;                const newMap = new Map(prev);&#10;                const player = newMap.get(currentPlayerId);&#10;                if (player) {&#10;                    newMap.set(currentPlayerId, {&#10;                        ...player,&#10;                        position,&#10;                        rotation,&#10;                        carModel&#10;                    });&#10;                }&#10;                return newMap;&#10;            });&#10;        }&#10;    };&#10;&#10;    const incrementSelfFalls = () =&gt; {&#10;        if (currentPlayerId) {&#10;            setPlayerStats(prev =&gt; {&#10;                const newStats = new Map(prev);&#10;                const playerStat = newStats.get(currentPlayerId);&#10;                if (playerStat) {&#10;                    const newFalls = playerStat.falls + 1;&#10;                    const updatedStat = {&#10;                        ...playerStat,&#10;                        falls: newFalls&#10;                    };&#10;                    newStats.set(currentPlayerId, updatedStat);&#10;&#10;                    saveFallsToStorage(currentPlayerId, playerStat.name, newFalls);&#10;                }&#10;                return newStats;&#10;            });&#10;        }&#10;    };&#10;&#10;    return {&#10;        players,&#10;        connected,&#10;        currentPlayerId,&#10;        playerStats,&#10;        sendPositionUpdate,&#10;        sendPlayerFell,&#10;        sendPlayerRespawn,&#10;        updateSelfPlayer,&#10;        incrementSelfFalls&#10;    };&#10;}&#10;" />
              <option name="updatedContent" value="import { useEffect, useRef, useState } from 'react';&#10;&#10;export function useWebSocket(playerName) {&#10;    const ws = useRef(null);&#10;    const [players, setPlayers] = useState(new Map());&#10;    const [connected, setConnected] = useState(false);&#10;    const [currentPlayerId, setCurrentPlayerId] = useState(null);&#10;    const [playerStats, setPlayerStats] = useState(new Map());&#10;    const heartbeatInterval = useRef(null);&#10;&#10;    const saveFallsToStorage = (playerId, playerName, falls) =&gt; {&#10;        const playerData = {&#10;            name: playerName,&#10;            falls: falls,&#10;            lastPlayed: Date.now()&#10;        };&#10;        localStorage.setItem(`player_${playerId}`, JSON.stringify(playerData));&#10;&#10;        localStorage.setItem(`playerStats_${playerName}`, JSON.stringify(playerData));&#10;    };&#10;&#10;    const loadFallsFromStorage = (playerName) =&gt; {&#10;        try {&#10;            const saved = localStorage.getItem(`playerStats_${playerName}`);&#10;            if (saved) {&#10;                const data = JSON.parse(saved);&#10;                return data.falls || 0;&#10;            }&#10;        } catch (error) {&#10;            console.error('Erro ao carregar quedas do localStorage:', error);&#10;        }&#10;        return 0;&#10;    };&#10;&#10;    useEffect(() =&gt; {&#10;        if (!playerName) return;&#10;&#10;        ws.current = new WebSocket('wss://ioficina.iopoint.com.br/ws/');&#10;&#10;        heartbeatInterval.current = setInterval(() =&gt; {&#10;            if (ws.current &amp;&amp; ws.current.readyState === WebSocket.OPEN) {&#10;                ws.current.send(JSON.stringify({&#10;                    type: 'HEARTBEAT'&#10;                }));&#10;            }&#10;        }, 5000);&#10;&#10;        ws.current.onopen = () =&gt; {&#10;            setConnected(true);&#10;&#10;            const savedFalls = loadFallsFromStorage(playerName);&#10;&#10;            ws.current.send(JSON.stringify({&#10;                type: 'JOIN',&#10;                playerName: playerName,&#10;                roomId: 'default',&#10;                carModel: Math.floor(Math.random() * 4) + 1,&#10;                savedFalls: savedFalls&#10;            }));&#10;        };&#10;&#10;        ws.current.onmessage = (event) =&gt; {&#10;            const data = JSON.parse(event.data);&#10;&#10;            switch (data.type) {&#10;                case 'JOIN_SUCCESS':&#10;                    setCurrentPlayerId(data.playerId);&#10;&#10;                    const savedFalls = loadFallsFromStorage(playerName);&#10;&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        newMap.set(data.playerId, {&#10;                            id: data.playerId,&#10;                            name: playerName,&#10;                            position: [0, 1, 0],&#10;                            rotation: 0,&#10;                            carModel: Math.floor(Math.random() * 4) + 1,&#10;                            falling: false&#10;                        });&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;                        newStats.set(data.playerId, {&#10;                            name: playerName,&#10;                            falls: savedFalls&#10;                        });&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'EXISTING_PLAYERS':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;&#10;                        data.players.forEach(player =&gt; {&#10;                            newMap.set(player.id, player);&#10;                        });&#10;&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;&#10;                        data.players.forEach(player =&gt; {&#10;                            newStats.set(player.id, {&#10;                                name: player.name,&#10;                                falls: player.falls || 0&#10;                            });&#10;                        });&#10;&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'PLAYER_JOINED':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        newMap.set(data.player.id, data.player);&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;                        newStats.set(data.player.id, {&#10;                            name: data.player.name,&#10;                            falls: data.player.falls || 0&#10;                        });&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'PLAYER_UPDATE':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        const player = newMap.get(data.playerId);&#10;                        if (player) {&#10;                            newMap.set(data.playerId, {&#10;                                ...player,&#10;                                position: data.position,&#10;                                rotation: data.rotation,&#10;                                carModel: data.carModel&#10;                            });&#10;                        }&#10;                        return newMap;&#10;                    });&#10;                    break;&#10;&#10;                case 'PLAYER_FELL':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        const player = newMap.get(data.playerId);&#10;                        if (player) {&#10;                            newMap.set(data.playerId, { ...player, falling: true });&#10;                        }&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;                        const playerStat = newStats.get(data.playerId);&#10;                        if (playerStat) {&#10;                            const newFalls = playerStat.falls + 1;&#10;                            newStats.set(data.playerId, {&#10;                                ...playerStat,&#10;                                falls: newFalls&#10;                            });&#10;&#10;                            if (data.playerId === currentPlayerId) {&#10;                                saveFallsToStorage(data.playerId, playerStat.name, newFalls);&#10;                            }&#10;                        }&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'PLAYER_RESPAWN':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        const player = newMap.get(data.playerId);&#10;                        if (player) {&#10;                            newMap.set(data.playerId, {&#10;                                ...player,&#10;                                position: data.position,&#10;                                rotation: data.rotation,&#10;                                carModel: data.carModel,&#10;                                falling: false&#10;                            });&#10;                        }&#10;                        return newMap;&#10;                    });&#10;                    break;&#10;&#10;                case 'PLAYER_LEFT':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        newMap.delete(data.playerId);&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;                        newStats.delete(data.playerId);&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'KICKED':&#10;                    window.location.reload();&#10;                    break;&#10;&#10;                case 'PONG':&#10;                    break;&#10;            }&#10;        };&#10;&#10;        ws.current.onclose = () =&gt; {&#10;            setConnected(false);&#10;        };&#10;&#10;        ws.current.onerror = (error) =&gt; {&#10;            console.error('Erro WebSocket:', error);&#10;        };&#10;&#10;        return () =&gt; {&#10;            if (heartbeatInterval.current) {&#10;                clearInterval(heartbeatInterval.current);&#10;            }&#10;            if (ws.current) {&#10;                ws.current.close();&#10;            }&#10;        };&#10;    }, [playerName]);&#10;&#10;    const sendPositionUpdate = (position, rotation, carModel) =&gt; {&#10;        if (ws.current &amp;&amp; ws.current.readyState === WebSocket.OPEN) {&#10;            ws.current.send(JSON.stringify({&#10;                type: 'UPDATE_POSITION',&#10;                position,&#10;                rotation,&#10;                carModel&#10;            }));&#10;        }&#10;    };&#10;&#10;    const sendPlayerFell = () =&gt; {&#10;        if (ws.current &amp;&amp; ws.current.readyState === WebSocket.OPEN) {&#10;            ws.current.send(JSON.stringify({&#10;                type: 'PLAYER_FELL'&#10;            }));&#10;        }&#10;    };&#10;&#10;    const sendPlayerRespawn = (position, rotation, carModel) =&gt; {&#10;        if (ws.current &amp;&amp; ws.current.readyState === WebSocket.OPEN) {&#10;            ws.current.send(JSON.stringify({&#10;                type: 'RESPAWN',&#10;                position,&#10;                rotation,&#10;                carModel&#10;            }));&#10;        }&#10;    };&#10;&#10;    const updateSelfPlayer = (position, rotation, carModel) =&gt; {&#10;        if (currentPlayerId) {&#10;            setPlayers(prev =&gt; {&#10;                const newMap = new Map(prev);&#10;                const player = newMap.get(currentPlayerId);&#10;                if (player) {&#10;                    newMap.set(currentPlayerId, {&#10;                        ...player,&#10;                        position,&#10;                        rotation,&#10;                        carModel&#10;                    });&#10;                }&#10;                return newMap;&#10;            });&#10;        }&#10;    };&#10;&#10;    const incrementSelfFalls = () =&gt; {&#10;        if (currentPlayerId) {&#10;            setPlayerStats(prev =&gt; {&#10;                const newStats = new Map(prev);&#10;                const playerStat = newStats.get(currentPlayerId);&#10;                if (playerStat) {&#10;                    const newFalls = playerStat.falls + 1;&#10;                    const updatedStat = {&#10;                        ...playerStat,&#10;                        falls: newFalls&#10;                    };&#10;                    newStats.set(currentPlayerId, updatedStat);&#10;&#10;                    saveFallsToStorage(currentPlayerId, playerStat.name, newFalls);&#10;                }&#10;                return newStats;&#10;            });&#10;        }&#10;    };&#10;&#10;    return {&#10;        players,&#10;        connected,&#10;        currentPlayerId,&#10;        playerStats,&#10;        sendPositionUpdate,&#10;        sendPlayerFell,&#10;        sendPlayerRespawn,&#10;        updateSelfPlayer,&#10;        incrementSelfFalls&#10;    };&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/package.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/package.json" />
              <option name="originalContent" value="{&#10;  &quot;name&quot;: &quot;formula-js-server&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;Servidor multiplayer para jogo de Fórmula 1&quot;,&#10;  &quot;main&quot;: &quot;server.js&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;start&quot;: &quot;node server.js&quot;,&#10;    &quot;dev&quot;: &quot;nodemon server.js&quot;&#10;  },&#10;  &quot;dependencies&quot;: {&#10;    &quot;ws&quot;: &quot;^8.14.2&quot;,&#10;    &quot;uuid&quot;: &quot;^9.0.1&quot;&#10;  },&#10;  &quot;devDependencies&quot;: {&#10;    &quot;nodemon&quot;: &quot;^3.0.1&quot;&#10;  }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;name&quot;: &quot;formula-js-server&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;Servidor multiplayer para jogo de Fórmula 1&quot;,&#10;  &quot;main&quot;: &quot;server.js&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;start&quot;: &quot;node server.js&quot;,&#10;    &quot;dev&quot;: &quot;nodemon server.js&quot;&#10;  },&#10;  &quot;dependencies&quot;: {&#10;    &quot;ws&quot;: &quot;^8.14.2&quot;,&#10;    &quot;uuid&quot;: &quot;^9.0.1&quot;&#10;  },&#10;  &quot;devDependencies&quot;: {&#10;    &quot;nodemon&quot;: &quot;^3.0.1&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/server.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/server.js" />
              <option name="originalContent" value="const WebSocket = require('ws');&#10;const { v4: uuidv4 } = require('uuid');&#10;&#10;const wss = new WebSocket.Server({ port: 8888 });&#10;&#10;const players = new Map();&#10;const rooms = new Map();&#10;&#10;&#10;setInterval(() =&gt; {&#10;    const now = Date.now();&#10;    players.forEach((player, playerId) =&gt; {&#10;        if (now - player.lastHeartbeat &gt; 15000) {&#10;&#10;            if (player.ws.readyState === WebSocket.OPEN) {&#10;                player.ws.send(JSON.stringify({ type: 'KICKED' }));&#10;                player.ws.close();&#10;            }&#10;&#10;            handlePlayerDisconnect(playerId);&#10;        }&#10;    });&#10;}, 10000);&#10;&#10;wss.on('connection', (ws) =&gt; {&#10;    const playerId = uuidv4();&#10;&#10;    ws.on('message', (message) =&gt; {&#10;        try {&#10;            const data = JSON.parse(message);&#10;&#10;            switch (data.type) {&#10;                case 'JOIN':&#10;                    handlePlayerJoin(ws, playerId, data);&#10;                    break;&#10;                case 'UPDATE_POSITION':&#10;                    handlePositionUpdate(playerId, data);&#10;                    break;&#10;                case 'PLAYER_FELL':&#10;                    handlePlayerFell(playerId, data);&#10;                    break;&#10;                case 'RESPAWN':&#10;                    handlePlayerRespawn(playerId, data);&#10;                    break;&#10;                case 'HEARTBEAT':&#10;                    handleHeartbeat(playerId, data);&#10;                    break;&#10;                case 'PING':&#10;                    ws.send(JSON.stringify({ type: 'PONG' }));&#10;                    break;&#10;            }&#10;        } catch (error) {&#10;        }&#10;    });&#10;&#10;    ws.on('close', () =&gt; {&#10;        handlePlayerDisconnect(playerId);&#10;    });&#10;&#10;    ws.on('error', (error) =&gt; {&#10;    });&#10;});&#10;&#10;function handlePlayerJoin(ws, playerId, data) {&#10;    const roomId = data.roomId || 'default';&#10;&#10;    if (!rooms.has(roomId)) {&#10;        rooms.set(roomId, new Set());&#10;    }&#10;&#10;    const savedFalls = typeof data.savedFalls === 'number' ? data.savedFalls : 0;&#10;&#10;    const player = {&#10;        id: playerId,&#10;        name: data.playerName,&#10;        ws: ws,&#10;        roomId: roomId,&#10;        position: [0, 1, 0],&#10;        rotation: 0,&#10;        carModel: String(data.carModel),&#10;        falling: false,&#10;        falls: savedFalls,&#10;        lastHeartbeat: Date.now(),&#10;        inactive: false,&#10;        inactiveTime: null&#10;    };&#10;&#10;    players.set(playerId, player);&#10;    rooms.get(roomId).add(playerId);&#10;&#10;&#10;    ws.send(JSON.stringify({&#10;        type: 'JOIN_SUCCESS',&#10;        playerId: playerId&#10;    }));&#10;&#10;    const existingPlayers = Array.from(rooms.get(roomId))&#10;        .filter(id =&gt; id !== playerId)&#10;        .map(id =&gt; {&#10;            const p = players.get(id);&#10;            return {&#10;                id: p.id,&#10;                name: p.name,&#10;                position: p.position,&#10;                rotation: p.rotation,&#10;                carModel: String(p.carModel),&#10;                falling: p.falling,&#10;                falls: p.falls&#10;            };&#10;        });&#10;&#10;    ws.send(JSON.stringify({&#10;        type: 'EXISTING_PLAYERS',&#10;        players: existingPlayers&#10;    }));&#10;&#10;    broadcastToRoom(roomId, {&#10;        type: 'PLAYER_JOINED',&#10;        player: {&#10;            id: playerId,&#10;            name: player.name,&#10;            position: player.position,&#10;            rotation: player.rotation,&#10;            carModel: String(player.carModel),&#10;            falling: player.falling,&#10;            falls: player.falls&#10;        }&#10;    }, playerId);&#10;&#10;}&#10;&#10;function handlePositionUpdate(playerId, data) {&#10;    const player = players.get(playerId);&#10;    if (!player) return;&#10;&#10;    player.position = data.position;&#10;    player.rotation = data.rotation;&#10;    player.carModel = String(data.carModel);&#10;&#10;    broadcastToRoom(player.roomId, {&#10;        type: 'PLAYER_UPDATE',&#10;        playerId: playerId,&#10;        position: data.position,&#10;        rotation: data.rotation,&#10;        carModel: String(data.carModel)&#10;    }, playerId);&#10;}&#10;&#10;function handlePlayerFell(playerId, data) {&#10;    const player = players.get(playerId);&#10;    if (!player) return;&#10;&#10;    player.falling = true;&#10;    player.falls += 1;&#10;&#10;    broadcastToRoom(player.roomId, {&#10;        type: 'PLAYER_FELL',&#10;        playerId: playerId,&#10;        falls: player.falls&#10;    }, playerId);&#10;}&#10;&#10;function handlePlayerRespawn(playerId, data) {&#10;    const player = players.get(playerId);&#10;    if (!player) return;&#10;&#10;    player.position = data.position;&#10;    player.rotation = data.rotation;&#10;    player.carModel = String(data.carModel);&#10;    player.falling = false;&#10;&#10;    broadcastToRoom(player.roomId, {&#10;        type: 'PLAYER_RESPAWN',&#10;        playerId: playerId,&#10;        position: data.position,&#10;        rotation: data.rotation,&#10;        carModel: String(data.carModel)&#10;    }, playerId);&#10;}&#10;&#10;function handlePlayerDisconnect(playerId) {&#10;    const player = players.get(playerId);&#10;    if (!player) return;&#10;&#10;    if (rooms.has(player.roomId)) {&#10;        rooms.get(player.roomId).delete(playerId);&#10;        if (rooms.get(player.roomId).size === 0) {&#10;            rooms.delete(player.roomId);&#10;        }&#10;    }&#10;&#10;    broadcastToRoom(player.roomId, {&#10;        type: 'PLAYER_LEFT',&#10;        playerId: playerId&#10;    });&#10;&#10;    players.delete(playerId);&#10;}&#10;&#10;function handleHeartbeat(playerId, data) {&#10;    const player = players.get(playerId);&#10;    if (!player) return;&#10;&#10;    player.lastHeartbeat = Date.now();&#10;&#10;    player.ws.send(JSON.stringify({ type: 'PONG' }));&#10;}&#10;&#10;function broadcastToRoom(roomId, message, excludePlayerId = null) {&#10;    if (!rooms.has(roomId)) return;&#10;&#10;    const room = rooms.get(roomId);&#10;    room.forEach(playerId =&gt; {&#10;        if (playerId === excludePlayerId) return;&#10;&#10;        const player = players.get(playerId);&#10;        if (player &amp;&amp; player.ws.readyState === WebSocket.OPEN) {&#10;            player.ws.send(JSON.stringify(message));&#10;        }&#10;    });&#10;}&#10;" />
              <option name="updatedContent" value="const WebSocket = require('ws');&#10;const { v4: uuidv4 } = require('uuid');&#10;&#10;const wss = new WebSocket.Server({ port: 8888 });&#10;&#10;const players = new Map();&#10;const rooms = new Map();&#10;&#10;&#10;setInterval(() =&gt; {&#10;    const now = Date.now();&#10;    players.forEach((player, playerId) =&gt; {&#10;        if (now - player.lastHeartbeat &gt; 15000) {&#10;&#10;            if (player.ws.readyState === WebSocket.OPEN) {&#10;                player.ws.send(JSON.stringify({ type: 'KICKED' }));&#10;                player.ws.close();&#10;            }&#10;&#10;            handlePlayerDisconnect(playerId);&#10;        }&#10;    });&#10;}, 10000);&#10;&#10;wss.on('connection', (ws) =&gt; {&#10;    const playerId = uuidv4();&#10;    console.log(`[${new Date().toISOString()}] Novo jogador conectado. ID: ${playerId}`);&#10;&#10;    ws.on('message', (message) =&gt; {&#10;        try {&#10;            const data = JSON.parse(message);&#10;            console.log(`[${new Date().toISOString()}] Mensagem recebida de ${playerId}: ${data.type}`);&#10;&#10;            switch (data.type) {&#10;                case 'JOIN':&#10;                    handlePlayerJoin(ws, playerId, data);&#10;                    break;&#10;                case 'UPDATE_POSITION':&#10;                    handlePositionUpdate(playerId, data);&#10;                    break;&#10;                case 'PLAYER_FELL':&#10;                    handlePlayerFell(playerId, data);&#10;                    break;&#10;                case 'RESPAWN':&#10;                    handlePlayerRespawn(playerId, data);&#10;                    break;&#10;                case 'HEARTBEAT':&#10;                    handleHeartbeat(playerId, data);&#10;                    break;&#10;                case 'PING':&#10;                    ws.send(JSON.stringify({ type: 'PONG' }));&#10;                    break;&#10;            }&#10;        } catch (error) {&#10;            console.error(`[${new Date().toISOString()}] Erro ao processar mensagem:`, error);&#10;        }&#10;    });&#10;&#10;    ws.on('close', () =&gt; {&#10;        console.log(`[${new Date().toISOString()}] Jogador desconectado. ID: ${playerId}`);&#10;        handlePlayerDisconnect(playerId);&#10;    });&#10;&#10;    ws.on('error', (error) =&gt; {&#10;    });&#10;});&#10;&#10;function handlePlayerJoin(ws, playerId, data) {&#10;    const roomId = data.roomId || 'default';&#10;&#10;    if (!rooms.has(roomId)) {&#10;        rooms.set(roomId, new Set());&#10;    }&#10;&#10;    const savedFalls = typeof data.savedFalls === 'number' ? data.savedFalls : 0;&#10;&#10;    const player = {&#10;        id: playerId,&#10;        name: data.playerName,&#10;        ws: ws,&#10;        roomId: roomId,&#10;        position: [0, 1, 0],&#10;        rotation: 0,&#10;        carModel: String(data.carModel),&#10;        falling: false,&#10;        falls: savedFalls,&#10;        lastHeartbeat: Date.now(),&#10;        inactive: false,&#10;        inactiveTime: null&#10;    };&#10;&#10;    players.set(playerId, player);&#10;    rooms.get(roomId).add(playerId);&#10;&#10;&#10;    ws.send(JSON.stringify({&#10;        type: 'JOIN_SUCCESS',&#10;        playerId: playerId&#10;    }));&#10;&#10;    const existingPlayers = Array.from(rooms.get(roomId))&#10;        .filter(id =&gt; id !== playerId)&#10;        .map(id =&gt; {&#10;            const p = players.get(id);&#10;            return {&#10;                id: p.id,&#10;                name: p.name,&#10;                position: p.position,&#10;                rotation: p.rotation,&#10;                carModel: String(p.carModel),&#10;                falling: p.falling,&#10;                falls: p.falls&#10;            };&#10;        });&#10;&#10;    ws.send(JSON.stringify({&#10;        type: 'EXISTING_PLAYERS',&#10;        players: existingPlayers&#10;    }));&#10;&#10;    broadcastToRoom(roomId, {&#10;        type: 'PLAYER_JOINED',&#10;        player: {&#10;            id: playerId,&#10;            name: player.name,&#10;            position: player.position,&#10;            rotation: player.rotation,&#10;            carModel: String(player.carModel),&#10;            falling: player.falling,&#10;            falls: player.falls&#10;        }&#10;    }, playerId);&#10;&#10;}&#10;&#10;function handlePositionUpdate(playerId, data) {&#10;    const player = players.get(playerId);&#10;    if (!player) return;&#10;&#10;    // Agora incluímos a altura (y) na posição&#10;    player.position = data.position;&#10;    player.rotation = data.rotation;&#10;    player.carModel = String(data.carModel);&#10;    &#10;    broadcastToRoom(player.roomId, {&#10;        type: 'PLAYER_UPDATE',&#10;        playerId: playerId,&#10;        position: data.position, // Isso já inclui a altura do pulo&#10;        rotation: data.rotation,&#10;        carModel: String(data.carModel)&#10;    }, playerId);&#10;}&#10;&#10;function handlePlayerFell(playerId, data) {&#10;    const player = players.get(playerId);&#10;    if (!player) return;&#10;&#10;    player.falling = true;&#10;    player.falls += 1;&#10;&#10;    broadcastToRoom(player.roomId, {&#10;        type: 'PLAYER_FELL',&#10;        playerId: playerId,&#10;        falls: player.falls&#10;    }, playerId);&#10;}&#10;&#10;function handlePlayerRespawn(playerId, data) {&#10;    const player = players.get(playerId);&#10;    if (!player) return;&#10;&#10;    player.position = data.position;&#10;    player.rotation = data.rotation;&#10;    player.carModel = String(data.carModel);&#10;    player.falling = false;&#10;&#10;    broadcastToRoom(player.roomId, {&#10;        type: 'PLAYER_RESPAWN',&#10;        playerId: playerId,&#10;        position: data.position,&#10;        rotation: data.rotation,&#10;        carModel: String(data.carModel)&#10;    }, playerId);&#10;}&#10;&#10;function handlePlayerDisconnect(playerId) {&#10;    const player = players.get(playerId);&#10;    if (!player) return;&#10;&#10;    if (rooms.has(player.roomId)) {&#10;        rooms.get(player.roomId).delete(playerId);&#10;        if (rooms.get(player.roomId).size === 0) {&#10;            rooms.delete(player.roomId);&#10;        }&#10;    }&#10;&#10;    broadcastToRoom(player.roomId, {&#10;        type: 'PLAYER_LEFT',&#10;        playerId: playerId&#10;    });&#10;&#10;    players.delete(playerId);&#10;}&#10;&#10;function handleHeartbeat(playerId, data) {&#10;    const player = players.get(playerId);&#10;    if (!player) return;&#10;&#10;    player.lastHeartbeat = Date.now();&#10;&#10;    player.ws.send(JSON.stringify({ type: 'PONG' }));&#10;}&#10;&#10;function broadcastToRoom(roomId, message, excludePlayerId = null) {&#10;    if (!rooms.has(roomId)) return;&#10;&#10;    const room = rooms.get(roomId);&#10;    room.forEach(playerId =&gt; {&#10;        if (playerId === excludePlayerId) return;&#10;&#10;        const player = players.get(playerId);&#10;        if (player &amp;&amp; player.ws.readyState === WebSocket.OPEN) {&#10;            player.ws.send(JSON.stringify(message));&#10;        }&#10;    });&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/App.jsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/App.jsx" />
              <option name="originalContent" value="import React, { useRef, useState } from &quot;react&quot;;&#10;import { Canvas } from &quot;@react-three/fiber&quot;;&#10;import Car from &quot;./components/Car&quot;;&#10;import Track from &quot;./components/Track&quot;;&#10;import Camera from &quot;./components/Camera&quot;;&#10;import Timer from &quot;./components/Timer&quot;;&#10;import PlayerName from &quot;./components/PlayerName&quot;;&#10;import PlayerNameLabel from &quot;./components/PlayerNameLabel&quot;;&#10;&#10;function App() {&#10;    const carRef = useRef();&#10;    const [playerName, setPlayerName] = useState(&quot;&quot;);&#10;    const [carPosition, setCarPosition] = useState([0, 1, 0]);&#10;&#10;    return (&#10;        &lt;div style={{ width: &quot;100vw&quot;, height: &quot;100vh&quot;, backgroundColor: &quot;white&quot; }}&gt;&#10;            &lt;PlayerName onNameSet={setPlayerName} /&gt;&#10;            &lt;Timer /&gt;&#10;            &lt;Canvas shadows camera={{ position: [0, 8, 15], fov: 60 }}&gt;&#10;                {/* Iluminação */}&#10;                &lt;ambientLight intensity={0.6} /&gt;&#10;                &lt;directionalLight&#10;                    position={[20, 20, 10]}&#10;                    intensity={1.5}&#10;                    castShadow&#10;                    shadow-mapSize-width={2048}&#10;                    shadow-mapSize-height={2048}&#10;                    shadow-camera-left={-50}&#10;                    shadow-camera-right={50}&#10;                    shadow-camera-top={50}&#10;                    shadow-camera-bottom={-50}&#10;                /&gt;&#10;&#10;                {/* Componentes do jogo */}&#10;                &lt;Track /&gt;&#10;                &lt;Car&#10;                    ref={carRef}&#10;                    position={[0, 1, 0]}&#10;                    onPositionChange={setCarPosition}&#10;                /&gt;&#10;                &lt;Camera target={carRef} /&gt;&#10;&#10;                {/* Label do jogador */}&#10;                {playerName &amp;&amp; (&#10;                    &lt;PlayerNameLabel&#10;                        position={carPosition}&#10;                        playerName={playerName}&#10;                    /&gt;&#10;                )}&#10;            &lt;/Canvas&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;export default App;" />
              <option name="updatedContent" value="import React, { useRef, useState } from &quot;react&quot;;&#10;import { Canvas } from &quot;@react-three/fiber&quot;;&#10;import Car from &quot;./components/Car&quot;;&#10;import Track from &quot;./components/Track&quot;;&#10;import Camera from &quot;./components/Camera&quot;;&#10;import Timer from &quot;./components/Timer&quot;;&#10;import PlayerName from &quot;./components/PlayerName&quot;;&#10;import PlayerNameLabel from &quot;./components/PlayerNameLabel&quot;;&#10;&#10;function App() {&#10;    const carRef = useRef();&#10;    const [playerName, setPlayerName] = useState(&quot;&quot;);&#10;    const [carPosition, setCarPosition] = useState([0, 1, 0]);&#10;    const [carRotation, setCarRotation] = useState(0);&#10;&#10;    const handlePositionChange = (position, rotation) =&gt; {&#10;        setCarPosition(position);&#10;        setCarRotation(rotation);&#10;    };&#10;&#10;    return (&#10;        &lt;div style={{ width: &quot;100vw&quot;, height: &quot;100vh&quot;, backgroundColor: &quot;white&quot; }}&gt;&#10;            &lt;PlayerName onNameSet={setPlayerName} /&gt;&#10;            &lt;Timer /&gt;&#10;            &lt;Canvas shadows camera={{ position: [0, 8, 15], fov: 60 }}&gt;&#10;                {/* Iluminação */}&#10;                &lt;ambientLight intensity={0.6} /&gt;&#10;                &lt;directionalLight&#10;                    position={[20, 20, 10]}&#10;                    intensity={1.5}&#10;                    castShadow&#10;                    shadow-mapSize-width={2048}&#10;                    shadow-mapSize-height={2048}&#10;                    shadow-camera-left={-50}&#10;                    shadow-camera-right={50}&#10;                    shadow-camera-top={50}&#10;                    shadow-camera-bottom={-50}&#10;                /&gt;&#10;&#10;                {/* Componentes do jogo */}&#10;                &lt;Track /&gt;&#10;                &lt;Car&#10;                    ref={carRef}&#10;                    position={[0, 1, 0]}&#10;                    onPositionChange={handlePositionChange}&#10;                /&gt;&#10;                &lt;Camera target={carRef} /&gt;&#10;&#10;                {/* Label do jogador */}&#10;                {playerName &amp;&amp; (&#10;                    &lt;PlayerNameLabel&#10;                        position={carPosition}&#10;                        playerName={playerName}&#10;                        carRotation={carRotation}&#10;                    /&gt;&#10;                )}&#10;            &lt;/Canvas&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;export default App;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/Camera.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/Camera.tsx" />
              <option name="originalContent" value="import { useFrame, useThree } from &quot;@react-three/fiber&quot;;&#10;import React, { useRef } from &quot;react&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type CameraProps = {&#10;    target: React.RefObject&lt;THREE.Group&gt;;&#10;};&#10;&#10;export default function Camera({ target }: CameraProps) {&#10;    const { camera } = useThree();&#10;    const tempPos = new THREE.Vector3();&#10;    const tempTarget = new THREE.Vector3();&#10;    const currentFov = useRef(50); // FOV atual da câmera&#10;&#10;    useFrame(() =&gt; {&#10;        if (!target.current) return;&#10;&#10;        const carPos = target.current.position;&#10;        const carRot = target.current.rotation.y;&#10;&#10;        // Calcula velocidade aproximada baseada na posição anterior&#10;        const velocity = target.current.userData.velocity || new THREE.Vector3();&#10;        const speed = velocity.length();&#10;&#10;        // Ajusta FOV baseado na velocidade (zoom out quando acelera)&#10;        const baseFov = 50;&#10;        const maxSpeedFov = 85; // FOV máximo quando em alta velocidade&#10;        const targetFov = baseFov + (speed * 1); // multiplicador mais suave&#10;        const clampedFov = Math.min(targetFov, maxSpeedFov);&#10;&#10;        // Suaviza a transição do FOV&#10;        currentFov.current = THREE.MathUtils.lerp(currentFov.current, clampedFov, 0.05);&#10;        camera.fov = currentFov.current;&#10;        camera.updateProjectionMatrix();&#10;&#10;        // Ajusta distância da câmera baseada na velocidade&#10;        const baseDistance = 8;&#10;        const speedDistance = speed * 1; // distância adicional por velocidade&#10;        const totalDistance = baseDistance + speedDistance;&#10;&#10;        // offset atrás do carro com distância dinâmica&#10;        const offset = new THREE.Vector3(0, 5, -totalDistance);&#10;        const rotatedOffset = offset.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), carRot);&#10;        tempPos.copy(carPos).add(rotatedOffset);&#10;&#10;        // suaviza movimento da câmera&#10;        camera.position.lerp(tempPos, 0.1); // lerp mais suave&#10;&#10;        // olha para o carro&#10;        camera.lookAt(carPos);&#10;    });&#10;&#10;    return null;&#10;}&#10;" />
              <option name="updatedContent" value="import { useFrame, useThree } from &quot;@react-three/fiber&quot;;&#10;import React, { useRef } from &quot;react&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type CameraProps = {&#10;    target: React.RefObject&lt;THREE.Group&gt;;&#10;};&#10;&#10;export default function Camera({ target }: CameraProps) {&#10;    const { camera } = useThree();&#10;    const tempPos = new THREE.Vector3();&#10;    const tempTarget = new THREE.Vector3();&#10;    const currentFov = useRef(45); // FOV base menor (era 50)&#10;&#10;    useFrame(() =&gt; {&#10;        if (!target.current) return;&#10;&#10;        const carPos = target.current.position;&#10;        const carRot = target.current.rotation.y;&#10;&#10;        // Calcula velocidade aproximada baseada na posição anterior&#10;        const velocity = target.current.userData.velocity || new THREE.Vector3();&#10;        const speed = velocity.length();&#10;&#10;        // Ajusta FOV baseado na velocidade com menos variação&#10;        const baseFov = 45; // FOV base menor&#10;        const maxSpeedFov = 55; // FOV máximo menor (era 85)&#10;        const targetFov = baseFov + (speed * 0.5); // multiplicador muito mais suave (era 1)&#10;        const clampedFov = Math.min(targetFov, maxSpeedFov);&#10;&#10;        // Suaviza a transição do FOV ainda mais&#10;        currentFov.current = THREE.MathUtils.lerp(currentFov.current, clampedFov, 0.02); // mais suave (era 0.05)&#10;        camera.fov = currentFov.current;&#10;        camera.updateProjectionMatrix();&#10;&#10;        // Ajusta distância da câmera com menos variação&#10;        const baseDistance = 10; // distância base maior&#10;        const speedDistance = speed * 0.5; // menos variação por velocidade (era 1)&#10;        const totalDistance = baseDistance + speedDistance;&#10;&#10;        // offset atrás do carro&#10;        const offset = new THREE.Vector3(0, 4, -totalDistance); // altura menor (era 5)&#10;        const rotatedOffset = offset.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), carRot);&#10;        tempPos.copy(carPos).add(rotatedOffset);&#10;&#10;        // movimento da câmera muito mais suave&#10;        camera.position.lerp(tempPos, 0.05); // muito mais suave (era 0.1)&#10;&#10;        // olha para o carro&#10;        camera.lookAt(carPos);&#10;    });&#10;&#10;    return null;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/Car.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/Car.tsx" />
              <option name="originalContent" value="import React, { useRef, useEffect, useState, forwardRef, useMemo } from &quot;react&quot;;&#10;import { useFrame } from &quot;@react-three/fiber&quot;;&#10;import { useGLTF } from &quot;@react-three/drei&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type CarProps = {&#10;    position?: [number, number, number];&#10;    onPositionChange?: (position: [number, number, number], rotation: number) =&gt; void;&#10;};&#10;&#10;const Car = forwardRef&lt;THREE.Group, CarProps&gt;(({ position = [0, 0.5, 0], onPositionChange }, ref) =&gt; {&#10;    const groupRef = useRef&lt;THREE.Group&gt;(null);&#10;    const [keys, setKeys] = useState&lt;{ [key: string]: boolean }&gt;({});&#10;    const velocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const angleRef = useRef(0);&#10;    const fallingRef = useRef(false);&#10;    const fallTimeRef = useRef(0);&#10;    const rotationVelocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const initialPosition = useRef(new THREE.Vector3(...position));&#10;    const [selectedCar, setSelectedCar] = useState(() =&gt; {&#10;        const carNumber = Math.floor(Math.random() * 4) + 1;&#10;        console.log(`Carro selecionado: car${carNumber}.glb`);&#10;        return `/models/car${carNumber}.glb`;&#10;    });&#10;&#10;    // Carrega o modelo GLB randomizado&#10;    const { scene } = useGLTF(selectedCar);&#10;&#10;    useEffect(() =&gt; {&#10;        if (!ref || !groupRef.current) return;&#10;        if (typeof ref === &quot;function&quot;) ref(groupRef.current);&#10;        else ref.current = groupRef.current;&#10;    }, [ref]);&#10;&#10;    useEffect(() =&gt; {&#10;        const down = (e: KeyboardEvent) =&gt; setKeys(k =&gt; ({ ...k, [e.key]: true }));&#10;        const up = (e: KeyboardEvent) =&gt; setKeys(k =&gt; ({ ...k, [e.key]: false }));&#10;        window.addEventListener(&quot;keydown&quot;, down);&#10;        window.addEventListener(&quot;keyup&quot;, up);&#10;        return () =&gt; {&#10;            window.removeEventListener(&quot;keydown&quot;, down);&#10;            window.removeEventListener(&quot;keyup&quot;, up);&#10;        };&#10;    }, []);&#10;&#10;    useFrame((state, delta) =&gt; {&#10;        const current = groupRef.current;&#10;        if (!current) return;&#10;&#10;        // Se está caindo, apenas aplica gravidade e rotação&#10;        if (fallingRef.current) {&#10;            velocityRef.current.y -= 9.8 * delta; // gravidade&#10;&#10;            // Continua movimento horizontal durante a queda&#10;            const direction = new THREE.Vector3(&#10;                Math.sin(angleRef.current) * velocityRef.current.z,&#10;                0,&#10;                Math.cos(angleRef.current) * velocityRef.current.z&#10;            );&#10;            current.position.add(direction);&#10;            current.position.add(new THREE.Vector3(0, velocityRef.current.y * delta, 0));&#10;&#10;            // Rotação realista durante a queda (frente cai primeiro)&#10;            rotationVelocityRef.current.x += 2 * delta;&#10;            current.rotation.x += rotationVelocityRef.current.x * delta;&#10;&#10;            fallTimeRef.current += delta;&#10;&#10;            // Respawn após 3 segundos&#10;            if (fallTimeRef.current &gt;= 3) {&#10;                // Posição aleatória na plataforma (evita bordas)&#10;                const randomX = (Math.random() - 0.5) * 120; // 120 de 200 para evitar bordas&#10;                const randomZ = (Math.random() - 0.5) * 120;&#10;                const randomAngle = Math.random() * Math.PI * 2; // rotação aleatória&#10;&#10;                current.position.set(randomX, initialPosition.current.y, randomZ);&#10;                velocityRef.current.set(0, 0, 0);&#10;                rotationVelocityRef.current.set(0, 0, 0);&#10;                angleRef.current = randomAngle;&#10;                current.rotation.set(0, randomAngle, 0);&#10;                fallingRef.current = false;&#10;                fallTimeRef.current = 0;&#10;&#10;                // Muda o carro no respawn&#10;                const carNumber = Math.floor(Math.random() * 4) + 1;&#10;                const newCarPath = `/models/car${carNumber}.glb`;&#10;                console.log(`Novo carro selecionado: car${carNumber}.glb`);&#10;                setSelectedCar(newCarPath);&#10;            }&#10;            return;&#10;        }&#10;&#10;        const velocity = velocityRef.current;&#10;        let angle = angleRef.current;&#10;&#10;        const acceleration = 0.02;&#10;        const maxSpeed = 0.5;&#10;        const turnSpeed = 0.03;&#10;        const friction = 0.99;&#10;        const brakeForce = 0.08; // força do freio (mais fraca que aceleração)&#10;        const reverseAcceleration = 0.01; // aceleração em ré (mais lenta)&#10;        const maxReverseSpeed = 0.2; // velocidade máxima em ré (mais baixa)&#10;&#10;        if (keys[&quot;ArrowUp&quot;] || keys[&quot;w&quot;]) {&#10;            velocity.z = Math.min(velocity.z + acceleration, maxSpeed);&#10;        }&#10;&#10;        if (keys[&quot;ArrowDown&quot;] || keys[&quot;s&quot;]) {&#10;            // Se está indo para frente, aplica freio gradual&#10;            if (velocity.z &gt; 0.8) { // threshold mínimo para considerar &quot;parado&quot;&#10;                velocity.z = Math.max(velocity.z - brakeForce, 0);&#10;            }&#10;            // Só permite ré quando realmente parou&#10;            else if (velocity.z &lt;= 0.2 &amp;&amp; velocity.z &gt;= -0.1) {&#10;                velocity.z = Math.max(velocity.z - reverseAcceleration, -maxReverseSpeed);&#10;            }&#10;        }&#10;&#10;        const speedFactor = Math.abs(velocity.z) / maxSpeed;&#10;        if ((keys[&quot;ArrowLeft&quot;] || keys[&quot;a&quot;]) &amp;&amp; speedFactor &gt; 0.1) {&#10;            angle += turnSpeed * speedFactor;&#10;        }&#10;        if ((keys[&quot;ArrowRight&quot;] || keys[&quot;d&quot;]) &amp;&amp; speedFactor &gt; 0.1) {&#10;            angle -= turnSpeed * speedFactor;&#10;        }&#10;&#10;        velocity.multiplyScalar(friction);&#10;&#10;        const direction = new THREE.Vector3(&#10;            Math.sin(angle) * velocity.z,&#10;            0,&#10;            Math.cos(angle) * velocity.z&#10;        );&#10;&#10;        current.position.add(direction);&#10;        current.rotation.y = angle;&#10;&#10;        // Verifica se a frente do carro saiu da plataforma (física mais realista)&#10;        const trackSize = 200;&#10;        const carLength = 3; // comprimento aproximado do carro&#10;&#10;        // Calcula posição da frente do carro&#10;        const frontX = current.position.x + Math.sin(angle) * carLength;&#10;        const frontZ = current.position.z + Math.cos(angle) * carLength;&#10;&#10;        if (Math.abs(frontX) &gt; trackSize/2 || Math.abs(frontZ) &gt; trackSize/2) {&#10;            if (!fallingRef.current) {&#10;                fallingRef.current = true;&#10;                velocityRef.current.y = 0; // inicia queda&#10;                rotationVelocityRef.current.set(0, 0, 0);&#10;            }&#10;        }&#10;&#10;        // Armazena velocidade para a câmera acessar&#10;        current.userData.velocity = velocity.clone();&#10;&#10;        // Atualiza posição para o label do jogador&#10;        if (onPositionChange) {&#10;            onPositionChange([current.position.x, current.position.y, current.position.z], angle);&#10;        }&#10;&#10;        angleRef.current = angle;&#10;    });&#10;&#10;    return (&#10;        &lt;group ref={groupRef} position={position} castShadow&gt;&#10;            &lt;primitive object={scene.clone()} scale={[5, 5, 5]} rotation={[0, Math.PI / 2, 0]} /&gt;&#10;        &lt;/group&gt;&#10;    );&#10;});&#10;&#10;for (let i = 1; i &lt;= 4; i++) {&#10;    useGLTF.preload(`/models/car${i}.glb`);&#10;}&#10;&#10;export default Car;&#10;&#10;" />
              <option name="updatedContent" value="import React, { useRef, useEffect, useState, forwardRef, useMemo } from &quot;react&quot;;&#10;import { useFrame } from &quot;@react-three/fiber&quot;;&#10;import { useGLTF } from &quot;@react-three/drei&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type CarProps = {&#10;    position?: [number, number, number];&#10;    onPositionChange?: (position: [number, number, number], rotation: number) =&gt; void;&#10;};&#10;&#10;const Car = forwardRef&lt;THREE.Group, CarProps&gt;(({ position = [0, 0.5, 0], onPositionChange }, ref) =&gt; {&#10;    const groupRef = useRef&lt;THREE.Group&gt;(null);&#10;    const [keys, setKeys] = useState&lt;{ [key: string]: boolean }&gt;({});&#10;    const velocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const angleRef = useRef(0);&#10;    const fallingRef = useRef(false);&#10;    const fallTimeRef = useRef(0);&#10;    const rotationVelocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const initialPosition = useRef(new THREE.Vector3(...position));&#10;    const [selectedCar, setSelectedCar] = useState(() =&gt; {&#10;        const carNumber = Math.floor(Math.random() * 4) + 1;&#10;        console.log(`Carro selecionado: car${carNumber}.glb`);&#10;        return `/models/car${carNumber}.glb`;&#10;    });&#10;&#10;    // Carrega o modelo GLB randomizado&#10;    const { scene } = useGLTF(selectedCar);&#10;&#10;    useEffect(() =&gt; {&#10;        if (!ref || !groupRef.current) return;&#10;        if (typeof ref === &quot;function&quot;) ref(groupRef.current);&#10;        else ref.current = groupRef.current;&#10;    }, [ref]);&#10;&#10;    useEffect(() =&gt; {&#10;        const down = (e: KeyboardEvent) =&gt; setKeys(k =&gt; ({ ...k, [e.key]: true }));&#10;        const up = (e: KeyboardEvent) =&gt; setKeys(k =&gt; ({ ...k, [e.key]: false }));&#10;        window.addEventListener(&quot;keydown&quot;, down);&#10;        window.addEventListener(&quot;keyup&quot;, up);&#10;        return () =&gt; {&#10;            window.removeEventListener(&quot;keydown&quot;, down);&#10;            window.removeEventListener(&quot;keyup&quot;, up);&#10;        };&#10;    }, []);&#10;&#10;    useFrame((state, delta) =&gt; {&#10;        const current = groupRef.current;&#10;        if (!current) return;&#10;&#10;        // Se está caindo, apenas aplica gravidade e rotação&#10;        if (fallingRef.current) {&#10;            velocityRef.current.y -= 9.8 * delta; // gravidade&#10;&#10;            // Continua movimento horizontal durante a queda&#10;            const direction = new THREE.Vector3(&#10;                Math.sin(angleRef.current) * velocityRef.current.z,&#10;                0,&#10;                Math.cos(angleRef.current) * velocityRef.current.z&#10;            );&#10;            current.position.add(direction);&#10;            current.position.add(new THREE.Vector3(0, velocityRef.current.y * delta, 0));&#10;&#10;            // Rotação realista durante a queda (frente cai primeiro)&#10;            rotationVelocityRef.current.x += 2 * delta;&#10;            current.rotation.x -= rotationVelocityRef.current.x * delta; // mudança aqui: menos ao invés de mais&#10;&#10;            fallTimeRef.current += delta;&#10;&#10;            // Respawn após 3 segundos&#10;            if (fallTimeRef.current &gt;= 3) {&#10;                // Posição aleatória na plataforma (evita bordas)&#10;                const randomX = (Math.random() - 0.5) * 120; // 120 de 200 para evitar bordas&#10;                const randomZ = (Math.random() - 0.5) * 120;&#10;                const randomAngle = Math.random() * Math.PI * 2; // rotação aleatória&#10;&#10;                current.position.set(randomX, initialPosition.current.y, randomZ);&#10;                velocityRef.current.set(0, 0, 0);&#10;                rotationVelocityRef.current.set(0, 0, 0);&#10;                angleRef.current = randomAngle;&#10;                current.rotation.set(0, randomAngle, 0);&#10;                fallingRef.current = false;&#10;                fallTimeRef.current = 0;&#10;&#10;                // Muda o carro no respawn&#10;                const carNumber = Math.floor(Math.random() * 4) + 1;&#10;                const newCarPath = `/models/car${carNumber}.glb`;&#10;                console.log(`Novo carro selecionado: car${carNumber}.glb`);&#10;                setSelectedCar(newCarPath);&#10;            }&#10;            return;&#10;        }&#10;&#10;        const velocity = velocityRef.current;&#10;        let angle = angleRef.current;&#10;&#10;        const acceleration = 0.02;&#10;        const maxSpeed = 0.5;&#10;        const turnSpeed = 0.03;&#10;        const friction = 0.99;&#10;        const brakeForce = 0.08; // força do freio (mais fraca que aceleração)&#10;        const reverseAcceleration = 0.01; // aceleração em ré (mais lenta)&#10;        const maxReverseSpeed = 0.2; // velocidade máxima em ré (mais baixa)&#10;&#10;        if (keys[&quot;ArrowUp&quot;] || keys[&quot;w&quot;]) {&#10;            velocity.z = Math.min(velocity.z + acceleration, maxSpeed);&#10;        }&#10;&#10;        if (keys[&quot;ArrowDown&quot;] || keys[&quot;s&quot;]) {&#10;            // Se está indo para frente, aplica freio gradual&#10;            if (velocity.z &gt; 0.8) { // threshold mínimo para considerar &quot;parado&quot;&#10;                velocity.z = Math.max(velocity.z - brakeForce, 0);&#10;            }&#10;            // Só permite ré quando realmente parou&#10;            else if (velocity.z &lt;= 0.2 &amp;&amp; velocity.z &gt;= -0.1) {&#10;                velocity.z = Math.max(velocity.z - reverseAcceleration, -maxReverseSpeed);&#10;            }&#10;        }&#10;&#10;        const speedFactor = Math.abs(velocity.z) / maxSpeed;&#10;        if ((keys[&quot;ArrowLeft&quot;] || keys[&quot;a&quot;]) &amp;&amp; speedFactor &gt; 0.1) {&#10;            angle += turnSpeed * speedFactor;&#10;        }&#10;        if ((keys[&quot;ArrowRight&quot;] || keys[&quot;d&quot;]) &amp;&amp; speedFactor &gt; 0.1) {&#10;            angle -= turnSpeed * speedFactor;&#10;        }&#10;&#10;        velocity.multiplyScalar(friction);&#10;&#10;        const direction = new THREE.Vector3(&#10;            Math.sin(angle) * velocity.z,&#10;            0,&#10;            Math.cos(angle) * velocity.z&#10;        );&#10;&#10;        current.position.add(direction);&#10;        current.rotation.y = angle;&#10;&#10;        // Verifica se a frente do carro saiu da plataforma (física mais realista)&#10;        const trackSize = 200;&#10;        const carLength = 3; // comprimento aproximado do carro&#10;&#10;        // Calcula posição da frente do carro&#10;        const frontX = current.position.x + Math.sin(angle) * carLength;&#10;        const frontZ = current.position.z + Math.cos(angle) * carLength;&#10;&#10;        if (Math.abs(frontX) &gt; trackSize/2 || Math.abs(frontZ) &gt; trackSize/2) {&#10;            if (!fallingRef.current) {&#10;                fallingRef.current = true;&#10;                velocityRef.current.y = 0; // inicia queda&#10;                rotationVelocityRef.current.set(0, 0, 0);&#10;            }&#10;        }&#10;&#10;        // Armazena velocidade para a câmera acessar&#10;        current.userData.velocity = velocity.clone();&#10;&#10;        // Atualiza posição para o label do jogador&#10;        if (onPositionChange) {&#10;            onPositionChange([current.position.x, current.position.y, current.position.z], angle);&#10;        }&#10;&#10;        angleRef.current = angle;&#10;    });&#10;&#10;    return (&#10;        &lt;group ref={groupRef} position={position} castShadow&gt;&#10;            &lt;primitive object={scene.clone()} scale={[5, 5, 5]} rotation={[0, Math.PI / 2, 0]} /&gt;&#10;        &lt;/group&gt;&#10;    );&#10;});&#10;&#10;for (let i = 1; i &lt;= 4; i++) {&#10;    useGLTF.preload(`/models/car${i}.glb`);&#10;}&#10;&#10;export default Car;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/PlayerName.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/PlayerName.tsx" />
              <option name="updatedContent" value="import React, { useState, useEffect } from &quot;react&quot;;&#10;&#10;type PlayerNameProps = {&#10;    onNameSet: (name: string) =&gt; void;&#10;};&#10;&#10;export default function PlayerName({ onNameSet }: PlayerNameProps) {&#10;    const [name, setName] = useState(&quot;&quot;);&#10;    const [showInput, setShowInput] = useState(false);&#10;&#10;    useEffect(() =&gt; {&#10;        const savedName = localStorage.getItem(&quot;playerName&quot;);&#10;        if (savedName) {&#10;            onNameSet(savedName);&#10;        } else {&#10;            setShowInput(true);&#10;        }&#10;    }, [onNameSet]);&#10;&#10;    const handleSubmit = (e: React.FormEvent) =&gt; {&#10;        e.preventDefault();&#10;        if (name.trim()) {&#10;            localStorage.setItem(&quot;playerName&quot;, name.trim());&#10;            onNameSet(name.trim());&#10;            setShowInput(false);&#10;        }&#10;    };&#10;&#10;    if (!showInput) return null;&#10;&#10;    return (&#10;        &lt;div style={{&#10;            position: &quot;fixed&quot;,&#10;            top: 0,&#10;            left: 0,&#10;            width: &quot;100vw&quot;,&#10;            height: &quot;100vh&quot;,&#10;            backgroundColor: &quot;rgba(0, 0, 0, 0.7)&quot;,&#10;            display: &quot;flex&quot;,&#10;            alignItems: &quot;center&quot;,&#10;            justifyContent: &quot;center&quot;,&#10;            zIndex: 1000&#10;        }}&gt;&#10;            &lt;div style={{&#10;                backgroundColor: &quot;white&quot;,&#10;                padding: &quot;30px&quot;,&#10;                borderRadius: &quot;10px&quot;,&#10;                textAlign: &quot;center&quot;,&#10;                minWidth: &quot;300px&quot;&#10;            }}&gt;&#10;                &lt;h2 style={{ marginBottom: &quot;20px&quot;, color: &quot;#333&quot; }}&gt;&#10;                    Bem-vindo ao Jogo!&#10;                &lt;/h2&gt;&#10;                &lt;form onSubmit={handleSubmit}&gt;&#10;                    &lt;input&#10;                        type=&quot;text&quot;&#10;                        value={name}&#10;                        onChange={(e) =&gt; setName(e.target.value)}&#10;                        placeholder=&quot;Digite seu nome&quot;&#10;                        style={{&#10;                            padding: &quot;10px&quot;,&#10;                            fontSize: &quot;16px&quot;,&#10;                            border: &quot;2px solid #ddd&quot;,&#10;                            borderRadius: &quot;5px&quot;,&#10;                            marginBottom: &quot;20px&quot;,&#10;                            width: &quot;100%&quot;,&#10;                            outline: &quot;none&quot;&#10;                        }}&#10;                        autoFocus&#10;                    /&gt;&#10;                    &lt;button&#10;                        type=&quot;submit&quot;&#10;                        style={{&#10;                            padding: &quot;10px 20px&quot;,&#10;                            fontSize: &quot;16px&quot;,&#10;                            backgroundColor: &quot;#007bff&quot;,&#10;                            color: &quot;white&quot;,&#10;                            border: &quot;none&quot;,&#10;                            borderRadius: &quot;5px&quot;,&#10;                            cursor: &quot;pointer&quot;&#10;                        }}&#10;                    &gt;&#10;                        Começar Jogo&#10;                    &lt;/button&gt;&#10;                &lt;/form&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/PlayerNameLabel.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/PlayerNameLabel.tsx" />
              <option name="originalContent" value="import React from &quot;react&quot;;&#10;import { Text } from &quot;@react-three/drei&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type PlayerNameLabelProps = {&#10;    position: [number, number, number];&#10;    playerName: string;&#10;    carRotation: number;&#10;};&#10;&#10;export default function PlayerNameLabel({ position, playerName, carRotation }: PlayerNameLabelProps) {&#10;    // @ts-ignore&#10;    return (&#10;        &lt;group position={[position[0], position[1] + 6, position[2]]} rotation={[0, carRotation + Math.PI, 0]}&gt;&#10;            {/* Fundo retangular cinza */}&#10;            &lt;mesh&gt;&#10;                &lt;planeGeometry args={[playerName.length * 0.2 + 0.3, 0.5]} /&gt;&#10;                &lt;meshBasicMaterial color=&quot;#666666&quot; transparent opacity={0.3} /&gt;&#10;            &lt;/mesh&gt;&#10;&#10;            {/* Texto do nome */}&#10;            &lt;Text&#10;                position={[0, 0, 0.01]}&#10;                fontSize={0.3}&#10;                color=&quot;#ffffff&quot;&#10;                anchorX=&quot;center&quot;&#10;                anchorY=&quot;middle&quot;&#10;                material-transparent={true}&#10;                material-opacity={0.9}&#10;            &gt;&#10;                {playerName}&#10;            &lt;/Text&gt;&#10;        &lt;/group&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="import React from &quot;react&quot;;&#10;import { Text } from &quot;@react-three/drei&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type PlayerNameLabelProps = {&#10;    position: [number, number, number];&#10;    playerName: string;&#10;    carRotation: number;&#10;};&#10;&#10;export default function PlayerNameLabel({ position, playerName, carRotation }: PlayerNameLabelProps) {&#10;    // @ts-ignore&#10;    return (&#10;        &lt;group position={[position[0], position[1] + 3, position[2]]} rotation={[0, carRotation + Math.PI, 0]}&gt;&#10;            {/* Fundo retangular cinza */}&#10;            &lt;mesh&gt;&#10;                &lt;planeGeometry args={[playerName.length * 0.2 + 0.3, 0.5]} /&gt;&#10;                &lt;meshBasicMaterial color=&quot;#666666&quot; transparent opacity={0.3} /&gt;&#10;            &lt;/mesh&gt;&#10;&#10;            {/* Texto do nome */}&#10;            &lt;Text&#10;                position={[0, 0, 0.01]}&#10;                fontSize={0.3}&#10;                color=&quot;#ffffff&quot;&#10;                anchorX=&quot;center&quot;&#10;                anchorY=&quot;middle&quot;&#10;                material-transparent={true}&#10;                material-opacity={0.9}&#10;            &gt;&#10;                {playerName}&#10;            &lt;/Text&gt;&#10;        &lt;/group&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/Timer.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/Timer.tsx" />
              <option name="originalContent" value="import React, { useEffect, useState } from &quot;react&quot;;&#10;&#10;export default function Timer() {&#10;    const [time, setTime] = useState(0);&#10;&#10;    useEffect(() =&gt; {&#10;        const interval = setInterval(() =&gt; setTime(prev =&gt; prev + 0.01), 10);&#10;        return () =&gt; clearInterval(interval);&#10;    }, []);&#10;&#10;    const formatTime = (t: number) =&gt; {&#10;        const minutes = Math.floor(t / 60);&#10;        const seconds = (t % 60).toFixed(2);&#10;        return `${minutes}:${seconds.padStart(5, &quot;0&quot;)}`;&#10;    };&#10;&#10;    return (&#10;        &lt;div style={{ position: &quot;absolute&quot;, top: 20, left: 20, color: &quot;white&quot;, fontSize: &quot;24px&quot; }}&gt;&#10;            {formatTime(time)}&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="import React, { useEffect, useState } from &quot;react&quot;;&#10;&#10;export default function Timer() {&#10;    const [time, setTime] = useState(0);&#10;&#10;    useEffect(() =&gt; {&#10;        const interval = setInterval(() =&gt; setTime(prev =&gt; prev + 0.01), 10);&#10;        return () =&gt; clearInterval(interval);&#10;    }, []);&#10;&#10;    const formatTime = (t: number) =&gt; {&#10;        const minutes = Math.floor(t / 60);&#10;        const seconds = (t % 60).toFixed(2);&#10;        return `${minutes}:${seconds.padStart(5, &quot;0&quot;)}`;&#10;    };&#10;&#10;    return (&#10;        &lt;div style={{ position: &quot;absolute&quot;, top: 20, left: 20, color: &quot;black&quot;, fontSize: &quot;24px&quot; }}&gt;&#10;            {formatTime(time)}&#10;        &lt;/div&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/Track.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/Track.tsx" />
              <option name="originalContent" value="import React from &quot;react&quot;;&#10;&#10;export default function Track() {&#10;    const trackSize = 100; // plataforma quadrada 100x100&#10;&#10;    return (&#10;        &lt;group&gt;&#10;            {/* Plataforma principal quadrada */}&#10;            &lt;mesh position={[0, -1, 0]} receiveShadow&gt;&#10;                &lt;boxGeometry args={[trackSize, 2, trackSize]} /&gt;&#10;                &lt;meshStandardMaterial color=&quot;#2c2c2c&quot; /&gt;&#10;            &lt;/mesh&gt;&#10;        &lt;/group&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="import React from &quot;react&quot;;&#10;&#10;export default function Track() {&#10;    const trackSize = 200; // plataforma muito maior: 200x200&#10;&#10;    return (&#10;        &lt;group&gt;&#10;            {/* Plataforma principal quadrada */}&#10;            &lt;mesh position={[0, -1, 0]} receiveShadow&gt;&#10;                &lt;boxGeometry args={[trackSize, 2, trackSize]} /&gt;&#10;                &lt;meshStandardMaterial color=&quot;#808080&quot; /&gt;&#10;            &lt;/mesh&gt;&#10;        &lt;/group&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>