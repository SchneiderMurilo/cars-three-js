<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/client/src/App.jsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/App.jsx" />
              <option name="originalContent" value="import React, { useRef, useState, useEffect } from &quot;react&quot;;&#10;import { Canvas } from &quot;@react-three/fiber&quot;;&#10;import Car from &quot;./components/Car&quot;;&#10;import Track from &quot;./components/Track&quot;;&#10;import Camera from &quot;./components/Camera&quot;;&#10;import Leaderboard from &quot;./components/Leaderboard&quot;;&#10;import PlayerName from &quot;./components/PlayerName&quot;;&#10;import PlayerNameLabel from &quot;./components/PlayerNameLabel&quot;;&#10;import OtherPlayer from &quot;./components/OtherPlayer&quot;;&#10;import { useWebSocket } from &quot;./hooks/useWebSocket&quot;;&#10;import Logo from &quot;./components/Logo.js&quot;;&#10;&#10;function App() {&#10;    const carRef = useRef();&#10;    const [playerName, setPlayerName] = useState(&quot;&quot;);&#10;    const [carPosition, setCarPosition] = useState([0, 1, 0]);&#10;    const [carRotation, setCarRotation] = useState(0);&#10;    const [isPlayerFallen, setIsPlayerFallen] = useState(false);&#10;&#10;    const {&#10;        players,&#10;        connected,&#10;        currentPlayerId,&#10;        playerStats,&#10;        platformSize,&#10;        isWaitingForRound,&#10;        waitingCountdown,&#10;        currentRound,&#10;        sendPositionUpdate,&#10;        sendPlayerFell,&#10;        sendPlayerRespawn,&#10;        updateSelfPlayer,&#10;        incrementSelfFalls,&#10;        stopPlayerTime&#10;    } = useWebSocket(playerName);&#10;&#10;    const handlePositionChange = (position, rotation) =&gt; {&#10;        setCarPosition(position);&#10;        setCarRotation(rotation);&#10;    };&#10;&#10;    const handleUpdateSelf = (position, rotation, carModel) =&gt; {&#10;        if (updateSelfPlayer) {&#10;            updateSelfPlayer(position, rotation, carModel);&#10;        }&#10;    };&#10;&#10;    const handleSelfFell = () =&gt; {&#10;        // Parar o tempo imediatamente quando começar a cair&#10;        if (stopPlayerTime) {&#10;            stopPlayerTime();&#10;        }&#10;&#10;        if (incrementSelfFalls) {&#10;            incrementSelfFalls();&#10;        }&#10;    };&#10;&#10;    const handleFallingStateChange = (isFalling) =&gt; {&#10;        setIsPlayerFallen(isFalling);&#10;    };&#10;&#10;    // Determinar se deve estar em modo espectador&#10;    const shouldBeSpectator = isWaitingForRound || isPlayerFallen;&#10;&#10;    // Remover o useEffect problemático que estava causando loops&#10;    // useEffect(() =&gt; {&#10;    //     if (!isWaitingForRound &amp;&amp; !isPlayerFallen) {&#10;    //         setIsPlayerFallen(false);&#10;    //     }&#10;    // }, [isWaitingForRound, isPlayerFallen]);&#10;&#10;    return (&#10;        &lt;div style={{ width: &quot;100vw&quot;, height: &quot;100vh&quot;, backgroundColor: &quot;white&quot; }}&gt;&#10;            &lt;Logo/&gt;&#10;            &lt;PlayerName onNameSet={setPlayerName} /&gt;&#10;            &lt;Leaderboard&#10;                players={players}&#10;                currentPlayerId={currentPlayerId}&#10;                playerStats={playerStats}&#10;            /&gt;&#10;&#10;            {/* Indicador de estado do jogador */}&#10;            {shouldBeSpectator &amp;&amp; (&#10;                &lt;div style={{&#10;                    position: &quot;absolute&quot;,&#10;                    bottom: 20,&#10;                    left: &quot;50%&quot;,&#10;                    transform: &quot;translateX(-50%)&quot;,&#10;                    backgroundColor: &quot;rgba(0, 0, 0, 0.9)&quot;,&#10;                    color: &quot;white&quot;,&#10;                    padding: &quot;20px 30px&quot;,&#10;                    borderRadius: &quot;15px&quot;,&#10;                    fontSize: &quot;18px&quot;,&#10;                    fontWeight: &quot;bold&quot;,&#10;                    textAlign: &quot;center&quot;,&#10;                    zIndex: 1000,&#10;                    border: &quot;2px solid #fff&quot;,&#10;                    minWidth: &quot;300px&quot;&#10;                }}&gt;&#10;                    {waitingCountdown &gt; 0 ? (&#10;                        &lt;&gt;&#10;                             Próxima Rodada em: {waitingCountdown}s&#10;                        &lt;/&gt;&#10;                    ) : (&#10;                        &lt;&gt;&#10;                             Modo Espectador&#10;                            &lt;br /&gt;&#10;                            &lt;span style={{ fontSize: &quot;14px&quot;, opacity: 0.8 }}&gt;&#10;                                Aguardando próxima rodada...&#10;                            &lt;/span&gt;&#10;                        &lt;/&gt;&#10;                    )}&#10;                &lt;/div&gt;&#10;            )}&#10;&#10;&#10;            &lt;div style={{&#10;                position: &quot;absolute&quot;,&#10;                bottom: 20,&#10;                left: 20,&#10;                backgroundColor: &quot;rgba(0, 0, 0, 0.8)&quot;,&#10;                color: &quot;white&quot;,&#10;                padding: &quot;10px 15px&quot;,&#10;                borderRadius: &quot;8px&quot;,&#10;                fontSize: &quot;16px&quot;,&#10;                fontWeight: &quot;bold&quot;,&#10;                zIndex: 1000&#10;            }}&gt;&#10;                 Plataforma: {Math.max(0, Math.round(platformSize))}m&#10;                {platformSize &lt;= 20 &amp;&amp; &quot;  PERIGO!&quot;}&#10;            &lt;/div&gt;&#10;&#10;            {/* Indicador de conexão */}&#10;            &lt;div style={{&#10;                position: &quot;absolute&quot;,&#10;                top: 20,&#10;                right: 20,&#10;                color: connected ? &quot;green&quot; : &quot;red&quot;,&#10;                fontSize: &quot;16px&quot;&#10;            }}&gt;&#10;                {connected ? &quot;● Online&quot; : &quot;● Offline&quot;}&#10;            &lt;/div&gt;&#10;&#10;            &lt;Canvas&#10;                shadows&#10;                camera={{ position: [0, 8, 15], fov: 60 }}&#10;                frameloop=&quot;always&quot;&#10;                gl={{ preserveDrawingBuffer: true }}&#10;                onCreated={({ gl }) =&gt; {&#10;                    gl.setAnimationLoop = (callback) =&gt; {&#10;                        const animate = () =&gt; {&#10;                            if (callback) callback();&#10;                            requestAnimationFrame(animate);&#10;                        };&#10;                        animate();&#10;                    };&#10;                }}&#10;            &gt;&#10;                &lt;ambientLight intensity={0.6} /&gt;&#10;                &lt;directionalLight&#10;                    position={[20, 20, 10]}&#10;                    intensity={1.5}&#10;                    castShadow&#10;                    shadow-mapSize-width={2048}&#10;                    shadow-mapSize-height={2048}&#10;                    shadow-camera-left={-50}&#10;                    shadow-camera-right={50}&#10;                    shadow-camera-top={50}&#10;                    shadow-camera-bottom={-50}&#10;                /&gt;&#10;&#10;                &lt;Track platformSize={platformSize} /&gt;&#10;&#10;                {/* Renderizar o carro sempre, mas ele será invisível quando cair */}&#10;                &lt;Car&#10;                    ref={carRef}&#10;                    position={[0, 1, 0]}&#10;                    onPositionChange={handlePositionChange}&#10;                    onSendUpdate={sendPositionUpdate}&#10;                    onPlayerFell={sendPlayerFell}&#10;                    onPlayerRespawn={sendPlayerRespawn}&#10;                    onUpdateSelf={handleUpdateSelf}&#10;                    onSelfFell={handleSelfFell}&#10;                    onFallingStateChange={handleFallingStateChange}&#10;                    otherPlayers={players}&#10;                    currentPlayerId={currentPlayerId}&#10;                    platformSize={platformSize}&#10;                    isWaitingForRound={isWaitingForRound}&#10;                /&gt;&#10;&#10;                &lt;Camera&#10;                    target={carRef}&#10;                    isPlayerFallen={shouldBeSpectator}&#10;                    platformSize={platformSize}&#10;                /&gt;&#10;&#10;                {Array.from(players.values())&#10;                    .filter(player =&gt; player.id !== currentPlayerId &amp;&amp; !player.isWaitingForRound)&#10;                    .map((player) =&gt; (&#10;                        &lt;OtherPlayer key={player.id} player={player} /&gt;&#10;                    ))}&#10;            &lt;/Canvas&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;export default App;" />
              <option name="updatedContent" value="import React, { useRef, useState, useEffect } from &quot;react&quot;;&#10;import { Canvas } from &quot;@react-three/fiber&quot;;&#10;import Car from &quot;./components/Car&quot;;&#10;import Track from &quot;./components/Track&quot;;&#10;import Camera from &quot;./components/Camera&quot;;&#10;import Leaderboard from &quot;./components/Leaderboard&quot;;&#10;import PlayerName from &quot;./components/PlayerName&quot;;&#10;import PlayerNameLabel from &quot;./components/PlayerNameLabel&quot;;&#10;import OtherPlayer from &quot;./components/OtherPlayer&quot;;&#10;import { useWebSocket } from &quot;./hooks/useWebSocket&quot;;&#10;import Logo from &quot;./components/Logo.js&quot;;&#10;&#10;function App() {&#10;    const carRef = useRef();&#10;    const [playerName, setPlayerName] = useState(&quot;&quot;);&#10;    const [carPosition, setCarPosition] = useState([0, 1, 0]);&#10;    const [carRotation, setCarRotation] = useState(0);&#10;    const [isPlayerFallen, setIsPlayerFallen] = useState(false);&#10;&#10;    const {&#10;        players,&#10;        connected,&#10;        currentPlayerId,&#10;        playerStats,&#10;        platformSize,&#10;        isWaitingForRound,&#10;        waitingCountdown,&#10;        currentRound,&#10;        sendPositionUpdate,&#10;        sendPlayerFell,&#10;        sendPlayerRespawn,&#10;        updateSelfPlayer,&#10;        incrementSelfFalls,&#10;        stopPlayerTime&#10;    } = useWebSocket(playerName);&#10;&#10;    const handlePositionChange = (position, rotation) =&gt; {&#10;        setCarPosition(position);&#10;        setCarRotation(rotation);&#10;    };&#10;&#10;    const handleUpdateSelf = (position, rotation, carModel, physicsData) =&gt; {&#10;        if (updateSelfPlayer) {&#10;            updateSelfPlayer(position, rotation, carModel);&#10;        }&#10;    };&#10;&#10;    const handleSelfFell = () =&gt; {&#10;        // Parar o tempo imediatamente quando começar a cair&#10;        if (stopPlayerTime) {&#10;            stopPlayerTime();&#10;        }&#10;&#10;        if (incrementSelfFalls) {&#10;            incrementSelfFalls();&#10;        }&#10;    };&#10;&#10;    const handleFallingStateChange = (isFalling) =&gt; {&#10;        setIsPlayerFallen(isFalling);&#10;    };&#10;&#10;    // Determinar se deve estar em modo espectador&#10;    const shouldBeSpectator = isWaitingForRound || isPlayerFallen;&#10;&#10;    // Remover o useEffect problemático que estava causando loops&#10;    // useEffect(() =&gt; {&#10;    //     if (!isWaitingForRound &amp;&amp; !isPlayerFallen) {&#10;    //         setIsPlayerFallen(false);&#10;    //     }&#10;    // }, [isWaitingForRound, isPlayerFallen]);&#10;&#10;    return (&#10;        &lt;div style={{ width: &quot;100vw&quot;, height: &quot;100vh&quot;, backgroundColor: &quot;white&quot; }}&gt;&#10;            &lt;Logo/&gt;&#10;            &lt;PlayerName onNameSet={setPlayerName} /&gt;&#10;            &lt;Leaderboard&#10;                players={players}&#10;                currentPlayerId={currentPlayerId}&#10;                playerStats={playerStats}&#10;            /&gt;&#10;&#10;            {/* Indicador de estado do jogador */}&#10;            {shouldBeSpectator &amp;&amp; (&#10;                &lt;div style={{&#10;                    position: &quot;absolute&quot;,&#10;                    bottom: 20,&#10;                    left: &quot;50%&quot;,&#10;                    transform: &quot;translateX(-50%)&quot;,&#10;                    backgroundColor: &quot;rgba(0, 0, 0, 0.9)&quot;,&#10;                    color: &quot;white&quot;,&#10;                    padding: &quot;20px 30px&quot;,&#10;                    borderRadius: &quot;15px&quot;,&#10;                    fontSize: &quot;18px&quot;,&#10;                    fontWeight: &quot;bold&quot;,&#10;                    textAlign: &quot;center&quot;,&#10;                    zIndex: 1000,&#10;                    border: &quot;2px solid #fff&quot;,&#10;                    minWidth: &quot;300px&quot;&#10;                }}&gt;&#10;                    {waitingCountdown &gt; 0 ? (&#10;                        &lt;&gt;&#10;                             Próxima Rodada em: {waitingCountdown}s&#10;                        &lt;/&gt;&#10;                    ) : (&#10;                        &lt;&gt;&#10;                             Modo Espectador&#10;                            &lt;br /&gt;&#10;                            &lt;span style={{ fontSize: &quot;14px&quot;, opacity: 0.8 }}&gt;&#10;                                Aguardando próxima rodada...&#10;                            &lt;/span&gt;&#10;                        &lt;/&gt;&#10;                    )}&#10;                &lt;/div&gt;&#10;            )}&#10;&#10;&#10;            &lt;div style={{&#10;                position: &quot;absolute&quot;,&#10;                bottom: 20,&#10;                left: 20,&#10;                backgroundColor: &quot;rgba(0, 0, 0, 0.8)&quot;,&#10;                color: &quot;white&quot;,&#10;                padding: &quot;10px 15px&quot;,&#10;                borderRadius: &quot;8px&quot;,&#10;                fontSize: &quot;16px&quot;,&#10;                fontWeight: &quot;bold&quot;,&#10;                zIndex: 1000&#10;            }}&gt;&#10;                 Plataforma: {Math.max(0, Math.round(platformSize))}m&#10;                {platformSize &lt;= 20 &amp;&amp; &quot;  PERIGO!&quot;}&#10;            &lt;/div&gt;&#10;&#10;            {/* Indicador de conexão */}&#10;            &lt;div style={{&#10;                position: &quot;absolute&quot;,&#10;                top: 20,&#10;                right: 20,&#10;                color: connected ? &quot;green&quot; : &quot;red&quot;,&#10;                fontSize: &quot;16px&quot;&#10;            }}&gt;&#10;                {connected ? &quot;● Online&quot; : &quot;● Offline&quot;}&#10;            &lt;/div&gt;&#10;&#10;            &lt;Canvas&#10;                shadows&#10;                camera={{ position: [0, 8, 15], fov: 60 }}&#10;                frameloop=&quot;always&quot;&#10;                gl={{ preserveDrawingBuffer: true }}&#10;                onCreated={({ gl }) =&gt; {&#10;                    gl.setAnimationLoop = (callback) =&gt; {&#10;                        const animate = () =&gt; {&#10;                            if (callback) callback();&#10;                            requestAnimationFrame(animate);&#10;                        };&#10;                        animate();&#10;                    };&#10;                }}&#10;            &gt;&#10;                &lt;ambientLight intensity={0.6} /&gt;&#10;                &lt;directionalLight&#10;                    position={[20, 20, 10]}&#10;                    intensity={1.5}&#10;                    castShadow&#10;                    shadow-mapSize-width={2048}&#10;                    shadow-mapSize-height={2048}&#10;                    shadow-camera-left={-50}&#10;                    shadow-camera-right={50}&#10;                    shadow-camera-top={50}&#10;                    shadow-camera-bottom={-50}&#10;                /&gt;&#10;&#10;                &lt;Track platformSize={platformSize} /&gt;&#10;&#10;                {/* Renderizar o carro sempre, mas ele será invisível quando cair */}&#10;                &lt;Car&#10;                    ref={carRef}&#10;                    position={[0, 1, 0]}&#10;                    onPositionChange={handlePositionChange}&#10;                    onSendUpdate={(pos, rot, model, physics) =&gt; sendPositionUpdate(pos, rot, model, physics)}&#10;                    onPlayerFell={sendPlayerFell}&#10;                    onPlayerRespawn={sendPlayerRespawn}&#10;                    onUpdateSelf={handleUpdateSelf}&#10;                    onSelfFell={handleSelfFell}&#10;                    onFallingStateChange={handleFallingStateChange}&#10;                    otherPlayers={players}&#10;                    currentPlayerId={currentPlayerId}&#10;                    platformSize={platformSize}&#10;                    isWaitingForRound={isWaitingForRound}&#10;                /&gt;&#10;&#10;                &lt;Camera&#10;                    target={carRef}&#10;                    isPlayerFallen={shouldBeSpectator}&#10;                    platformSize={platformSize}&#10;                /&gt;&#10;&#10;                {Array.from(players.values())&#10;                    .filter(player =&gt; player.id !== currentPlayerId &amp;&amp; !player.isWaitingForRound)&#10;                    .map((player) =&gt; (&#10;                        &lt;OtherPlayer key={player.id} player={player} /&gt;&#10;                    ))}&#10;            &lt;/Canvas&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;export default App;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client/src/components/Camera.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/components/Camera.tsx" />
              <option name="originalContent" value="import { useFrame, useThree } from &quot;@react-three/fiber&quot;;&#10;import React, { useRef } from &quot;react&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type CameraProps = {&#10;    target: React.RefObject&lt;THREE.Group&gt;;&#10;};&#10;&#10;export default function Camera({ target }: CameraProps) {&#10;    const { camera } = useThree();&#10;    const tempPos = new THREE.Vector3();&#10;    const tempTarget = new THREE.Vector3();&#10;    const currentFov = useRef(45);&#10;    useFrame(() =&gt; {&#10;        if (!target.current) return;&#10;&#10;        const carPos = target.current.position;&#10;        const carRot = target.current.rotation.y;&#10;&#10;        const velocity = target.current.userData.velocity || new THREE.Vector3();&#10;        const speed = velocity.length();&#10;&#10;        const baseFov = 65;&#10;        const maxSpeedFov = 70;&#10;        const targetFov = baseFov + (speed * 0.5);&#10;        const clampedFov = Math.min(targetFov, maxSpeedFov);&#10;&#10;        currentFov.current = THREE.MathUtils.lerp(currentFov.current, clampedFov, 0.05);&#10;        camera.fov = currentFov.current;&#10;        camera.updateProjectionMatrix();&#10;&#10;        const baseDistance = 10;&#10;        const speedDistance = speed * 0.2;&#10;        const totalDistance = baseDistance + speedDistance;&#10;&#10;        const offset = new THREE.Vector3(0, 5, -totalDistance);&#10;        const rotatedOffset = offset.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), carRot);&#10;        tempPos.copy(carPos).add(rotatedOffset);&#10;&#10;        camera.position.lerp(tempPos, 0.2);&#10;&#10;        camera.lookAt(carPos);&#10;    });&#10;" />
              <option name="updatedContent" value="import { useFrame, useThree } from &quot;@react-three/fiber&quot;;&#10;import React, { useRef, useEffect, useState } from &quot;react&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type CameraProps = {&#10;    target: React.RefObject&lt;THREE.Group&gt;;&#10;    isPlayerFallen?: boolean;&#10;    platformSize?: number;&#10;};&#10;&#10;export default function Camera({ target, isPlayerFallen = false, platformSize = 200 }: CameraProps) {&#10;    const { camera } = useThree();&#10;    const tempPos = new THREE.Vector3();&#10;    const tempTarget = new THREE.Vector3();&#10;    const currentFov = useRef(45);&#10;    const [isSpectating, setIsSpectating] = useState(false);&#10;    const spectatorPosition = useRef(new THREE.Vector3(0, 100, 0));&#10;    const spectatorTarget = useRef(new THREE.Vector3(0, 0, 0));&#10;&#10;    useEffect(() =&gt; {&#10;        setIsSpectating(isPlayerFallen);&#10;    }, [isPlayerFallen]);&#10;&#10;    useFrame(() =&gt; {&#10;        if (isSpectating) {&#10;            // Modo espectador - vista superior fixa&#10;            const targetSpectatorPos = new THREE.Vector3(0, 120, 50);&#10;            const targetSpectatorLook = new THREE.Vector3(0, 0, 0);&#10;&#10;            // Transição suave para a posição de espectador&#10;            spectatorPosition.current.lerp(targetSpectatorPos, 0.05);&#10;            spectatorTarget.current.lerp(targetSpectatorLook, 0.05);&#10;&#10;            camera.position.copy(spectatorPosition.current);&#10;            camera.lookAt(spectatorTarget.current);&#10;&#10;            // FOV mais amplo para ver toda a arena&#10;            const targetFov = 80;&#10;            currentFov.current = THREE.MathUtils.lerp(currentFov.current, targetFov, 0.05);&#10;            camera.fov = currentFov.current;&#10;            camera.updateProjectionMatrix();&#10;&#10;        } else {&#10;            // Modo de jogo normal - seguir o carro&#10;            if (!target.current) return;&#10;&#10;            const carPos = target.current.position;&#10;            const carRot = target.current.rotation.y;&#10;&#10;            const velocity = target.current.userData.velocity || new THREE.Vector3();&#10;            const speed = velocity.length();&#10;&#10;            const baseFov = 65;&#10;            const maxSpeedFov = 70;&#10;            const targetFov = baseFov + (speed * 0.5);&#10;            const clampedFov = Math.min(targetFov, maxSpeedFov);&#10;&#10;            currentFov.current = THREE.MathUtils.lerp(currentFov.current, clampedFov, 0.05);&#10;            camera.fov = currentFov.current;&#10;            camera.updateProjectionMatrix();&#10;&#10;            const baseDistance = 10;&#10;            const speedDistance = speed * 0.2;&#10;            const totalDistance = baseDistance + speedDistance;&#10;&#10;            const offset = new THREE.Vector3(0, 5, -totalDistance);&#10;            const rotatedOffset = offset.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), carRot);&#10;            tempPos.copy(carPos).add(rotatedOffset);&#10;&#10;            camera.position.lerp(tempPos, 0.2);&#10;            camera.lookAt(carPos);&#10;&#10;            // Atualizar posições de referência para transição suave&#10;            spectatorPosition.current.copy(camera.position);&#10;            spectatorTarget.current.copy(carPos);&#10;        }&#10;    });&#10;&#10;    return null;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client/src/components/Car.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/components/Car.tsx" />
              <option name="originalContent" value="import React, { useRef, useEffect, useState, forwardRef, useMemo } from &quot;react&quot;;&#10;import { useFrame } from &quot;@react-three/fiber&quot;;&#10;import { useGLTF } from &quot;@react-three/drei&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type CarProps = {&#10;    position?: [number, number, number];&#10;    onPositionChange?: (position: [number, number, number], rotation: number) =&gt; void;&#10;    onSendUpdate?: (position: [number, number, number], rotation: number, carModel: string) =&gt; void;&#10;    onPlayerFell?: () =&gt; void;&#10;    onPlayerRespawn?: (position: [number, number, number], rotation: number, carModel: string) =&gt; void;&#10;    onUpdateSelf?: (position: [number, number, number], rotation: number, carModel: string) =&gt; void;&#10;    onSelfFell?: () =&gt; void;&#10;    onFallingStateChange?: (isFalling: boolean) =&gt; void;&#10;    otherPlayers?: Map&lt;string, any&gt;;&#10;    currentPlayerId?: string;&#10;    platformSize: number;&#10;    isWaitingForRound?: boolean;&#10;};&#10;&#10;const Car = forwardRef&lt;THREE.Group, CarProps&gt;(({&#10;    position = [0, 0.5, 0],&#10;    onPositionChange,&#10;    onSendUpdate,&#10;    onPlayerFell,&#10;    onPlayerRespawn,&#10;    onUpdateSelf,&#10;    onSelfFell,&#10;    onFallingStateChange,&#10;    otherPlayers,&#10;    currentPlayerId,&#10;    platformSize,&#10;    isWaitingForRound = false&#10;}, ref) =&gt; {&#10;    const groupRef = useRef&lt;THREE.Group&gt;(null);&#10;    const [keys, setKeys] = useState&lt;{ [key: string]: boolean }&gt;({});&#10;    const velocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const angleRef = useRef(0);&#10;    const fallingRef = useRef(false);&#10;    const fallTimeRef = useRef(0);&#10;    const rotationVelocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const initialPosition = useRef(new THREE.Vector3(...position));&#10;    const [selectedCar, setSelectedCar] = useState(() =&gt; {&#10;        const carNumber = Math.floor(Math.random() * 4) + 1;&#10;        return `/models/car${carNumber}.glb`;&#10;    });&#10;    const jumpVelocityRef = useRef(0);&#10;    const isJumpingRef = useRef(false);&#10;    const jumpCooldownRef = useRef(false);&#10;&#10;    const { scene } = useGLTF(selectedCar);&#10;&#10;    const getRandomSpawnPosition = () =&gt; {&#10;        const randomX = (Math.random() - 0.5) * 120;&#10;        const randomZ = (Math.random() - 0.5) * 120;&#10;        const randomAngle = Math.random() * Math.PI * 2;&#10;        return { position: [randomX, initialPosition.current.y, randomZ] as [number, number, number], angle: randomAngle };&#10;    };&#10;&#10;    useEffect(() =&gt; {&#10;        if (!ref || !groupRef.current) return;&#10;        if (typeof ref === &quot;function&quot;) ref(groupRef.current);&#10;        else ref.current = groupRef.current;&#10;    }, [ref]);&#10;&#10;    useEffect(() =&gt; {&#10;        const down = (e: KeyboardEvent) =&gt; setKeys(k =&gt; ({ ...k, [e.key]: true }));&#10;        const up = (e: KeyboardEvent) =&gt; setKeys(k =&gt; ({ ...k, [e.key]: false }));&#10;        window.addEventListener(&quot;keydown&quot;, down);&#10;        window.addEventListener(&quot;keyup&quot;, up);&#10;        return () =&gt; {&#10;            window.removeEventListener(&quot;keydown&quot;, down);&#10;            window.removeEventListener(&quot;keyup&quot;, up);&#10;        };&#10;    }, []);&#10;&#10;    const checkCollision = (pos1: THREE.Vector3, pos2: THREE.Vector3, minDistance = 5.5) =&gt; {&#10;        return pos1.distanceTo(pos2) &lt; minDistance;&#10;    };&#10;&#10;    const handleCollision = (myPos: THREE.Vector3, otherPos: THREE.Vector3, myVelocity: THREE.Vector3) =&gt; {&#10;        const separationDirection = new THREE.Vector3().subVectors(myPos, otherPos);&#10;        const distance = separationDirection.length();&#10;&#10;        if (distance &lt; 0.1) {&#10;            separationDirection.set(&#10;                (Math.random() - 0.5) * 2,&#10;                0,&#10;                (Math.random() - 0.5) * 2&#10;            );&#10;        }&#10;&#10;        separationDirection.normalize();&#10;&#10;        const minDistance = 4.5;&#10;        const separationForce = Math.max(0, (minDistance - distance) / minDistance) * 0.5;&#10;&#10;        const immediateForce = separationDirection.clone().multiplyScalar(separationForce * 2);&#10;        myPos.add(new THREE.Vector3(immediateForce.x, 0, immediateForce.z));&#10;&#10;        const velocityForce = separationDirection.clone().multiplyScalar(0.15);&#10;        myVelocity.add(new THREE.Vector3(velocityForce.x, 0, velocityForce.z));&#10;&#10;        const maxVelocity = 0.5;&#10;        if (myVelocity.length() &gt; maxVelocity) {&#10;            myVelocity.normalize().multiplyScalar(maxVelocity);&#10;        }&#10;&#10;        return separationDirection;&#10;    };&#10;&#10;    const resolveOverlap = (current: THREE.Group) =&gt; {&#10;        if (!otherPlayers || !currentPlayerId) return;&#10;&#10;        const maxIterations = 3;&#10;&#10;        for (let iteration = 0; iteration &lt; maxIterations; iteration++) {&#10;            let hasOverlap = false;&#10;&#10;            Array.from(otherPlayers.values()).forEach(otherPlayer =&gt; {&#10;                if (otherPlayer.id !== currentPlayerId &amp;&amp; !otherPlayer.falling) {&#10;                    const otherPos = new THREE.Vector3(...otherPlayer.position);&#10;                    const distance = current.position.distanceTo(otherPos);&#10;                    const minDistance = 4.5;&#10;&#10;                    if (distance &lt; minDistance) {&#10;                        hasOverlap = true;&#10;&#10;                        const direction = new THREE.Vector3()&#10;                            .subVectors(current.position, otherPos)&#10;                            .normalize();&#10;&#10;                        if (direction.length() &lt; 0.1) {&#10;                            direction.set(&#10;                                (Math.random() - 0.5) * 2,&#10;                                0,&#10;                                (Math.random() - 0.5) * 2&#10;                            ).normalize();&#10;                        }&#10;&#10;                        const pushDistance = (minDistance - distance) * 0.6;&#10;                        const pushVector = direction.multiplyScalar(pushDistance);&#10;                        current.position.add(new THREE.Vector3(pushVector.x, 0, pushVector.z));&#10;                    }&#10;                }&#10;            });&#10;&#10;            if (!hasOverlap) break;&#10;        }&#10;    };&#10;&#10;    useFrame((state, delta) =&gt; {&#10;        const current = groupRef.current;&#10;        if (!current) return;&#10;&#10;        const safeDelta = Math.min(delta, 1/30);&#10;&#10;        if (fallingRef.current) {&#10;            velocityRef.current.y -= 9.8 * safeDelta;&#10;&#10;            const direction = new THREE.Vector3(&#10;                Math.sin(angleRef.current) * velocityRef.current.z,&#10;                0,&#10;                Math.cos(angleRef.current) * velocityRef.current.z&#10;            );&#10;            current.position.add(direction);&#10;            current.position.add(new THREE.Vector3(0, velocityRef.current.y * safeDelta, 0));&#10;&#10;            rotationVelocityRef.current.x += 2 * safeDelta;&#10;            current.rotation.x -= rotationVelocityRef.current.x * safeDelta;&#10;&#10;            fallTimeRef.current += safeDelta;&#10;&#10;            // Notificar mudança para modo espectador após 3 segundos&#10;            if (fallTimeRef.current &gt;= 3 &amp;&amp; onFallingStateChange) {&#10;                onFallingStateChange(true);&#10;            }&#10;&#10;            // Esconder o carro depois de 3 segundos de queda&#10;            if (fallTimeRef.current &gt;= 3) {&#10;                current.position.set(0, -1000, 0);&#10;                current.visible = false;&#10;            }&#10;            return;&#10;        }&#10;&#10;        // Lógica do pulo&#10;        if (keys[&quot; &quot;] &amp;&amp; !isJumpingRef.current &amp;&amp; !jumpCooldownRef.current) {&#10;            jumpVelocityRef.current = 0.5; // Força inicial do pulo&#10;            isJumpingRef.current = true;&#10;            jumpCooldownRef.current = true;&#10;            setTimeout(() =&gt; jumpCooldownRef.current = false, 500); // Cooldown de 1.5 segundos&#10;        }&#10;&#10;        if (isJumpingRef.current) {&#10;            jumpVelocityRef.current -= 1.5 * safeDelta; // Gravidade&#10;            current.position.y += jumpVelocityRef.current;&#10;&#10;            if (current.position.y &lt;= 0.5) { // Altura base do carro&#10;                current.position.y = 0.5;&#10;                isJumpingRef.current = false;&#10;                jumpVelocityRef.current = 0;&#10;            }&#10;        }&#10;&#10;        const velocity = velocityRef.current;&#10;        let angle = angleRef.current;&#10;&#10;        const acceleration = 0.02;&#10;        const maxSpeed = 0.4;&#10;        const turnSpeed = 0.03;&#10;        const friction = 0.99;&#10;        const brakeForce = 0.5;&#10;        const reverseAcceleration = 0.01;&#10;        const maxReverseSpeed = 0.2;&#10;&#10;        if (keys[&quot;ArrowUp&quot;] || keys[&quot;w&quot;]) {&#10;            velocity.z = Math.min(velocity.z + acceleration, maxSpeed);&#10;        }&#10;&#10;        if (keys[&quot;ArrowDown&quot;] || keys[&quot;s&quot;]) {&#10;            if (velocity.z &gt; 0.5) {&#10;                velocity.z = Math.max(velocity.z - brakeForce, 0);&#10;            }&#10;            else if (velocity.z &lt;= 0.3 &amp;&amp; velocity.z &gt;= -0.2) {&#10;                velocity.z = Math.max(velocity.z - reverseAcceleration, -maxReverseSpeed);&#10;            }&#10;        }&#10;&#10;        const speedFactor = Math.abs(velocity.z) / maxSpeed;&#10;        if ((keys[&quot;ArrowLeft&quot;] || keys[&quot;a&quot;]) &amp;&amp; speedFactor &gt; 0.1) {&#10;            angle += turnSpeed * speedFactor;&#10;        }&#10;        if ((keys[&quot;ArrowRight&quot;] || keys[&quot;d&quot;]) &amp;&amp; speedFactor &gt; 0.1) {&#10;            angle -= turnSpeed * speedFactor;&#10;        }&#10;&#10;        velocity.multiplyScalar(friction);&#10;&#10;        resolveOverlap(current);&#10;&#10;        // Modificar a verificação de colisão para considerar a altura&#10;        if (otherPlayers &amp;&amp; currentPlayerId) {&#10;            Array.from(otherPlayers.values()).forEach(otherPlayer =&gt; {&#10;                if (otherPlayer.id !== currentPlayerId &amp;&amp; !otherPlayer.falling) {&#10;                    const otherPos = new THREE.Vector3(...otherPlayer.position);&#10;                    const heightDiff = Math.abs(current.position.y - otherPos.y);&#10;&#10;                    if (checkCollision(current.position, otherPos) &amp;&amp; heightDiff &lt; 2) {&#10;                        handleCollision(current.position, otherPos, velocity);&#10;                    }&#10;                }&#10;            });&#10;        }&#10;&#10;        const movement = new THREE.Vector3(&#10;            Math.sin(angle) * velocity.z,&#10;            0,&#10;            Math.cos(angle) * velocity.z&#10;        );&#10;&#10;        current.position.add(movement);&#10;        current.rotation.y = angle;&#10;&#10;        const carLength = 3;&#10;        const frontX = current.position.x + Math.sin(angle) * carLength;&#10;        const frontZ = current.position.z + Math.cos(angle) * carLength;&#10;&#10;        // Verificar se saiu da plataforma OU se a plataforma é muito pequena&#10;        const platformRadius = platformSize / 2;&#10;        const carDistance = Math.sqrt(current.position.x * current.position.x + current.position.z * current.position.z);&#10;&#10;        if (Math.abs(frontX) &gt; platformRadius || Math.abs(frontZ) &gt; platformRadius || carDistance &gt; platformRadius || platformSize &lt;= 5) {&#10;            if (!fallingRef.current) {&#10;                fallingRef.current = true;&#10;                velocityRef.current.y = 0;&#10;                rotationVelocityRef.current.set(0, 0, 0);&#10;&#10;                // Parar o tempo imediatamente quando começar a cair&#10;                if (onSelfFell) {&#10;                    onSelfFell();&#10;                }&#10;&#10;                if (onPlayerFell) {&#10;                    onPlayerFell();&#10;                }&#10;            }&#10;        }&#10;&#10;        current.userData.velocity = velocity.clone();&#10;&#10;        if (onPositionChange) {&#10;            onPositionChange([current.position.x, current.position.y, current.position.z], angle);&#10;        }&#10;&#10;        if (onUpdateSelf) {&#10;            onUpdateSelf([current.position.x, current.position.y, current.position.z], angle, selectedCar);&#10;        }&#10;&#10;        if (onSendUpdate &amp;&amp; Math.random() &lt; 0.8) {&#10;            onSendUpdate(&#10;                [current.position.x, current.position.y, current.position.z],&#10;                angle,&#10;                selectedCar&#10;            );&#10;        }&#10;&#10;        angleRef.current = angle;&#10;    });&#10;&#10;    // Remover os useEffects problemáticos e substituir por um simples&#10;    useEffect(() =&gt; {&#10;        const current = groupRef.current;&#10;        if (!current) return;&#10;&#10;        // Só resetar quando explicitamente não estiver esperando rodada&#10;        if (!isWaitingForRound) {&#10;            // Reset para nova rodada&#10;            const spawnData = getRandomSpawnPosition();&#10;&#10;            current.position.set(...spawnData.position);&#10;            current.visible = true;&#10;            velocityRef.current.set(0, 0, 0);&#10;            rotationVelocityRef.current.set(0, 0, 0);&#10;            angleRef.current = spawnData.angle;&#10;            current.rotation.set(0, spawnData.angle, 0);&#10;            fallingRef.current = false;&#10;            fallTimeRef.current = 0;&#10;            isJumpingRef.current = false;&#10;            jumpVelocityRef.current = 0;&#10;&#10;            if (onFallingStateChange) {&#10;                onFallingStateChange(false);&#10;            }&#10;&#10;            const carNumber = Math.floor(Math.random() * 4) + 1;&#10;            const newCarPath = `/models/car${carNumber}.glb`;&#10;            setSelectedCar(newCarPath);&#10;        } else {&#10;            // Se está esperando rodada, esconder o carro&#10;            if (current) {&#10;                current.position.set(0, -1000, 0);&#10;                current.visible = false;&#10;                fallingRef.current = false;&#10;&#10;                if (onFallingStateChange) {&#10;                    onFallingStateChange(true);&#10;                }&#10;            }&#10;        }&#10;    }, [isWaitingForRound]);&#10;&#10;    return (&#10;        &lt;group ref={groupRef} position={position} castShadow&gt;&#10;            &lt;primitive object={scene.clone()} scale={[3.2, 3.2, 3.2]} rotation={[0, Math.PI / 2, 0]} /&gt;&#10;        &lt;/group&gt;&#10;    );&#10;});&#10;&#10;for (let i = 1; i &lt;= 4; i++) {&#10;    useGLTF.preload(`/models/car${i}.glb`);&#10;}&#10;&#10;export default Car;&#10;" />
              <option name="updatedContent" value="import React, { useRef, useEffect, useState, forwardRef, useMemo } from &quot;react&quot;;&#10;import { useFrame } from &quot;@react-three/fiber&quot;;&#10;import { useGLTF } from &quot;@react-three/drei&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type CarProps = {&#10;    position?: [number, number, number];&#10;    onPositionChange?: (position: [number, number, number], rotation: number) =&gt; void;&#10;    onSendUpdate?: (position: [number, number, number], rotation: number, carModel: string) =&gt; void;&#10;    onPlayerFell?: () =&gt; void;&#10;    onPlayerRespawn?: (position: [number, number, number], rotation: number, carModel: string) =&gt; void;&#10;    onUpdateSelf?: (position: [number, number, number], rotation: number, carModel: string) =&gt; void;&#10;    onSelfFell?: () =&gt; void;&#10;    onFallingStateChange?: (isFalling: boolean) =&gt; void;&#10;    otherPlayers?: Map&lt;string, any&gt;;&#10;    currentPlayerId?: string;&#10;    platformSize: number;&#10;    isWaitingForRound?: boolean;&#10;};&#10;&#10;const Car = forwardRef&lt;THREE.Group, CarProps&gt;(({&#10;    position = [0, 0.5, 0],&#10;    onPositionChange,&#10;    onSendUpdate,&#10;    onPlayerFell,&#10;    onPlayerRespawn,&#10;    onUpdateSelf,&#10;    onSelfFell,&#10;    onFallingStateChange,&#10;    otherPlayers,&#10;    currentPlayerId,&#10;    platformSize,&#10;    isWaitingForRound = false&#10;}, ref) =&gt; {&#10;    const groupRef = useRef&lt;THREE.Group&gt;(null);&#10;    const [keys, setKeys] = useState&lt;{ [key: string]: boolean }&gt;({});&#10;    const velocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const angleRef = useRef(0);&#10;    const fallingRef = useRef(false);&#10;    const fallTimeRef = useRef(0);&#10;    const rotationVelocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const initialPosition = useRef(new THREE.Vector3(...position));&#10;    const [selectedCar, setSelectedCar] = useState(() =&gt; {&#10;        const carNumber = Math.floor(Math.random() * 4) + 1;&#10;        return `/models/car${carNumber}.glb`;&#10;    });&#10;    const jumpVelocityRef = useRef(0);&#10;    const isJumpingRef = useRef(false);&#10;    const jumpCooldownRef = useRef(false);&#10;&#10;    const { scene } = useGLTF(selectedCar);&#10;&#10;    const getRandomSpawnPosition = () =&gt; {&#10;        const randomX = (Math.random() - 0.5) * 120;&#10;        const randomZ = (Math.random() - 0.5) * 120;&#10;        const randomAngle = Math.random() * Math.PI * 2;&#10;        return { position: [randomX, initialPosition.current.y, randomZ] as [number, number, number], angle: randomAngle };&#10;    };&#10;&#10;    useEffect(() =&gt; {&#10;        if (!ref || !groupRef.current) return;&#10;        if (typeof ref === &quot;function&quot;) ref(groupRef.current);&#10;        else ref.current = groupRef.current;&#10;    }, [ref]);&#10;&#10;    useEffect(() =&gt; {&#10;        const down = (e: KeyboardEvent) =&gt; setKeys(k =&gt; ({ ...k, [e.key]: true }));&#10;        const up = (e: KeyboardEvent) =&gt; setKeys(k =&gt; ({ ...k, [e.key]: false }));&#10;        window.addEventListener(&quot;keydown&quot;, down);&#10;        window.addEventListener(&quot;keyup&quot;, up);&#10;        return () =&gt; {&#10;            window.removeEventListener(&quot;keydown&quot;, down);&#10;            window.removeEventListener(&quot;keyup&quot;, up);&#10;        };&#10;    }, []);&#10;&#10;    const checkCollision = (pos1: THREE.Vector3, pos2: THREE.Vector3, minDistance = 5.5) =&gt; {&#10;        return pos1.distanceTo(pos2) &lt; minDistance;&#10;    };&#10;&#10;    const handleCollision = (myPos: THREE.Vector3, otherPos: THREE.Vector3, myVelocity: THREE.Vector3) =&gt; {&#10;        const separationDirection = new THREE.Vector3().subVectors(myPos, otherPos);&#10;        const distance = separationDirection.length();&#10;&#10;        if (distance &lt; 0.1) {&#10;            separationDirection.set(&#10;                (Math.random() - 0.5) * 2,&#10;                0,&#10;                (Math.random() - 0.5) * 2&#10;            );&#10;        }&#10;&#10;        separationDirection.normalize();&#10;&#10;        const minDistance = 4.5;&#10;        const separationForce = Math.max(0, (minDistance - distance) / minDistance) * 0.5;&#10;&#10;        const immediateForce = separationDirection.clone().multiplyScalar(separationForce * 2);&#10;        myPos.add(new THREE.Vector3(immediateForce.x, 0, immediateForce.z));&#10;&#10;        const velocityForce = separationDirection.clone().multiplyScalar(0.15);&#10;        myVelocity.add(new THREE.Vector3(velocityForce.x, 0, velocityForce.z));&#10;&#10;        const maxVelocity = 0.5;&#10;        if (myVelocity.length() &gt; maxVelocity) {&#10;            myVelocity.normalize().multiplyScalar(maxVelocity);&#10;        }&#10;&#10;        return separationDirection;&#10;    };&#10;&#10;    const resolveOverlap = (current: THREE.Group) =&gt; {&#10;        if (!otherPlayers || !currentPlayerId) return;&#10;&#10;        const maxIterations = 3;&#10;&#10;        for (let iteration = 0; iteration &lt; maxIterations; iteration++) {&#10;            let hasOverlap = false;&#10;&#10;            Array.from(otherPlayers.values()).forEach(otherPlayer =&gt; {&#10;                if (otherPlayer.id !== currentPlayerId &amp;&amp; !otherPlayer.falling) {&#10;                    const otherPos = new THREE.Vector3(...otherPlayer.position);&#10;                    const distance = current.position.distanceTo(otherPos);&#10;                    const minDistance = 4.5;&#10;&#10;                    if (distance &lt; minDistance) {&#10;                        hasOverlap = true;&#10;&#10;                        const direction = new THREE.Vector3()&#10;                            .subVectors(current.position, otherPos)&#10;                            .normalize();&#10;&#10;                        if (direction.length() &lt; 0.1) {&#10;                            direction.set(&#10;                                (Math.random() - 0.5) * 2,&#10;                                0,&#10;                                (Math.random() - 0.5) * 2&#10;                            ).normalize();&#10;                        }&#10;&#10;                        const pushDistance = (minDistance - distance) * 0.6;&#10;                        const pushVector = direction.multiplyScalar(pushDistance);&#10;                        current.position.add(new THREE.Vector3(pushVector.x, 0, pushVector.z));&#10;                    }&#10;                }&#10;            });&#10;&#10;            if (!hasOverlap) break;&#10;        }&#10;    };&#10;&#10;    // Sistema de colisão aprimorado&#10;    const massRef = useRef(1.0);&#10;    const accelerationRef = useRef(0);&#10;    const lastVelocityRef = useRef(0);&#10;    const collisionForceRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const lastPositionRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const collisionCooldownRef = useRef(0);&#10;&#10;    const calculateMass = () =&gt; {&#10;        const speed = velocityRef.current.length();&#10;        const acceleration = Math.abs(accelerationRef.current);&#10;        return Math.max(0.8, Math.min(2.5, 1.0 + (speed * 0.4) + (acceleration * 0.3)));&#10;    };&#10;&#10;    const performCollisionDetection = (current: THREE.Group) =&gt; {&#10;        if (!otherPlayers || !currentPlayerId) return false;&#10;&#10;        const myPosition = current.position.clone();&#10;        const now = Date.now();&#10;        &#10;        if (collisionCooldownRef.current &gt; now) return false;&#10;&#10;        let hasCollision = false;&#10;        const collisionRadius = 4.5;&#10;&#10;        Array.from(otherPlayers.values()).forEach(otherPlayer =&gt; {&#10;            if (otherPlayer.id !== currentPlayerId &amp;&amp; !otherPlayer.falling) {&#10;                const otherPos = new THREE.Vector3(...otherPlayer.position);&#10;                &#10;                // Verificação rápida&#10;                const roughDistance = Math.abs(myPosition.x - otherPos.x) + Math.abs(myPosition.z - otherPos.z);&#10;                if (roughDistance &gt; collisionRadius * 1.5) return;&#10;                &#10;                const distance = myPosition.distanceTo(otherPos);&#10;                const heightDiff = Math.abs(myPosition.y - otherPos.y);&#10;&#10;                if (distance &lt; collisionRadius &amp;&amp; heightDiff &lt; 2) {&#10;                    hasCollision = true;&#10;                    &#10;                    // Calcular direção da colisão (de outro para mim)&#10;                    const collisionDirection = new THREE.Vector3()&#10;                        .subVectors(myPosition, otherPos)&#10;                        .normalize();&#10;                    &#10;                    if (collisionDirection.length() &lt; 0.1) {&#10;                        collisionDirection.set(&#10;                            (Math.random() - 0.5) * 2,&#10;                            0,&#10;                            (Math.random() - 0.5) * 2&#10;                        ).normalize();&#10;                    }&#10;&#10;                    const overlap = collisionRadius - distance;&#10;                    &#10;                    // Calcular minha velocidade na direção da colisão&#10;                    const mySpeed = velocityRef.current.length();&#10;                    const myDirection = new THREE.Vector3(&#10;                        Math.sin(angleRef.current),&#10;                        0,&#10;                        Math.cos(angleRef.current)&#10;                    );&#10;                    &#10;                    // Verificar se estou me movendo em direção ao outro jogador&#10;                    const movingTowardsOther = myDirection.dot(collisionDirection.clone().negate()) &gt; 0;&#10;                    &#10;                    // Se estou atacando, recebo menos força; se estou parado/fugindo, recebo mais&#10;                    let forceMultiplier = 0.5;&#10;                    if (movingTowardsOther &amp;&amp; mySpeed &gt; 0.1) {&#10;                        forceMultiplier = 0.3; // Menos força se estou atacando&#10;                    } else {&#10;                        forceMultiplier = 0.8 + (otherPlayer.velocity || 0) * 0.5; // Mais força se estou sendo atacado&#10;                    }&#10;                    &#10;                    const separationForce = overlap * forceMultiplier;&#10;                    &#10;                    // Aplicar separação imediata&#10;                    const separation = collisionDirection.clone()&#10;                        .multiplyScalar(separationForce);&#10;                    &#10;                    current.position.add(new THREE.Vector3(separation.x, 0, separation.z));&#10;                    &#10;                    // Aplicar força à velocidade&#10;                    const velocityImpact = collisionDirection.clone()&#10;                        .multiplyScalar(Math.min(0.4, separationForce * 0.4));&#10;                    &#10;                    velocityRef.current.add(new THREE.Vector3(&#10;                        velocityImpact.x, &#10;                        0, &#10;                        velocityImpact.z&#10;                    ));&#10;                    &#10;                    // Limitar velocidade após colisão&#10;                    const maxVelocity = 0.9;&#10;                    if (velocityRef.current.length() &gt; maxVelocity) {&#10;                        velocityRef.current.normalize().multiplyScalar(maxVelocity);&#10;                    }&#10;                    &#10;                    // Armazenar força para efeitos visuais&#10;                    collisionForceRef.current.copy(separation);&#10;                    &#10;                    // Cooldown&#10;                    collisionCooldownRef.current = now + 60;&#10;                }&#10;            }&#10;        });&#10;&#10;        return hasCollision;&#10;    };&#10;&#10;    useFrame((state, delta) =&gt; {&#10;        const current = groupRef.current;&#10;        if (!current) return;&#10;&#10;        const safeDelta = Math.min(delta, 1/30);&#10;&#10;        if (fallingRef.current) {&#10;            velocityRef.current.y -= 9.8 * safeDelta;&#10;&#10;            const direction = new THREE.Vector3(&#10;                Math.sin(angleRef.current) * velocityRef.current.z,&#10;                0,&#10;                Math.cos(angleRef.current) * velocityRef.current.z&#10;            );&#10;            current.position.add(direction);&#10;            current.position.add(new THREE.Vector3(0, velocityRef.current.y * safeDelta, 0));&#10;&#10;            rotationVelocityRef.current.x += 2 * safeDelta;&#10;            current.rotation.x -= rotationVelocityRef.current.x * safeDelta;&#10;&#10;            fallTimeRef.current += safeDelta;&#10;&#10;            // Notificar mudança para modo espectador após 3 segundos&#10;            if (fallTimeRef.current &gt;= 3 &amp;&amp; onFallingStateChange) {&#10;                onFallingStateChange(true);&#10;            }&#10;&#10;            // Esconder o carro depois de 3 segundos de queda&#10;            if (fallTimeRef.current &gt;= 3) {&#10;                current.position.set(0, -1000, 0);&#10;                current.visible = false;&#10;            }&#10;            return;&#10;        }&#10;&#10;        // Lógica do pulo&#10;        if (keys[&quot; &quot;] &amp;&amp; !isJumpingRef.current &amp;&amp; !jumpCooldownRef.current) {&#10;            jumpVelocityRef.current = 0.5; // Força inicial do pulo&#10;            isJumpingRef.current = true;&#10;            jumpCooldownRef.current = true;&#10;            setTimeout(() =&gt; jumpCooldownRef.current = false, 500); // Cooldown de 1.5 segundos&#10;        }&#10;&#10;        if (isJumpingRef.current) {&#10;            jumpVelocityRef.current -= 1.5 * safeDelta; // Gravidade&#10;            current.position.y += jumpVelocityRef.current;&#10;&#10;            if (current.position.y &lt;= 0.5) { // Altura base do carro&#10;                current.position.y = 0.5;&#10;                isJumpingRef.current = false;&#10;                jumpVelocityRef.current = 0;&#10;            }&#10;        }&#10;&#10;        // Calcular física&#10;        const currentSpeed = velocityRef.current.length();&#10;        accelerationRef.current = (currentSpeed - lastVelocityRef.current) / safeDelta;&#10;        lastVelocityRef.current = currentSpeed;&#10;        massRef.current = calculateMass();&#10;&#10;        const velocity = velocityRef.current;&#10;        let angle = angleRef.current;&#10;&#10;        const acceleration = 0.02;&#10;        const maxSpeed = 0.4;&#10;        const turnSpeed = 0.03;&#10;        const friction = 0.99;&#10;        const brakeForce = 0.5;&#10;        const reverseAcceleration = 0.01;&#10;        const maxReverseSpeed = 0.2;&#10;&#10;        if (keys[&quot;ArrowUp&quot;] || keys[&quot;w&quot;]) {&#10;            velocity.z = Math.min(velocity.z + acceleration, maxSpeed);&#10;        }&#10;&#10;        if (keys[&quot;ArrowDown&quot;] || keys[&quot;s&quot;]) {&#10;            if (velocity.z &gt; 0.5) {&#10;                velocity.z = Math.max(velocity.z - brakeForce, 0);&#10;            }&#10;            else if (velocity.z &lt;= 0.3 &amp;&amp; velocity.z &gt;= -0.2) {&#10;                velocity.z = Math.max(velocity.z - reverseAcceleration, -maxReverseSpeed);&#10;            }&#10;        }&#10;&#10;        const speedFactor = Math.abs(velocity.z) / maxSpeed;&#10;        if ((keys[&quot;ArrowLeft&quot;] || keys[&quot;a&quot;]) &amp;&amp; speedFactor &gt; 0.1) {&#10;            angle += turnSpeed * speedFactor;&#10;        }&#10;        if ((keys[&quot;ArrowRight&quot;] || keys[&quot;d&quot;]) &amp;&amp; speedFactor &gt; 0.1) {&#10;            angle -= turnSpeed * speedFactor;&#10;        }&#10;&#10;        // Aplicar força de colisão residual&#10;        if (collisionForceRef.current.length() &gt; 0.01) {&#10;            const dampingFactor = 0.1;&#10;            velocityRef.current.add(new THREE.Vector3(&#10;                collisionForceRef.current.x * dampingFactor,&#10;                0,&#10;                collisionForceRef.current.z * dampingFactor&#10;            ));&#10;            collisionForceRef.current.multiplyScalar(0.88);&#10;        }&#10;&#10;        velocity.multiplyScalar(friction);&#10;&#10;        // Sistema de colisão otimizado&#10;        performCollisionDetection(current);&#10;&#10;        const movement = new THREE.Vector3(&#10;            Math.sin(angle) * velocity.z,&#10;            0,&#10;            Math.cos(angle) * velocity.z&#10;        );&#10;&#10;        current.position.add(movement);&#10;        current.rotation.y = angle;&#10;&#10;        const carLength = 3;&#10;        const frontX = current.position.x + Math.sin(angle) * carLength;&#10;        const frontZ = current.position.z + Math.cos(angle) * carLength;&#10;&#10;        // Verificar se saiu da plataforma OU se a plataforma é muito pequena&#10;        const platformRadius = platformSize / 2;&#10;        const carDistance = Math.sqrt(current.position.x * current.position.x + current.position.z * current.position.z);&#10;&#10;        if (Math.abs(frontX) &gt; platformRadius || Math.abs(frontZ) &gt; platformRadius || carDistance &gt; platformRadius || platformSize &lt;= 5) {&#10;            if (!fallingRef.current) {&#10;                fallingRef.current = true;&#10;                velocityRef.current.y = 0;&#10;                rotationVelocityRef.current.set(0, 0, 0);&#10;&#10;                // Parar o tempo imediatamente quando começar a cair&#10;                if (onSelfFell) {&#10;                    onSelfFell();&#10;                }&#10;&#10;                if (onPlayerFell) {&#10;                    onPlayerFell();&#10;                }&#10;            }&#10;        }&#10;&#10;        current.userData.velocity = velocity.clone();&#10;        current.userData.mass = massRef.current;&#10;        current.userData.acceleration = accelerationRef.current;&#10;&#10;        if (onPositionChange) {&#10;            onPositionChange([current.position.x, current.position.y, current.position.z], angle);&#10;        }&#10;&#10;        if (onUpdateSelf) {&#10;            onUpdateSelf([current.position.x, current.position.y, current.position.z], angle, selectedCar);&#10;        }&#10;&#10;        // Enviar dados com informações de física&#10;        if (onSendUpdate &amp;&amp; Math.random() &lt; 0.4) {&#10;            onSendUpdate(&#10;                [current.position.x, current.position.y, current.position.z],&#10;                angle,&#10;                selectedCar,&#10;                {&#10;                    mass: massRef.current,&#10;                    velocity: velocityRef.current.length(),&#10;                    acceleration: accelerationRef.current&#10;                }&#10;            );&#10;        }&#10;&#10;        angleRef.current = angle;&#10;        lastPositionRef.current.copy(current.position);&#10;    });&#10;&#10;    // Remover os useEffects problemáticos e substituir por um simples&#10;    useEffect(() =&gt; {&#10;        const current = groupRef.current;&#10;        if (!current) return;&#10;&#10;        // Só resetar quando explicitamente não estiver esperando rodada&#10;        if (!isWaitingForRound) {&#10;            // Reset para nova rodada&#10;            const spawnData = getRandomSpawnPosition();&#10;&#10;            current.position.set(...spawnData.position);&#10;            current.visible = true;&#10;            velocityRef.current.set(0, 0, 0);&#10;            rotationVelocityRef.current.set(0, 0, 0);&#10;            angleRef.current = spawnData.angle;&#10;            current.rotation.set(0, spawnData.angle, 0);&#10;            fallingRef.current = false;&#10;            fallTimeRef.current = 0;&#10;            isJumpingRef.current = false;&#10;            jumpVelocityRef.current = 0;&#10;&#10;            if (onFallingStateChange) {&#10;                onFallingStateChange(false);&#10;            }&#10;&#10;            const carNumber = Math.floor(Math.random() * 4) + 1;&#10;            const newCarPath = `/models/car${carNumber}.glb`;&#10;            setSelectedCar(newCarPath);&#10;        } else {&#10;            // Se está esperando rodada, esconder o carro&#10;            if (current) {&#10;                current.position.set(0, -1000, 0);&#10;                current.visible = false;&#10;                fallingRef.current = false;&#10;&#10;                if (onFallingStateChange) {&#10;                    onFallingStateChange(true);&#10;                }&#10;            }&#10;        }&#10;    }, [isWaitingForRound]);&#10;&#10;    return (&#10;        &lt;group ref={groupRef} position={position} castShadow&gt;&#10;            &lt;primitive object={scene.clone()} scale={[3.2, 3.2, 3.2]} rotation={[0, Math.PI / 2, 0]} /&gt;&#10;        &lt;/group&gt;&#10;    );&#10;});&#10;&#10;for (let i = 1; i &lt;= 4; i++) {&#10;    useGLTF.preload(`/models/car${i}.glb`);&#10;}&#10;&#10;export default Car;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client/src/components/Leaderboard.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/components/Leaderboard.tsx" />
              <option name="originalContent" value="import React from &quot;react&quot;;&#10;&#10;type LeaderboardProps = {&#10;    players: Map&lt;string, any&gt;;&#10;    currentPlayerId?: string;&#10;    playerStats: Map&lt;string, {&#10;        name: string;&#10;        currentTime: number;&#10;        bestTime: number;&#10;        totalRounds: number;&#10;    }&gt;;&#10;};&#10;&#10;export default function Leaderboard({ players, currentPlayerId, playerStats }: LeaderboardProps) {&#10;    const formatTime = (milliseconds: number) =&gt; {&#10;        const totalSeconds = Math.floor(milliseconds / 1000);&#10;        const minutes = Math.floor(totalSeconds / 60);&#10;        const seconds = totalSeconds % 60;&#10;        const ms = Math.floor((milliseconds % 1000) / 10); // Centésimos de segundo&#10;&#10;        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;&#10;    };&#10;&#10;    const leaderboardData = Array.from(players.values())&#10;        .map(player =&gt; {&#10;            const stats = playerStats.get(player.id);&#10;            return {&#10;                id: player.id,&#10;                name: player.name,&#10;                currentTime: stats?.currentTime || 0,&#10;                bestTime: stats?.bestTime || 0,&#10;                totalRounds: stats?.totalRounds || 0,&#10;                isCurrentPlayer: player.id === currentPlayerId,&#10;                isAlive: !player.falling&#10;            };&#10;        })&#10;        .sort((a, b) =&gt; {&#10;            // Ordenar por melhor tempo (bestTime) em ordem decrescente&#10;            return b.bestTime - a.bestTime;&#10;        });&#10;&#10;    const getPositionColor = (index: number) =&gt; {&#10;        switch (index) {&#10;            case 0: return &quot;#FFD700&quot;; // Ouro&#10;            case 1: return &quot;#C0C0C0&quot;; // Prata&#10;            case 2: return &quot;#CD7F32&quot;; // Bronze&#10;            default: return &quot;#666666&quot;;&#10;        }&#10;    };&#10;&#10;    const getPositionIcon = (index: number) =&gt; {&#10;        switch (index) {&#10;            case 0: return &quot;&quot;;&#10;            case 1: return &quot;&quot;;&#10;            case 2: return &quot;&quot;;&#10;            default: return `${index + 1}º`;&#10;        }&#10;    };&#10;&#10;    return (&#10;        &lt;div style={{&#10;            position: &quot;absolute&quot;,&#10;            top: 20,&#10;            left: 20,&#10;            backgroundColor: &quot;rgba(0, 0, 0, 0.92)&quot;,&#10;            padding: &quot;20px&quot;,&#10;            borderRadius: &quot;12px&quot;,&#10;            minWidth: &quot;350px&quot;,&#10;            maxWidth: &quot;400px&quot;,&#10;            boxShadow: &quot;0 10px 25px rgba(0, 0, 0, 0.5)&quot;,&#10;            border: &quot;2px solid #444&quot;,&#10;            zIndex: 1000,&#10;            backdropFilter: &quot;blur(10px)&quot;,&#10;            fontFamily: &quot;'Roboto Mono', monospace&quot;&#10;        }}&gt;&#10;            &lt;h3 style={{&#10;                margin: &quot;0 0 18px 0&quot;,&#10;                color: &quot;#fff&quot;,&#10;                fontSize: &quot;20px&quot;,&#10;                textAlign: &quot;center&quot;,&#10;                borderBottom: &quot;2px solid #555&quot;,&#10;                paddingBottom: &quot;12px&quot;,&#10;                fontWeight: &quot;bold&quot;,&#10;                letterSpacing: &quot;0.5px&quot;&#10;            }}&gt;&#10;                 HALL DA FAMA&#10;            &lt;/h3&gt;&#10;&#10;            {leaderboardData.length === 0 ? (&#10;                &lt;div style={{&#10;                    color: &quot;#aaa&quot;,&#10;                    textAlign: &quot;center&quot;,&#10;                    fontStyle: &quot;italic&quot;,&#10;                    backgroundColor: &quot;rgba(255, 255, 255, 0.1)&quot;,&#10;                    padding: &quot;15px&quot;,&#10;                    borderRadius: &quot;8px&quot;&#10;                }}&gt;&#10;                     Aguardando pilotos...&#10;                &lt;/div&gt;&#10;            ) : (&#10;                &lt;div style={{ maxHeight: &quot;400px&quot;, overflowY: &quot;auto&quot; }}&gt;&#10;                    {leaderboardData.map((player, index) =&gt; (&#10;                        &lt;div&#10;                            key={player.id}&#10;                            style={{&#10;                                display: &quot;flex&quot;,&#10;                                flexDirection: &quot;column&quot;,&#10;                                padding: &quot;12px 15px&quot;,&#10;                                margin: &quot;8px 0&quot;,&#10;                                backgroundColor: player.isCurrentPlayer&#10;                                    ? &quot;rgba(33, 150, 243, 0.25)&quot;&#10;                                    : &quot;rgba(255, 255, 255, 0.08)&quot;,&#10;                                borderRadius: &quot;10px&quot;,&#10;                                border: player.isCurrentPlayer&#10;                                    ? &quot;2px solid #2196f3&quot;&#10;                                    : &quot;1px solid rgba(255, 255, 255, 0.1)&quot;,&#10;                                transition: &quot;all 0.3s ease&quot;,&#10;                                position: &quot;relative&quot;&#10;                            }}&#10;                        &gt;&#10;                            {/* Header com posição e nome */}&#10;                            &lt;div style={{&#10;                                display: &quot;flex&quot;,&#10;                                alignItems: &quot;center&quot;,&#10;                                justifyContent: &quot;space-between&quot;,&#10;                                marginBottom: &quot;8px&quot;&#10;                            }}&gt;&#10;                                &lt;div style={{ display: &quot;flex&quot;, alignItems: &quot;center&quot;, gap: &quot;12px&quot; }}&gt;&#10;                                    &lt;span style={{&#10;                                        fontSize: &quot;18px&quot;,&#10;                                        minWidth: &quot;35px&quot;,&#10;                                        textAlign: &quot;center&quot;,&#10;                                        color: getPositionColor(index),&#10;                                        fontWeight: &quot;bold&quot;&#10;                                    }}&gt;&#10;                                        {getPositionIcon(index)}&#10;                                    &lt;/span&gt;&#10;                                    &lt;div&gt;&#10;                                        &lt;div style={{&#10;                                            color: &quot;#fff&quot;,&#10;                                            fontSize: &quot;16px&quot;,&#10;                                            fontWeight: &quot;bold&quot;,&#10;                                            maxWidth: &quot;140px&quot;,&#10;                                            overflow: &quot;hidden&quot;,&#10;                                            textOverflow: &quot;ellipsis&quot;,&#10;                                            whiteSpace: &quot;nowrap&quot;&#10;                                        }}&gt;&#10;                                            {player.name}&#10;                                            {player.isCurrentPlayer &amp;&amp; &quot; &quot;}&#10;                                        &lt;/div&gt;&#10;                                        &lt;div style={{&#10;                                            fontSize: &quot;11px&quot;,&#10;                                            color: &quot;#bbb&quot;,&#10;                                            marginTop: &quot;2px&quot;&#10;                                        }}&gt;&#10;                                            {player.isAlive &amp;&amp; &quot; ATIVO&quot;}&#10;                                        &lt;/div&gt;&#10;                                    &lt;/div&gt;&#10;                                &lt;/div&gt;&#10;&#10;                                {/* Melhor tempo destacado */}&#10;                                &lt;div style={{ textAlign: &quot;right&quot; }}&gt;&#10;                                    &lt;div style={{&#10;                                        fontSize: &quot;16px&quot;,&#10;                                        fontWeight: &quot;bold&quot;,&#10;                                        color: player.bestTime &gt; 0 ? &quot;#4caf50&quot; : &quot;#999&quot;,&#10;                                        fontFamily: &quot;'Roboto Mono', monospace&quot;&#10;                                    }}&gt;&#10;                                        {player.bestTime &gt; 0 ? formatTime(player.bestTime) : &quot;--:--:--&quot;}&#10;                                    &lt;/div&gt;&#10;                                    &lt;div style={{&#10;                                        fontSize: &quot;10px&quot;,&#10;                                        color: &quot;#999&quot;,&#10;                                        marginTop: &quot;2px&quot;&#10;                                    }}&gt;&#10;                                        RECORDE&#10;                                    &lt;/div&gt;&#10;                                &lt;/div&gt;&#10;                            &lt;/div&gt;&#10;&#10;                            {/* Tempo atual - só mostra se o jogador estiver vivo e não esperando rodada */}&#10;                            {player.isAlive &amp;&amp; !player.isCurrentPlayer ? null : (&#10;                                player.isAlive &amp;&amp; (&#10;                                    &lt;div style={{&#10;                                        backgroundColor: &quot;rgba(255, 255, 255, 0.05)&quot;,&#10;                                        padding: &quot;8px 12px&quot;,&#10;                                        borderRadius: &quot;6px&quot;,&#10;                                        textAlign: &quot;center&quot;&#10;                                    }}&gt;&#10;                                        &lt;div style={{&#10;                                            fontSize: &quot;18px&quot;,&#10;                                            fontWeight: &quot;bold&quot;,&#10;                                            color: &quot;#00ff88&quot;,&#10;                                            fontFamily: &quot;'Roboto Mono', monospace&quot;&#10;                                        }}&gt;&#10;                                            {formatTime(player.currentTime)}&#10;                                        &lt;/div&gt;&#10;                                        &lt;div style={{ fontSize: &quot;10px&quot;, color: &quot;#aaa&quot; }}&gt;&#10;                                            TEMPO ATUAL&#10;                                        &lt;/div&gt;&#10;                                    &lt;/div&gt;&#10;                                )&#10;                            )}&#10;&#10;                            {/* Indicador de novo recorde */}&#10;                            {player.currentTime &gt; 0 &amp;&amp; player.currentTime === player.bestTime &amp;&amp; player.bestTime &gt; 0 &amp;&amp; (&#10;                                &lt;div style={{&#10;                                    position: &quot;absolute&quot;,&#10;                                    top: &quot;-5px&quot;,&#10;                                    right: &quot;-5px&quot;,&#10;                                    backgroundColor: &quot;#FFD700&quot;,&#10;                                    color: &quot;#000&quot;,&#10;                                    padding: &quot;2px 6px&quot;,&#10;                                    borderRadius: &quot;10px&quot;,&#10;                                    fontSize: &quot;10px&quot;,&#10;                                    fontWeight: &quot;bold&quot;,&#10;                                    animation: &quot;pulse 1s infinite&quot;&#10;                                }}&gt;&#10;                                    NOVO!&#10;                                &lt;/div&gt;&#10;                            )}&#10;                        &lt;/div&gt;&#10;                    ))}&#10;                &lt;/div&gt;&#10;            )}&#10;&#10;            &lt;div style={{&#10;                marginTop: &quot;15px&quot;,&#10;                paddingTop: &quot;12px&quot;,&#10;                borderTop: &quot;1px solid #555&quot;,&#10;                display: &quot;flex&quot;,&#10;                justifyContent: &quot;center&quot;,&#10;                alignItems: &quot;center&quot;&#10;            }}&gt;&#10;                &lt;div style={{&#10;                    fontSize: &quot;12px&quot;,&#10;                    color: &quot;#aaa&quot;&#10;                }}&gt;&#10;                     {players.size} Piloto{players.size !== 1 ? 's' : ''} Online&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            &lt;style jsx&gt;{`&#10;                @keyframes pulse {&#10;                    0% { transform: scale(1); }&#10;                    50% { transform: scale(1.1); }&#10;                    100% { transform: scale(1); }&#10;                }&#10;            `}&lt;/style&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="import React from &quot;react&quot;;&#10;&#10;type LeaderboardProps = {&#10;    players: Map&lt;string, any&gt;;&#10;    currentPlayerId?: string;&#10;    playerStats: Map&lt;string, {&#10;        name: string;&#10;        currentTime: number;&#10;        bestTime: number;&#10;        totalRounds: number;&#10;    }&gt;;&#10;};&#10;&#10;export default function Leaderboard({ players, currentPlayerId, playerStats }: LeaderboardProps) {&#10;    const formatTime = (milliseconds: number) =&gt; {&#10;        const totalSeconds = Math.floor(milliseconds / 1000);&#10;        const minutes = Math.floor(totalSeconds / 60);&#10;        const seconds = totalSeconds % 60;&#10;        const ms = Math.floor((milliseconds % 1000) / 10); // Centésimos de segundo&#10;&#10;        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;&#10;    };&#10;&#10;    const leaderboardData = Array.from(players.values())&#10;        .map(player =&gt; {&#10;            const stats = playerStats.get(player.id);&#10;            return {&#10;                id: player.id,&#10;                name: player.name,&#10;                currentTime: stats?.currentTime || 0,&#10;                bestTime: stats?.bestTime || 0,&#10;                totalRounds: stats?.totalRounds || 0,&#10;                isCurrentPlayer: player.id === currentPlayerId,&#10;                isAlive: !player.falling&#10;            };&#10;        })&#10;        .sort((a, b) =&gt; {&#10;            // Ordenar por melhor tempo (bestTime) em ordem decrescente&#10;            return b.bestTime - a.bestTime;&#10;        });&#10;&#10;    const getPositionColor = (index: number) =&gt; {&#10;        switch (index) {&#10;            case 0: return &quot;#FFD700&quot;; // Ouro&#10;            case 1: return &quot;#C0C0C0&quot;; // Prata&#10;            case 2: return &quot;#CD7F32&quot;; // Bronze&#10;            default: return &quot;#666666&quot;;&#10;        }&#10;    };&#10;&#10;    const getPositionIcon = (index: number) =&gt; {&#10;        switch (index) {&#10;            case 0: return &quot;&quot;;&#10;            case 1: return &quot;&quot;;&#10;            case 2: return &quot;&quot;;&#10;            default: return `${index + 1}º`;&#10;        }&#10;    };&#10;&#10;    return (&#10;        &lt;div style={{&#10;            position: &quot;absolute&quot;,&#10;            top: 20,&#10;            left: 20,&#10;            backgroundColor: &quot;rgba(0, 0, 0, 0.92)&quot;,&#10;            padding: &quot;20px&quot;,&#10;            borderRadius: &quot;12px&quot;,&#10;            minWidth: &quot;350px&quot;,&#10;            maxWidth: &quot;400px&quot;,&#10;            boxShadow: &quot;0 10px 25px rgba(0, 0, 0, 0.5)&quot;,&#10;            border: &quot;2px solid #444&quot;,&#10;            zIndex: 1000,&#10;            backdropFilter: &quot;blur(10px)&quot;,&#10;            fontFamily: &quot;'Roboto Mono', monospace&quot;&#10;        }}&gt;&#10;            &lt;h3 style={{&#10;                margin: &quot;0 0 18px 0&quot;,&#10;                color: &quot;#fff&quot;,&#10;                fontSize: &quot;20px&quot;,&#10;                textAlign: &quot;center&quot;,&#10;                borderBottom: &quot;2px solid #555&quot;,&#10;                paddingBottom: &quot;12px&quot;,&#10;                fontWeight: &quot;bold&quot;,&#10;                letterSpacing: &quot;0.5px&quot;&#10;            }}&gt;&#10;                 HALL DA FAMA&#10;            &lt;/h3&gt;&#10;&#10;            {leaderboardData.length === 0 ? (&#10;                &lt;div style={{&#10;                    color: &quot;#aaa&quot;,&#10;                    textAlign: &quot;center&quot;,&#10;                    fontStyle: &quot;italic&quot;,&#10;                    backgroundColor: &quot;rgba(255, 255, 255, 0.1)&quot;,&#10;                    padding: &quot;15px&quot;,&#10;                    borderRadius: &quot;8px&quot;&#10;                }}&gt;&#10;                     Aguardando pilotos...&#10;                &lt;/div&gt;&#10;            ) : (&#10;                &lt;div style={{ maxHeight: &quot;400px&quot;, overflowY: &quot;auto&quot; }}&gt;&#10;                    {leaderboardData.map((player, index) =&gt; (&#10;                        &lt;div&#10;                            key={player.id}&#10;                            style={{&#10;                                display: &quot;flex&quot;,&#10;                                flexDirection: &quot;column&quot;,&#10;                                padding: &quot;12px 15px&quot;,&#10;                                margin: &quot;8px 0&quot;,&#10;                                backgroundColor: player.isCurrentPlayer&#10;                                    ? &quot;rgba(33, 150, 243, 0.25)&quot;&#10;                                    : &quot;rgba(255, 255, 255, 0.08)&quot;,&#10;                                borderRadius: &quot;10px&quot;,&#10;                                border: player.isCurrentPlayer&#10;                                    ? &quot;2px solid #2196f3&quot;&#10;                                    : &quot;1px solid rgba(255, 255, 255, 0.1)&quot;,&#10;                                transition: &quot;all 0.3s ease&quot;,&#10;                                position: &quot;relative&quot;&#10;                            }}&#10;                        &gt;&#10;                            {/* Header com posição e nome */}&#10;                            &lt;div style={{&#10;                                display: &quot;flex&quot;,&#10;                                alignItems: &quot;center&quot;,&#10;                                justifyContent: &quot;space-between&quot;,&#10;                                marginBottom: &quot;8px&quot;&#10;                            }}&gt;&#10;                                &lt;div style={{ display: &quot;flex&quot;, alignItems: &quot;center&quot;, gap: &quot;12px&quot; }}&gt;&#10;                                    &lt;span style={{&#10;                                        fontSize: &quot;18px&quot;,&#10;                                        minWidth: &quot;35px&quot;,&#10;                                        textAlign: &quot;center&quot;,&#10;                                        color: getPositionColor(index),&#10;                                        fontWeight: &quot;bold&quot;&#10;                                    }}&gt;&#10;                                        {getPositionIcon(index)}&#10;                                    &lt;/span&gt;&#10;                                    &lt;div&gt;&#10;                                        &lt;div style={{&#10;                                            color: &quot;#fff&quot;,&#10;                                            fontSize: &quot;16px&quot;,&#10;                                            fontWeight: &quot;bold&quot;,&#10;                                            maxWidth: &quot;140px&quot;,&#10;                                            overflow: &quot;hidden&quot;,&#10;                                            textOverflow: &quot;ellipsis&quot;,&#10;                                            whiteSpace: &quot;nowrap&quot;&#10;                                        }}&gt;&#10;                                            {player.name}&#10;                                            {player.isCurrentPlayer &amp;&amp; &quot; &quot;}&#10;                                        &lt;/div&gt;&#10;                                        &lt;div style={{&#10;                                            fontSize: &quot;11px&quot;,&#10;                                            color: &quot;#bbb&quot;,&#10;                                            marginTop: &quot;2px&quot;&#10;                                        }}&gt;&#10;                                            {player.isAlive &amp;&amp; &quot; ATIVO&quot;}&#10;                                        &lt;/div&gt;&#10;                                    &lt;/div&gt;&#10;                                &lt;/div&gt;&#10;&#10;                                {/* Melhor tempo destacado */}&#10;                                &lt;div style={{ textAlign: &quot;right&quot; }}&gt;&#10;                                    &lt;div style={{&#10;                                        fontSize: &quot;16px&quot;,&#10;                                        fontWeight: &quot;bold&quot;,&#10;                                        color: player.bestTime &gt; 0 ? &quot;#4caf50&quot; : &quot;#999&quot;,&#10;                                        fontFamily: &quot;'Roboto Mono', monospace&quot;&#10;                                    }}&gt;&#10;                                        {player.bestTime &gt; 0 ? formatTime(player.bestTime) : &quot;--:--:--&quot;}&#10;                                    &lt;/div&gt;&#10;                                    &lt;div style={{&#10;                                        fontSize: &quot;10px&quot;,&#10;                                        color: &quot;#999&quot;,&#10;                                        marginTop: &quot;2px&quot;&#10;                                    }}&gt;&#10;                                        RECORDE&#10;                                    &lt;/div&gt;&#10;                                &lt;/div&gt;&#10;                            &lt;/div&gt;&#10;&#10;                            {/* Tempo atual - só mostra se o jogador estiver vivo e não esperando rodada */}&#10;                            {player.isAlive &amp;&amp; !player.isCurrentPlayer ? null : (&#10;                                player.isAlive &amp;&amp; (&#10;                                    &lt;div style={{&#10;                                        backgroundColor: &quot;rgba(255, 255, 255, 0.05)&quot;,&#10;                                        padding: &quot;8px 12px&quot;,&#10;                                        borderRadius: &quot;6px&quot;,&#10;                                        textAlign: &quot;center&quot;&#10;                                    }}&gt;&#10;                                        &lt;div style={{&#10;                                            fontSize: &quot;18px&quot;,&#10;                                            fontWeight: &quot;bold&quot;,&#10;                                            color: &quot;#00ff88&quot;,&#10;                                            fontFamily: &quot;'Roboto Mono', monospace&quot;&#10;                                        }}&gt;&#10;                                            {formatTime(player.currentTime)}&#10;                                        &lt;/div&gt;&#10;                                        &lt;div style={{ fontSize: &quot;10px&quot;, color: &quot;#aaa&quot; }}&gt;&#10;                                            TEMPO ATUAL&#10;                                        &lt;/div&gt;&#10;                                    &lt;/div&gt;&#10;                                )&#10;                            )}&#10;&#10;                            {/* Indicador de novo recorde - melhorar a condição */}&#10;                            {player.isCurrentPlayer &amp;&amp; player.isAlive &amp;&amp; player.currentTime &gt; 0 &amp;&amp; &#10;                             player.currentTime &gt;= player.bestTime &amp;&amp; player.bestTime &gt; 0 &amp;&amp; (&#10;                                &lt;div style={{&#10;                                    position: &quot;absolute&quot;,&#10;                                    top: &quot;-5px&quot;,&#10;                                    right: &quot;-5px&quot;,&#10;                                    backgroundColor: &quot;#FFD700&quot;,&#10;                                    color: &quot;#000&quot;,&#10;                                    padding: &quot;2px 6px&quot;,&#10;                                    borderRadius: &quot;10px&quot;,&#10;                                    fontSize: &quot;10px&quot;,&#10;                                    fontWeight: &quot;bold&quot;,&#10;                                    animation: &quot;pulse 1s infinite&quot;,&#10;                                    boxShadow: &quot;0 0 10px rgba(255, 215, 0, 0.5)&quot;&#10;                                }}&gt;&#10;                                     RECORDE!&#10;                                &lt;/div&gt;&#10;                            )}&#10;                        &lt;/div&gt;&#10;                    ))}&#10;                &lt;/div&gt;&#10;            )}&#10;&#10;            &lt;div style={{&#10;                marginTop: &quot;15px&quot;,&#10;                paddingTop: &quot;12px&quot;,&#10;                borderTop: &quot;1px solid #555&quot;,&#10;                display: &quot;flex&quot;,&#10;                justifyContent: &quot;center&quot;,&#10;                alignItems: &quot;center&quot;&#10;            }}&gt;&#10;                &lt;div style={{&#10;                    fontSize: &quot;12px&quot;,&#10;                    color: &quot;#aaa&quot;&#10;                }}&gt;&#10;                     {players.size} Piloto{players.size !== 1 ? 's' : ''} Online&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            &lt;style jsx&gt;{`&#10;                @keyframes pulse {&#10;                    0% { transform: scale(1); }&#10;                    50% { transform: scale(1.1); }&#10;                    100% { transform: scale(1); }&#10;                }&#10;            `}&lt;/style&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client/src/components/NewPlayerPopup.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/components/NewPlayerPopup.tsx" />
              <option name="updatedContent" value="import React, { useEffect, useState } from &quot;react&quot;;&#10;&#10;type NewPlayerPopupProps = {&#10;    playerName: string | null;&#10;    onClose: () =&gt; void;&#10;};&#10;&#10;export default function NewPlayerPopup({ playerName, onClose }: NewPlayerPopupProps) {&#10;    const [visible, setVisible] = useState(false);&#10;&#10;    useEffect(() =&gt; {&#10;        if (playerName) {&#10;            setVisible(true);&#10;            const timer = setTimeout(() =&gt; {&#10;                setVisible(false);&#10;                setTimeout(onClose, 300);&#10;            }, 3000);&#10;            return () =&gt; clearTimeout(timer);&#10;        }&#10;    }, [playerName, onClose]);&#10;&#10;    if (!playerName) return null;&#10;&#10;    return (&#10;        &lt;div className={`new-player-popup ${visible ? 'visible' : ''}`}&gt;&#10;            &lt;div className=&quot;new-player-content&quot;&gt;&#10;                &lt;div className=&quot;new-player-icon&quot;&gt;️&lt;/div&gt;&#10;                &lt;div className=&quot;new-player-text&quot;&gt;&#10;                    &lt;strong&gt;{playerName}&lt;/strong&gt; entrou na corrida!&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client/src/components/OtherPlayer.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/components/OtherPlayer.tsx" />
              <option name="originalContent" value="import React, { useRef, useEffect, useState } from &quot;react&quot;;&#10;import { useGLTF, Text } from &quot;@react-three/drei&quot;;&#10;import { useFrame, useThree } from &quot;@react-three/fiber&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type OtherPlayerProps = {&#10;    player: {&#10;        id: string;&#10;        name: string;&#10;        position: [number, number, number];&#10;        rotation: number;&#10;        carModel: string | number;&#10;        falling: boolean;&#10;    };&#10;};&#10;&#10;export default function OtherPlayer({ player }: OtherPlayerProps) {&#10;    const groupRef = useRef&lt;THREE.Group&gt;(null);&#10;    const nameRef = useRef&lt;THREE.Group&gt;(null);&#10;    const { camera } = useThree();&#10;&#10;    const targetPosition = useRef(new THREE.Vector3(...player.position));&#10;    const targetRotation = useRef(player.rotation);&#10;    const fallRotationRef = useRef(0);&#10;    const fallVelocityRef = useRef(0);&#10;    const lastPosition = useRef(new THREE.Vector3(...player.position));&#10;    const [isBeingPushed, setIsBeingPushed] = useState(false);&#10;    const [localFalling, setLocalFalling] = useState(false);&#10;    const rotationVelocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const smoothedPosition = useRef(new THREE.Vector3(...player.position));&#10;&#10;    const carNumber = typeof player.carModel === &quot;string&quot;&#10;        ? player.carModel.match(/car(\d+)\.glb/)?.[1] || &quot;1&quot;&#10;        : String(player.carModel);&#10;    const carPath = `/models/car${carNumber}.glb`;&#10;    const { scene } = useGLTF(carPath);&#10;&#10;    const getRandomSpawnPosition = (): [number, number, number] =&gt; {&#10;        const randomX = (Math.random() - 0.5) * 120;&#10;        const randomZ = (Math.random() - 0.5) * 120;&#10;        return [randomX, 0.5, randomZ];&#10;    };&#10;&#10;    useEffect(() =&gt; {&#10;        const newPos = new THREE.Vector3(...player.position);&#10;        const oldPos = lastPosition.current;&#10;        const distance = newPos.distanceTo(oldPos);&#10;&#10;        if (distance &gt; 50) {&#10;            setLocalFalling(false);&#10;            fallRotationRef.current = 0;&#10;            fallVelocityRef.current = 0;&#10;            rotationVelocityRef.current.set(0, 0, 0);&#10;&#10;            if (player.position[0] === 0 &amp;&amp; player.position[2] === 0) {&#10;                const randomPos = getRandomSpawnPosition();&#10;                targetPosition.current.set(...randomPos);&#10;            } else {&#10;                targetPosition.current.copy(newPos);&#10;            }&#10;        } else {&#10;            if (distance &gt; 0.8) {&#10;                setIsBeingPushed(true);&#10;                setTimeout(() =&gt; setIsBeingPushed(false), 200);&#10;            }&#10;            targetPosition.current.copy(newPos);&#10;        }&#10;&#10;        targetRotation.current = player.rotation;&#10;        lastPosition.current.copy(newPos);&#10;&#10;        if (!player.falling &amp;&amp; localFalling) {&#10;        } else if (player.falling &amp;&amp; !localFalling) {&#10;            setLocalFalling(true);&#10;        }&#10;    }, [player.position, player.rotation, player.falling]);&#10;&#10;    useFrame((state, delta) =&gt; {&#10;        if (!groupRef.current) return;&#10;        const safeDelta = Math.min(delta, 1 / 30);&#10;&#10;        const trackSize = 200;&#10;        const carLength = 3;&#10;        const angle = targetRotation.current;&#10;&#10;        const frontX = targetPosition.current.x + Math.sin(angle) * carLength;&#10;        const frontZ = targetPosition.current.z + Math.cos(angle) * carLength;&#10;&#10;        if ((Math.abs(frontX) &gt; trackSize/2 || Math.abs(frontZ) &gt; trackSize/2) &amp;&amp; !localFalling) {&#10;            setLocalFalling(true);&#10;            fallVelocityRef.current = 0;&#10;            rotationVelocityRef.current.set(0, 0, 0);&#10;        }&#10;&#10;        if (player.falling || localFalling) {&#10;            fallVelocityRef.current += 9.8 * safeDelta;&#10;            groupRef.current.position.y -= fallVelocityRef.current * safeDelta;&#10;&#10;            const horizontalMovement = new THREE.Vector3(&#10;                Math.sin(targetRotation.current) * 0.1,&#10;                0,&#10;                Math.cos(targetRotation.current) * 0.1&#10;            );&#10;            groupRef.current.position.add(horizontalMovement);&#10;&#10;            rotationVelocityRef.current.x += 2 * safeDelta;&#10;            groupRef.current.rotation.x -= rotationVelocityRef.current.x * safeDelta;&#10;&#10;            const currentY = groupRef.current.rotation.y;&#10;            const targetY = targetRotation.current;&#10;            groupRef.current.rotation.y = THREE.MathUtils.lerp(currentY, targetY, 0.8);&#10;        } else {&#10;            const lerpFactor = isBeingPushed ? 0.8 : 0.15;&#10;&#10;            // Agora usamos a altura real do jogador&#10;            smoothedPosition.current.lerp(new THREE.Vector3(&#10;                player.position[0],&#10;                player.position[1], // Altura do pulo é sincronizada&#10;                player.position[2]&#10;            ), lerpFactor);&#10;&#10;            groupRef.current.position.copy(smoothedPosition.current);&#10;&#10;            const currentY = groupRef.current.rotation.y;&#10;            const targetY = targetRotation.current;&#10;            groupRef.current.rotation.y = THREE.MathUtils.lerp(currentY, targetY, lerpFactor);&#10;&#10;            groupRef.current.rotation.x = THREE.MathUtils.lerp(groupRef.current.rotation.x, 0, 0.1);&#10;        }&#10;&#10;        // Atualiza a posição do nome para seguir a altura do pulo&#10;        if (nameRef.current) {&#10;            nameRef.current.position.set(&#10;                groupRef.current.position.x,&#10;                groupRef.current.position.y + 5, // Nome segue a altura do carro&#10;                groupRef.current.position.z&#10;            );&#10;            nameRef.current.lookAt(camera.position);&#10;        }&#10;    });&#10;&#10;    return (&#10;        &lt;group&gt;&#10;            &lt;group ref={groupRef} position={player.position} castShadow&gt;&#10;                &lt;primitive&#10;                    object={scene.clone()}&#10;                    scale={[3.2, 3.2, 3.2]}&#10;                    rotation={[0, Math.PI / 2, 0]}&#10;                /&gt;&#10;            &lt;/group&gt;&#10;&#10;            &lt;group ref={nameRef}&gt;&#10;                &lt;mesh&gt;&#10;                    &lt;planeGeometry args={[player.name.length * 0.5 + 0.5, 0.8]} /&gt;&#10;                    &lt;meshBasicMaterial color=&quot;#666666&quot; transparent opacity={0.8} /&gt;&#10;                &lt;/mesh&gt;&#10;&#10;                &lt;Text&#10;                    position={[0, 0, 0.01]}&#10;                    fontSize={0.8}&#10;                    color=&quot;#ffffff&quot;&#10;                    anchorX=&quot;center&quot;&#10;                    anchorY=&quot;middle&quot;&#10;                &gt;&#10;                    {player.name}&#10;                &lt;/Text&gt;&#10;            &lt;/group&gt;&#10;        &lt;/group&gt;&#10;    );&#10;}&#10;&#10;for (let i = 1; i &lt;= 4; i++) {&#10;    useGLTF.preload(`/models/car${i}.glb`);&#10;}&#10;" />
              <option name="updatedContent" value="import React, { useRef, useEffect, useState } from &quot;react&quot;;&#10;import { useGLTF, Text } from &quot;@react-three/drei&quot;;&#10;import { useFrame, useThree } from &quot;@react-three/fiber&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type OtherPlayerProps = {&#10;    player: {&#10;        id: string;&#10;        name: string;&#10;        position: [number, number, number];&#10;        rotation: number;&#10;        carModel: string | number;&#10;        falling: boolean;&#10;    };&#10;};&#10;&#10;export default function OtherPlayer({ player }: OtherPlayerProps) {&#10;    const groupRef = useRef&lt;THREE.Group&gt;(null);&#10;    const nameRef = useRef&lt;THREE.Group&gt;(null);&#10;    const { camera } = useThree();&#10;&#10;    const targetPosition = useRef(new THREE.Vector3(...player.position));&#10;    const targetRotation = useRef(player.rotation);&#10;    const fallRotationRef = useRef(0);&#10;    const fallVelocityRef = useRef(0);&#10;    const lastPosition = useRef(new THREE.Vector3(...player.position));&#10;    const [isBeingPushed, setIsBeingPushed] = useState(false);&#10;    const [localFalling, setLocalFalling] = useState(false);&#10;    const rotationVelocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const smoothedPosition = useRef(new THREE.Vector3(...player.position));&#10;    const smoothedRotation = useRef(0);&#10;&#10;    const carNumber = typeof player.carModel === &quot;string&quot;&#10;        ? player.carModel.match(/car(\d+)\.glb/)?.[1] || &quot;1&quot;&#10;        : String(player.carModel);&#10;    const carPath = `/models/car${carNumber}.glb`;&#10;    const { scene } = useGLTF(carPath);&#10;&#10;    const getRandomSpawnPosition = (): [number, number, number] =&gt; {&#10;        const randomX = (Math.random() - 0.5) * 120;&#10;        const randomZ = (Math.random() - 0.5) * 120;&#10;        return [randomX, 0.5, randomZ];&#10;    };&#10;&#10;    useEffect(() =&gt; {&#10;        const newPos = new THREE.Vector3(...player.position);&#10;        const oldPos = lastPosition.current;&#10;        const distance = newPos.distanceTo(oldPos);&#10;&#10;        if (distance &gt; 50) {&#10;            setLocalFalling(false);&#10;            fallRotationRef.current = 0;&#10;            fallVelocityRef.current = 0;&#10;            rotationVelocityRef.current.set(0, 0, 0);&#10;&#10;            if (player.position[0] === 0 &amp;&amp; player.position[2] === 0) {&#10;                const randomPos = getRandomSpawnPosition();&#10;                targetPosition.current.set(...randomPos);&#10;            } else {&#10;                targetPosition.current.copy(newPos);&#10;            }&#10;        } else {&#10;            if (distance &gt; 0.8) {&#10;                setIsBeingPushed(true);&#10;                setTimeout(() =&gt; setIsBeingPushed(false), 200);&#10;            }&#10;            targetPosition.current.copy(newPos);&#10;        }&#10;&#10;        targetRotation.current = player.rotation;&#10;        lastPosition.current.copy(newPos);&#10;&#10;        if (!player.falling &amp;&amp; localFalling) {&#10;        } else if (player.falling &amp;&amp; !localFalling) {&#10;            setLocalFalling(true);&#10;        }&#10;    }, [player.position, player.rotation, player.falling]);&#10;&#10;    useFrame((state, delta) =&gt; {&#10;        if (!groupRef.current) return;&#10;        const safeDelta = Math.min(delta, 1 / 30);&#10;&#10;        const trackSize = 200;&#10;        const carLength = 3;&#10;        const angle = targetRotation.current;&#10;&#10;        const frontX = targetPosition.current.x + Math.sin(angle) * carLength;&#10;        const frontZ = targetPosition.current.z + Math.cos(angle) * carLength;&#10;&#10;        if ((Math.abs(frontX) &gt; trackSize/2 || Math.abs(frontZ) &gt; trackSize/2) &amp;&amp; !localFalling) {&#10;            setLocalFalling(true);&#10;            fallVelocityRef.current = 0;&#10;            rotationVelocityRef.current.set(0, 0, 0);&#10;        }&#10;&#10;        if (player.falling || localFalling) {&#10;            fallVelocityRef.current += 9.8 * safeDelta;&#10;            groupRef.current.position.y -= fallVelocityRef.current * safeDelta;&#10;&#10;            const horizontalMovement = new THREE.Vector3(&#10;                Math.sin(targetRotation.current) * 0.1,&#10;                0,&#10;                Math.cos(targetRotation.current) * 0.1&#10;            );&#10;            groupRef.current.position.add(horizontalMovement);&#10;&#10;            rotationVelocityRef.current.x += 2 * safeDelta;&#10;            groupRef.current.rotation.x -= rotationVelocityRef.current.x * safeDelta;&#10;&#10;            const currentY = groupRef.current.rotation.y;&#10;            const targetY = targetRotation.current;&#10;            groupRef.current.rotation.y = THREE.MathUtils.lerp(currentY, targetY, 0.8);&#10;        } else {&#10;            // Sistema de interpolação baseado na colisão&#10;            const collisionForce = player.collisionForce || 0;&#10;            const impactDirection = player.impactDirection;&#10;            const isAttacker = player.isAttacker;&#10;            &#10;            // Ajustar interpolação baseada na força da colisão&#10;            let lerpFactor = 0.15; // Base&#10;            &#10;            if (collisionForce &gt; 2.0) {&#10;                // Colisão forte - movimento mais rápido&#10;                lerpFactor = isAttacker ? 0.7 : 0.9; // Atacante se move menos, defendente mais&#10;            } else if (collisionForce &gt; 1.0) {&#10;                lerpFactor = 0.5;&#10;            } else if (isBeingPushed) {&#10;                lerpFactor = 0.4;&#10;            }&#10;&#10;            // Interpolar posição&#10;            smoothedPosition.current.lerp(targetPosition.current, lerpFactor);&#10;            groupRef.current.position.copy(smoothedPosition.current);&#10;&#10;            // Interpolar rotação&#10;            const currentY = groupRef.current.rotation.y;&#10;            const targetY = targetRotation.current;&#10;            const rotationDiff = targetY - currentY;&#10;            &#10;            let normalizedDiff = rotationDiff;&#10;            if (Math.abs(rotationDiff) &gt; Math.PI) {&#10;                normalizedDiff = rotationDiff - Math.sign(rotationDiff) * 2 * Math.PI;&#10;            }&#10;            &#10;            smoothedRotation.current = currentY + normalizedDiff * lerpFactor;&#10;            groupRef.current.rotation.y = smoothedRotation.current;&#10;&#10;            // Reset rotação X&#10;            groupRef.current.rotation.x = THREE.MathUtils.lerp(&#10;                groupRef.current.rotation.x, &#10;                0, &#10;                0.1&#10;            );&#10;&#10;            // Efeitos visuais de colisão&#10;            if (collisionForce &gt; 1.5) {&#10;                const shakeIntensity = Math.min(collisionForce * 0.06, 0.2);&#10;                &#10;                // Shake baseado na direção do impacto&#10;                if (impactDirection) {&#10;                    const shakeX = impactDirection.x * shakeIntensity * (Math.random() * 0.5 + 0.5);&#10;                    const shakeZ = impactDirection.z * shakeIntensity * (Math.random() * 0.5 + 0.5);&#10;                    &#10;                    groupRef.current.position.x += shakeX;&#10;                    groupRef.current.position.z += shakeZ;&#10;                } else {&#10;                    groupRef.current.position.x += (Math.random() - 0.5) * shakeIntensity;&#10;                    groupRef.current.position.z += (Math.random() - 0.5) * shakeIntensity;&#10;                }&#10;                &#10;                // Rotação temporária para simular impacto&#10;                if (collisionForce &gt; 3.0) {&#10;                    const rotationShake = (Math.random() - 0.5) * 0.08;&#10;                    groupRef.current.rotation.z += rotationShake;&#10;                }&#10;            }&#10;        }&#10;&#10;        // Atualiza a posição do nome para seguir a altura do pulo&#10;        if (nameRef.current) {&#10;            nameRef.current.position.set(&#10;                groupRef.current.position.x,&#10;                groupRef.current.position.y + 5, // Nome segue a altura do carro&#10;                groupRef.current.position.z&#10;            );&#10;            nameRef.current.lookAt(camera.position);&#10;        }&#10;    });&#10;&#10;    return (&#10;        &lt;group&gt;&#10;            &lt;group ref={groupRef} position={player.position} castShadow&gt;&#10;                &lt;primitive&#10;                    object={scene.clone()}&#10;                    scale={[3.2, 3.2, 3.2]}&#10;                    rotation={[0, Math.PI / 2, 0]}&#10;                /&gt;&#10;            &lt;/group&gt;&#10;&#10;            &lt;group ref={nameRef}&gt;&#10;                &lt;mesh&gt;&#10;                    &lt;planeGeometry args={[player.name.length * 0.5 + 0.5, 0.8]} /&gt;&#10;                    &lt;meshBasicMaterial color=&quot;#666666&quot; transparent opacity={0.8} /&gt;&#10;                &lt;/mesh&gt;&#10;&#10;                &lt;Text&#10;                    position={[0, 0, 0.01]}&#10;                    fontSize={0.8}&#10;                    color=&quot;#ffffff&quot;&#10;                    anchorX=&quot;center&quot;&#10;                    anchorY=&quot;middle&quot;&#10;                &gt;&#10;                    {player.name}&#10;                &lt;/Text&gt;&#10;            &lt;/group&gt;&#10;        &lt;/group&gt;&#10;    );&#10;}&#10;&#10;for (let i = 1; i &lt;= 4; i++) {&#10;    useGLTF.preload(`/models/car${i}.glb`);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client/src/components/Track.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/components/Track.tsx" />
              <option name="originalContent" value="import React from &quot;react&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type TrackProps = {&#10;    platformSize: number;&#10;};&#10;&#10;export default function Track({ platformSize }: TrackProps) {&#10;    const warningZone = platformSize &lt; 100;&#10;    const criticalZone = platformSize &lt; 50;&#10;    const finalZone = platformSize &lt;= 20;&#10;&#10;    // Se a plataforma for muito pequena (menor que 10), não renderizar mais&#10;    if (platformSize &lt; 5) {&#10;        return null;&#10;    }&#10;&#10;    return (&#10;        &lt;group&gt;&#10;            &lt;mesh position={[0, -1, 0]} receiveShadow&gt;&#10;                &lt;boxGeometry args={[platformSize, 2, platformSize]} /&gt;&#10;                &lt;meshStandardMaterial&#10;                    color={finalZone ? &quot;#ff0000&quot; : criticalZone ? &quot;#ff6666&quot; : warningZone ? &quot;#ffaa66&quot; : &quot;#cccccc&quot;}&#10;                    metalness={0.3}&#10;                    roughness={0.7}&#10;                /&gt;&#10;            &lt;/mesh&gt;&#10;&#10;            &lt;mesh position={[0, 0.01, 0]} receiveShadow&gt;&#10;                &lt;planeGeometry args={[platformSize, platformSize]} /&gt;&#10;                &lt;meshStandardMaterial&#10;                    color={finalZone ? &quot;#ff9999&quot; : criticalZone ? &quot;#ffcccc&quot; : warningZone ? &quot;#fff2cc&quot; : &quot;#ffffff&quot;}&#10;                    metalness={0.1}&#10;                    roughness={0.8}&#10;                /&gt;&#10;            &lt;/mesh&gt;&#10;&#10;            &lt;lineSegments position={[0, 0.02, 0]}&gt;&#10;                &lt;edgesGeometry args={[new THREE.PlaneGeometry(platformSize, platformSize)]} /&gt;&#10;                &lt;lineBasicMaterial&#10;                    color={finalZone ? &quot;#ff0000&quot; : criticalZone ? &quot;#ff0000&quot; : warningZone ? &quot;#ff8800&quot; : &quot;#666666&quot;}&#10;                    linewidth={3}&#10;                /&gt;&#10;            &lt;/lineSegments&gt;&#10;&#10;            {/* Só mostrar linhas de referência se a plataforma for grande o suficiente */}&#10;            {platformSize &gt; 30 &amp;&amp; (&#10;                &lt;group position={[0, 0.1, 0]}&gt;&#10;                    &lt;mesh position={[0, 0, 0]} rotation={[-Math.PI/2, 0, 0]}&gt;&#10;                        &lt;planeGeometry args={[platformSize * 0.1, 2]} /&gt;&#10;                        &lt;meshBasicMaterial color=&quot;#333333&quot; transparent opacity={0.5} /&gt;&#10;                    &lt;/mesh&gt;&#10;                    &lt;mesh position={[0, 0, 0]} rotation={[-Math.PI/2, 0, Math.PI/2]}&gt;&#10;                        &lt;planeGeometry args={[platformSize * 0.1, 2]} /&gt;&#10;                        &lt;meshBasicMaterial color=&quot;#333333&quot; transparent opacity={0.5} /&gt;&#10;                    &lt;/mesh&gt;&#10;&#10;                    {[25, 50, 75, 100].map((radius, index) =&gt; (&#10;                        radius &lt; platformSize/2 &amp;&amp; (&#10;                            &lt;mesh key={index} position={[0, 0, 0]} rotation={[-Math.PI/2, 0, 0]}&gt;&#10;                                &lt;ringGeometry args={[radius - 1, radius + 1, 32]} /&gt;&#10;                                &lt;meshBasicMaterial&#10;                                    color=&quot;#666666&quot;&#10;                                    transparent&#10;                                    opacity={0.3}&#10;                                    side={THREE.DoubleSide}&#10;                                /&gt;&#10;                            &lt;/mesh&gt;&#10;                        )&#10;                    ))}&#10;                &lt;/group&gt;&#10;            )}&#10;&#10;            {/* Efeito de pulsação quando a plataforma está muito pequena */}&#10;            {finalZone &amp;&amp; (&#10;                &lt;mesh position={[0, 0.05, 0]} rotation={[-Math.PI/2, 0, 0]}&gt;&#10;                    &lt;ringGeometry args={[Math.max(platformSize/2 - 2, 1), platformSize/2 + 2, 32]} /&gt;&#10;                    &lt;meshBasicMaterial&#10;                        color=&quot;#ff0000&quot;&#10;                        transparent&#10;                        opacity={Math.sin(Date.now() * 0.02) * 0.5 + 0.5}&#10;                        side={THREE.DoubleSide}&#10;                    /&gt;&#10;                &lt;/mesh&gt;&#10;            )}&#10;        &lt;/group&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="import React from &quot;react&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type TrackProps = {&#10;    platformSize: number;&#10;};&#10;&#10;export default function Track({ platformSize }: TrackProps) {&#10;    const warningZone = platformSize &lt; 100;&#10;    const criticalZone = platformSize &lt; 50;&#10;    const finalZone = platformSize &lt;= 20;&#10;&#10;    // Se a plataforma for muito pequena (menor que 10), não renderizar mais&#10;    if (platformSize &lt; 5) {&#10;        return null;&#10;    }&#10;&#10;    return (&#10;        &lt;group&gt;&#10;            &lt;mesh position={[0, -1, 0]} receiveShadow&gt;&#10;                &lt;boxGeometry args={[platformSize, 2, platformSize]} /&gt;&#10;                &lt;meshStandardMaterial&#10;                    color={finalZone ? &quot;#ff0000&quot; : criticalZone ? &quot;#ff6666&quot; : warningZone ? &quot;#ffaa66&quot; : &quot;#cccccc&quot;}&#10;                    metalness={0.3}&#10;                    roughness={0.7}&#10;                /&gt;&#10;            &lt;/mesh&gt;&#10;&#10;            &lt;mesh position={[0, 0.01, 0]} receiveShadow&gt;&#10;                &lt;planeGeometry args={[platformSize, platformSize]} /&gt;&#10;                &lt;meshStandardMaterial&#10;                    color={finalZone ? &quot;#ff9999&quot; : criticalZone ? &quot;#ffcccc&quot; : warningZone ? &quot;#fff2cc&quot; : &quot;#ffffff&quot;}&#10;                    metalness={0.1}&#10;                    roughness={0.8}&#10;                /&gt;&#10;            &lt;/mesh&gt;&#10;&#10;            &lt;lineSegments position={[0, 0.02, 0]}&gt;&#10;                &lt;edgesGeometry args={[new THREE.PlaneGeometry(platformSize, platformSize)]} /&gt;&#10;                &lt;lineBasicMaterial&#10;                    color={finalZone ? &quot;#ff0000&quot; : criticalZone ? &quot;#ff0000&quot; : warningZone ? &quot;#ff8800&quot; : &quot;#666666&quot;}&#10;                    linewidth={3}&#10;                /&gt;&#10;            &lt;/lineSegments&gt;&#10;&#10;            {/* Só mostrar círculos de referência se a plataforma for grande o suficiente */}&#10;            {platformSize &gt; 30 &amp;&amp; (&#10;                &lt;group position={[0, 0.1, 0]}&gt;&#10;                    {[25, 50, 75, 100].map((radius, index) =&gt; (&#10;                        radius &lt; platformSize/2 &amp;&amp; (&#10;                            &lt;mesh key={index} position={[0, 0, 0]} rotation={[-Math.PI/2, 0, 0]}&gt;&#10;                                &lt;ringGeometry args={[radius - 1, radius + 1, 32]} /&gt;&#10;                                &lt;meshBasicMaterial&#10;                                    color=&quot;#666666&quot;&#10;                                    transparent&#10;                                    opacity={0.3}&#10;                                    side={THREE.DoubleSide}&#10;                                /&gt;&#10;                            &lt;/mesh&gt;&#10;                        )&#10;                    ))}&#10;                &lt;/group&gt;&#10;            )}&#10;&#10;            {/* Efeito de pulsação quando a plataforma está muito pequena */}&#10;            {finalZone &amp;&amp; (&#10;                &lt;mesh position={[0, 0.05, 0]} rotation={[-Math.PI/2, 0, 0]}&gt;&#10;                    &lt;ringGeometry args={[Math.max(platformSize/2 - 2, 1), platformSize/2 + 2, 32]} /&gt;&#10;                    &lt;meshBasicMaterial&#10;                        color=&quot;#ff0000&quot;&#10;                        transparent&#10;                        opacity={Math.sin(Date.now() * 0.02) * 0.5 + 0.5}&#10;                        side={THREE.DoubleSide}&#10;                    /&gt;&#10;                &lt;/mesh&gt;&#10;            )}&#10;        &lt;/group&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client/src/hooks/useWebSocket.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/hooks/useWebSocket.js" />
              <option name="originalContent" value="import { useEffect, useRef, useState } from 'react';&#10;&#10;export function useWebSocket(playerName) {&#10;    const ws = useRef(null);&#10;    const [players, setPlayers] = useState(new Map());&#10;    const [connected, setConnected] = useState(false);&#10;    const [currentPlayerId, setCurrentPlayerId] = useState(null);&#10;    const [playerStats, setPlayerStats] = useState(new Map());&#10;    const [platformSize, setPlatformSize] = useState(200);&#10;    const [isWaitingForRound, setIsWaitingForRound] = useState(true);&#10;    const [waitingCountdown, setWaitingCountdown] = useState(0);&#10;    const [currentRound, setCurrentRound] = useState(0);&#10;    const heartbeatInterval = useRef(null);&#10;&#10;    const savePlayerRecord = (playerName, survivalTime) =&gt; {&#10;        try {&#10;            const records = JSON.parse(localStorage.getItem('playerRecords') || '{}');&#10;            if (!records[playerName] || survivalTime &gt; records[playerName]) {&#10;                records[playerName] = survivalTime;&#10;                localStorage.setItem('playerRecords', JSON.stringify(records));&#10;            }&#10;        } catch (error) {&#10;            console.error('Erro ao salvar recorde:', error);&#10;        }&#10;    };&#10;&#10;    const getPlayerRecord = (playerName) =&gt; {&#10;        try {&#10;            const records = JSON.parse(localStorage.getItem('playerRecords') || '{}');&#10;            return records[playerName] || 0;&#10;        } catch (error) {&#10;            console.error('Erro ao carregar recorde:', error);&#10;            return 0;&#10;        }&#10;    };&#10;&#10;    useEffect(() =&gt; {&#10;        if (!playerName) return;&#10;&#10;        // ws.current = new WebSocket('wss://ioficina.iopoint.com.br/ws/');&#10;        ws.current = new WebSocket('ws://localhost:8888/');&#10;&#10;        heartbeatInterval.current = setInterval(() =&gt; {&#10;            if (ws.current &amp;&amp; ws.current.readyState === WebSocket.OPEN) {&#10;                ws.current.send(JSON.stringify({&#10;                    type: 'HEARTBEAT'&#10;                }));&#10;            }&#10;        }, 5000);&#10;&#10;        ws.current.onopen = () =&gt; {&#10;            setConnected(true);&#10;&#10;            ws.current.send(JSON.stringify({&#10;                type: 'JOIN',&#10;                playerName: playerName,&#10;                roomId: 'default',&#10;                carModel: Math.floor(Math.random() * 4) + 1&#10;            }));&#10;        };&#10;&#10;        ws.current.onmessage = (event) =&gt; {&#10;            const data = JSON.parse(event.data);&#10;&#10;            switch (data.type) {&#10;                case 'JOIN_SUCCESS':&#10;                    setCurrentPlayerId(data.playerId);&#10;                    setPlatformSize(data.platformSize);&#10;                    setIsWaitingForRound(data.isWaitingForRound);&#10;                    setCurrentRound(data.roundNumber);&#10;&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        newMap.set(data.playerId, {&#10;                            id: data.playerId,&#10;                            name: playerName,&#10;                            position: [0, 1, 0],&#10;                            rotation: 0,&#10;                            carModel: Math.floor(Math.random() * 4) + 1,&#10;                            falling: false,&#10;                            isWaitingForRound: data.isWaitingForRound&#10;                        });&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;                        newStats.set(data.playerId, {&#10;                            name: playerName,&#10;                            currentTime: 0,&#10;                            bestTime: getPlayerRecord(playerName),&#10;                            totalRounds: 0&#10;                        });&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'EXISTING_PLAYERS':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        data.players.forEach(player =&gt; {&#10;                            newMap.set(player.id, player);&#10;                        });&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;                        data.players.forEach(player =&gt; {&#10;                            const existingStat = newStats.get(player.id);&#10;                            newStats.set(player.id, {&#10;                                name: player.name,&#10;                                currentTime: player.survivalTime || 0,&#10;                                bestTime: existingStat ? existingStat.bestTime : getPlayerRecord(player.name),&#10;                                totalRounds: existingStat ? existingStat.totalRounds : 0&#10;                            });&#10;                        });&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'WAITING_NEW_ROUND':&#10;                    setIsWaitingForRound(true);&#10;                    setWaitingCountdown(data.countdown);&#10;                    setCurrentRound(data.roundNumber);&#10;                    break;&#10;&#10;                case 'NEW_ROUND_STARTED':&#10;                    setPlatformSize(data.platformSize);&#10;                    setCurrentRound(data.roundNumber);&#10;                    setIsWaitingForRound(false);&#10;                    setWaitingCountdown(0);&#10;&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map();&#10;                        prev.forEach((player, id) =&gt; {&#10;                            newMap.set(id, {&#10;                                ...player,&#10;                                falling: false,&#10;                                position: [0, 1, 0],&#10;                                isWaitingForRound: false&#10;                            });&#10;                        });&#10;                        return newMap;&#10;                    });&#10;&#10;                    // Não limpar os stats, apenas resetar o tempo atual&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map();&#10;                        prev.forEach((stat, id) =&gt; {&#10;                            newStats.set(id, {&#10;                                ...stat,&#10;                                currentTime: 0&#10;                            });&#10;                        });&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'ROUND_ENDED':&#10;                    setIsWaitingForRound(true);&#10;                    break;&#10;&#10;                case 'PLAYER_JOINED':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        newMap.set(data.player.id, data.player);&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;                        newStats.set(data.player.id, {&#10;                            name: data.player.name,&#10;                            currentTime: 0,&#10;                            bestTime: getPlayerRecord(data.player.name),&#10;                            totalRounds: 0&#10;                        });&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'PLAYER_FELL':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        const player = newMap.get(data.playerId);&#10;                        if (player) {&#10;                            newMap.set(data.playerId, {&#10;                                ...player,&#10;                                falling: true,&#10;                                isWaitingForRound: true&#10;                            });&#10;                        }&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;                        const playerStat = newStats.get(data.playerId);&#10;                        if (playerStat) {&#10;                            const survivalTime = data.survivalTime || 0;&#10;                            const newTotalRounds = playerStat.totalRounds + 1;&#10;&#10;                            // Verificar se é um novo recorde&#10;                            const isNewRecord = survivalTime &gt; playerStat.bestTime;&#10;                            const newBestTime = isNewRecord ? survivalTime : playerStat.bestTime;&#10;&#10;                            // Salvar recorde se necessário&#10;                            if (isNewRecord) {&#10;                                savePlayerRecord(playerStat.name, survivalTime);&#10;                            }&#10;&#10;                            newStats.set(data.playerId, {&#10;                                ...playerStat,&#10;                                currentTime: survivalTime,&#10;                                bestTime: newBestTime,&#10;                                totalRounds: newTotalRounds&#10;                            });&#10;                        }&#10;                        return newStats;&#10;                    });&#10;&#10;                    if (data.playerId === currentPlayerId) {&#10;                        setIsWaitingForRound(true);&#10;                    }&#10;                    break;&#10;&#10;                case 'PLATFORM_UPDATE':&#10;                    setPlatformSize(data.platformSize);&#10;                    setCurrentRound(data.roundNumber);&#10;                    break;&#10;&#10;                case 'GAME_RESTART':&#10;                    setPlatformSize(data.platformSize);&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map();&#10;                        prev.forEach((player, id) =&gt; {&#10;                            newMap.set(id, {&#10;                                ...player,&#10;                                falling: false,&#10;                                position: [0, 1, 0]&#10;                            });&#10;                        });&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map();&#10;                        prev.forEach((stat, id) =&gt; {&#10;                            newStats.set(id, {&#10;                                ...stat,&#10;                                survivalTime: 0&#10;                            });&#10;                        });&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'PLAYER_UPDATE':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        const player = newMap.get(data.playerId);&#10;                        if (player) {&#10;                            newMap.set(data.playerId, {&#10;                                ...player,&#10;                                position: data.position,&#10;                                rotation: data.rotation,&#10;                                carModel: data.carModel&#10;                            });&#10;                        }&#10;                        return newMap;&#10;                    });&#10;                    break;&#10;&#10;                case 'PLAYER_RESPAWN':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        const player = newMap.get(data.playerId);&#10;                        if (player) {&#10;                            newMap.set(data.playerId, {&#10;                                ...player,&#10;                                position: data.position,&#10;                                rotation: data.rotation,&#10;                                carModel: data.carModel,&#10;                                falling: false&#10;                            });&#10;                        }&#10;                        return newMap;&#10;                    });&#10;                    break;&#10;&#10;                case 'PLAYER_LEFT':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        newMap.delete(data.playerId);&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;                        newStats.delete(data.playerId);&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'KICKED':&#10;                    window.location.reload();&#10;                    break;&#10;&#10;                case 'PONG':&#10;                    break;&#10;            }&#10;        };&#10;&#10;        ws.current.onclose = () =&gt; {&#10;            setConnected(false);&#10;        };&#10;&#10;        ws.current.onerror = (error) =&gt; {&#10;            console.error('Erro WebSocket:', error);&#10;        };&#10;&#10;        return () =&gt; {&#10;            if (heartbeatInterval.current) {&#10;                clearInterval(heartbeatInterval.current);&#10;            }&#10;            if (ws.current) {&#10;                ws.current.close();&#10;            }&#10;        };&#10;    }, [playerName]);&#10;&#10;    const sendPositionUpdate = (position, rotation, carModel) =&gt; {&#10;        if (ws.current &amp;&amp; ws.current.readyState === WebSocket.OPEN) {&#10;            ws.current.send(JSON.stringify({&#10;                type: 'UPDATE_POSITION',&#10;                position,&#10;                rotation,&#10;                carModel&#10;            }));&#10;        }&#10;    };&#10;&#10;    const sendPlayerFell = () =&gt; {&#10;        if (ws.current &amp;&amp; ws.current.readyState === WebSocket.OPEN) {&#10;            ws.current.send(JSON.stringify({&#10;                type: 'PLAYER_FELL'&#10;            }));&#10;        }&#10;    };&#10;&#10;    const sendPlayerRespawn = (position, rotation, carModel) =&gt; {&#10;        if (ws.current &amp;&amp; ws.current.readyState === WebSocket.OPEN) {&#10;            ws.current.send(JSON.stringify({&#10;                type: 'RESPAWN',&#10;                position,&#10;                rotation,&#10;                carModel&#10;            }));&#10;        }&#10;    };&#10;&#10;    const updateSelfPlayer = (position, rotation, carModel) =&gt; {&#10;        if (currentPlayerId) {&#10;            setPlayers(prev =&gt; {&#10;                const newMap = new Map(prev);&#10;                const player = newMap.get(currentPlayerId);&#10;                if (player) {&#10;                    newMap.set(currentPlayerId, {&#10;                        ...player,&#10;                        position,&#10;                        rotation,&#10;                        carModel&#10;                    });&#10;                }&#10;                return newMap;&#10;            });&#10;        }&#10;    };&#10;&#10;    const incrementSelfFalls = () =&gt; {&#10;        if (currentPlayerId) {&#10;            setPlayerStats(prev =&gt; {&#10;                const newStats = new Map(prev);&#10;                const playerStat = newStats.get(currentPlayerId);&#10;                if (playerStat) {&#10;                    // Remover a lógica de falls já que agora usamos survival time&#10;                    // Esta função pode ser mantida para compatibilidade mas não faz nada&#10;                }&#10;                return newStats;&#10;            });&#10;        }&#10;    };&#10;&#10;    // Modificar o useEffect para parar o tempo quando cair&#10;    useEffect(() =&gt; {&#10;        if (!isWaitingForRound &amp;&amp; currentPlayerId) {&#10;            // Definir tempo de início quando a rodada começar&#10;            const startTime = Date.now();&#10;&#10;            setPlayerStats(prev =&gt; {&#10;                const newStats = new Map(prev);&#10;                const playerStat = newStats.get(currentPlayerId);&#10;                if (playerStat) {&#10;                    newStats.set(currentPlayerId, {&#10;                        ...playerStat,&#10;                        startTime: startTime,&#10;                        currentTime: 0,&#10;                        isFalling: false&#10;                    });&#10;                }&#10;                return newStats;&#10;            });&#10;&#10;            // Iniciar intervalo para atualizar tempo atual e verificar recordes&#10;            const timeInterval = setInterval(() =&gt; {&#10;                if (!isWaitingForRound &amp;&amp; currentPlayerId) {&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;                        const playerStat = newStats.get(currentPlayerId);&#10;                        // Só atualizar o tempo se não estiver caindo&#10;                        if (playerStat &amp;&amp; playerStat.startTime &amp;&amp; !playerStat.isFalling) {&#10;                            const currentTime = Date.now() - playerStat.startTime;&#10;&#10;                            // Verificar se é um novo recorde enquanto joga&#10;                            let newBestTime = playerStat.bestTime;&#10;                            if (currentTime &gt; playerStat.bestTime) {&#10;                                newBestTime = currentTime;&#10;                                // Salvar o novo recorde no localStorage&#10;                                savePlayerRecord(playerStat.name, currentTime);&#10;                            }&#10;&#10;                            newStats.set(currentPlayerId, {&#10;                                ...playerStat,&#10;                                currentTime: currentTime,&#10;                                bestTime: newBestTime&#10;                            });&#10;                        }&#10;                        return newStats;&#10;                    });&#10;                }&#10;            }, 100);&#10;&#10;            return () =&gt; clearInterval(timeInterval);&#10;        } else if (isWaitingForRound &amp;&amp; currentPlayerId) {&#10;            // Quando estiver esperando rodada, resetar o tempo atual para 0&#10;            setPlayerStats(prev =&gt; {&#10;                const newStats = new Map(prev);&#10;                const playerStat = newStats.get(currentPlayerId);&#10;                if (playerStat) {&#10;                    newStats.set(currentPlayerId, {&#10;                        ...playerStat,&#10;                        currentTime: 0,&#10;                        startTime: null,&#10;                        isFalling: false&#10;                    });&#10;                }&#10;                return newStats;&#10;            });&#10;        }&#10;    }, [isWaitingForRound, currentPlayerId]);&#10;&#10;    // Função para parar o tempo quando o jogador começar a cair&#10;    const stopPlayerTime = () =&gt; {&#10;        if (currentPlayerId) {&#10;            setPlayerStats(prev =&gt; {&#10;                const newStats = new Map(prev);&#10;                const playerStat = newStats.get(currentPlayerId);&#10;                if (playerStat &amp;&amp; !playerStat.isFalling) {&#10;                    newStats.set(currentPlayerId, {&#10;                        ...playerStat,&#10;                        isFalling: true&#10;                    });&#10;                }&#10;                return newStats;&#10;            });&#10;        }&#10;    };&#10;&#10;    return {&#10;        players,&#10;        connected,&#10;        currentPlayerId,&#10;        playerStats,&#10;        platformSize,&#10;        isWaitingForRound,&#10;        waitingCountdown,&#10;        currentRound,&#10;        sendPositionUpdate,&#10;        sendPlayerFell,&#10;        sendPlayerRespawn,&#10;        updateSelfPlayer,&#10;        incrementSelfFalls,&#10;        stopPlayerTime&#10;    };&#10;}&#10;" />
              <option name="updatedContent" value="import { useEffect, useRef, useState } from 'react';&#10;&#10;export function useWebSocket(playerName) {&#10;    const ws = useRef(null);&#10;    const [players, setPlayers] = useState(new Map());&#10;    const [connected, setConnected] = useState(false);&#10;    const [currentPlayerId, setCurrentPlayerId] = useState(null);&#10;    const [playerStats, setPlayerStats] = useState(new Map());&#10;    const [platformSize, setPlatformSize] = useState(200);&#10;    const [isWaitingForRound, setIsWaitingForRound] = useState(true);&#10;    const [waitingCountdown, setWaitingCountdown] = useState(0);&#10;    const [currentRound, setCurrentRound] = useState(0);&#10;    const heartbeatInterval = useRef(null);&#10;&#10;    const savePlayerRecord = (playerName, survivalTime) =&gt; {&#10;        try {&#10;            const records = JSON.parse(localStorage.getItem('playerRecords') || '{}');&#10;            if (!records[playerName] || survivalTime &gt; records[playerName]) {&#10;                records[playerName] = survivalTime;&#10;                localStorage.setItem('playerRecords', JSON.stringify(records));&#10;            }&#10;        } catch (error) {&#10;            console.error('Erro ao salvar recorde:', error);&#10;        }&#10;    };&#10;&#10;    const getPlayerRecord = (playerName) =&gt; {&#10;        try {&#10;            const records = JSON.parse(localStorage.getItem('playerRecords') || '{}');&#10;            return records[playerName] || 0;&#10;        } catch (error) {&#10;            console.error('Erro ao carregar recorde:', error);&#10;            return 0;&#10;        }&#10;    };&#10;&#10;    useEffect(() =&gt; {&#10;        if (!playerName) return;&#10;&#10;        // ws.current = new WebSocket('wss://ioficina.iopoint.com.br/ws/');&#10;        ws.current = new WebSocket('ws://localhost:8888/');&#10;&#10;        heartbeatInterval.current = setInterval(() =&gt; {&#10;            if (ws.current &amp;&amp; ws.current.readyState === WebSocket.OPEN) {&#10;                ws.current.send(JSON.stringify({&#10;                    type: 'HEARTBEAT'&#10;                }));&#10;            }&#10;        }, 5000);&#10;&#10;        ws.current.onopen = () =&gt; {&#10;            setConnected(true);&#10;&#10;            ws.current.send(JSON.stringify({&#10;                type: 'JOIN',&#10;                playerName: playerName,&#10;                roomId: 'default',&#10;                carModel: Math.floor(Math.random() * 4) + 1&#10;            }));&#10;        };&#10;&#10;        ws.current.onmessage = (event) =&gt; {&#10;            const data = JSON.parse(event.data);&#10;&#10;            switch (data.type) {&#10;                case 'JOIN_SUCCESS':&#10;                    setCurrentPlayerId(data.playerId);&#10;                    setPlatformSize(data.platformSize);&#10;                    setIsWaitingForRound(data.isWaitingForRound);&#10;                    setCurrentRound(data.roundNumber);&#10;&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        newMap.set(data.playerId, {&#10;                            id: data.playerId,&#10;                            name: playerName,&#10;                            position: [0, 1, 0],&#10;                            rotation: 0,&#10;                            carModel: Math.floor(Math.random() * 4) + 1,&#10;                            falling: false,&#10;                            isWaitingForRound: data.isWaitingForRound&#10;                        });&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;                        newStats.set(data.playerId, {&#10;                            name: playerName,&#10;                            currentTime: 0,&#10;                            bestTime: getPlayerRecord(playerName),&#10;                            totalRounds: 0&#10;                        });&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'EXISTING_PLAYERS':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        data.players.forEach(player =&gt; {&#10;                            newMap.set(player.id, player);&#10;                        });&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;                        data.players.forEach(player =&gt; {&#10;                            const existingStat = newStats.get(player.id);&#10;                            newStats.set(player.id, {&#10;                                name: player.name,&#10;                                currentTime: player.survivalTime || 0,&#10;                                bestTime: existingStat ? existingStat.bestTime : getPlayerRecord(player.name),&#10;                                totalRounds: existingStat ? existingStat.totalRounds : 0&#10;                            });&#10;                        });&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'WAITING_NEW_ROUND':&#10;                    setIsWaitingForRound(true);&#10;                    setWaitingCountdown(data.countdown);&#10;                    setCurrentRound(data.roundNumber);&#10;                    break;&#10;&#10;                case 'NEW_ROUND_STARTED':&#10;                    setPlatformSize(data.platformSize);&#10;                    setCurrentRound(data.roundNumber);&#10;                    setIsWaitingForRound(false);&#10;                    setWaitingCountdown(0);&#10;&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map();&#10;                        prev.forEach((player, id) =&gt; {&#10;                            newMap.set(id, {&#10;                                ...player,&#10;                                falling: false,&#10;                                position: [0, 1, 0],&#10;                                isWaitingForRound: false&#10;                            });&#10;                        });&#10;                        return newMap;&#10;                    });&#10;&#10;                    // Não limpar os stats, apenas resetar o tempo atual&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map();&#10;                        prev.forEach((stat, id) =&gt; {&#10;                            newStats.set(id, {&#10;                                ...stat,&#10;                                currentTime: 0&#10;                            });&#10;                        });&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'ROUND_ENDED':&#10;                    setIsWaitingForRound(true);&#10;                    break;&#10;&#10;                case 'PLAYER_JOINED':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        newMap.set(data.player.id, data.player);&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;                        newStats.set(data.player.id, {&#10;                            name: data.player.name,&#10;                            currentTime: 0,&#10;                            bestTime: getPlayerRecord(data.player.name),&#10;                            totalRounds: 0&#10;                        });&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'PLAYER_FELL':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        const player = newMap.get(data.playerId);&#10;                        if (player) {&#10;                            newMap.set(data.playerId, {&#10;                                ...player,&#10;                                falling: true,&#10;                                isWaitingForRound: true&#10;                            });&#10;                        }&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;                        const playerStat = newStats.get(data.playerId);&#10;                        if (playerStat) {&#10;                            const survivalTime = data.survivalTime || 0;&#10;                            const newTotalRounds = playerStat.totalRounds + 1;&#10;&#10;                            // Verificar se é um novo recorde&#10;                            const isNewRecord = survivalTime &gt; playerStat.bestTime;&#10;                            const newBestTime = isNewRecord ? survivalTime : playerStat.bestTime;&#10;&#10;                            // Salvar recorde se necessário&#10;                            if (isNewRecord) {&#10;                                savePlayerRecord(playerStat.name, survivalTime);&#10;                            }&#10;&#10;                            newStats.set(data.playerId, {&#10;                                ...playerStat,&#10;                                currentTime: survivalTime,&#10;                                bestTime: newBestTime,&#10;                                totalRounds: newTotalRounds&#10;                            });&#10;                        }&#10;                        return newStats;&#10;                    });&#10;&#10;                    if (data.playerId === currentPlayerId) {&#10;                        setIsWaitingForRound(true);&#10;                    }&#10;                    break;&#10;&#10;                case 'PLATFORM_UPDATE':&#10;                    setPlatformSize(data.platformSize);&#10;                    setCurrentRound(data.roundNumber);&#10;                    break;&#10;&#10;                case 'GAME_RESTART':&#10;                    setPlatformSize(data.platformSize);&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map();&#10;                        prev.forEach((player, id) =&gt; {&#10;                            newMap.set(id, {&#10;                                ...player,&#10;                                falling: false,&#10;                                position: [0, 1, 0]&#10;                            });&#10;                        });&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map();&#10;                        prev.forEach((stat, id) =&gt; {&#10;                            newStats.set(id, {&#10;                                ...stat,&#10;                                survivalTime: 0&#10;                            });&#10;                        });&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'PLAYER_UPDATE':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        const player = newMap.get(data.playerId);&#10;                        if (player) {&#10;                            newMap.set(data.playerId, {&#10;                                ...player,&#10;                                position: data.position,&#10;                                rotation: data.rotation,&#10;                                carModel: data.carModel&#10;                            });&#10;                        }&#10;                        return newMap;&#10;                    });&#10;                    break;&#10;&#10;                case 'PLAYER_RESPAWN':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        const player = newMap.get(data.playerId);&#10;                        if (player) {&#10;                            newMap.set(data.playerId, {&#10;                                ...player,&#10;                                position: data.position,&#10;                                rotation: data.rotation,&#10;                                carModel: data.carModel,&#10;                                falling: false&#10;                            });&#10;                        }&#10;                        return newMap;&#10;                    });&#10;                    break;&#10;&#10;                case 'PLAYER_LEFT':&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        newMap.delete(data.playerId);&#10;                        return newMap;&#10;                    });&#10;&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;                        newStats.delete(data.playerId);&#10;                        return newStats;&#10;                    });&#10;                    break;&#10;&#10;                case 'KICKED':&#10;                    window.location.reload();&#10;                    break;&#10;&#10;                case 'PONG':&#10;                    break;&#10;&#10;                case 'COLLISION':&#10;                    // Aplicar resultado da colisão calculada pelo servidor&#10;                    setPlayers(prev =&gt; {&#10;                        const newMap = new Map(prev);&#10;                        &#10;                        const player1 = newMap.get(data.player1Id);&#10;                        const player2 = newMap.get(data.player2Id);&#10;                        &#10;                        if (player1) {&#10;                            newMap.set(data.player1Id, {&#10;                                ...player1,&#10;                                position: data.player1Position,&#10;                                collisionForce: data.force,&#10;                                impactDirection: data.impactDirection,&#10;                                isAttacker: data.attackingPlayer === 1&#10;                            });&#10;                        }&#10;                        &#10;                        if (player2) {&#10;                            newMap.set(data.player2Id, {&#10;                                ...player2,&#10;                                position: data.player2Position,&#10;                                collisionForce: data.force,&#10;                                impactDirection: {&#10;                                    x: -data.impactDirection.x,&#10;                                    z: -data.impactDirection.z&#10;                                },&#10;                                isAttacker: data.attackingPlayer === 2&#10;                            });&#10;                        }&#10;                        &#10;                        return newMap;&#10;                    });&#10;                    &#10;                    // Limpar dados de colisão após um tempo&#10;                    setTimeout(() =&gt; {&#10;                        setPlayers(prev =&gt; {&#10;                            const newMap = new Map(prev);&#10;                            &#10;                            const player1 = newMap.get(data.player1Id);&#10;                            const player2 = newMap.get(data.player2Id);&#10;                            &#10;                            if (player1) {&#10;                                newMap.set(data.player1Id, {&#10;                                    ...player1,&#10;                                    collisionForce: 0,&#10;                                    impactDirection: null,&#10;                                    isAttacker: false&#10;                                });&#10;                            }&#10;                            &#10;                            if (player2) {&#10;                                newMap.set(data.player2Id, {&#10;                                    ...player2,&#10;                                    collisionForce: 0,&#10;                                    impactDirection: null,&#10;                                    isAttacker: false&#10;                                });&#10;                            }&#10;                            &#10;                            return newMap;&#10;                        });&#10;                    }, 250);&#10;                    break;&#10;            }&#10;        };&#10;&#10;        ws.current.onclose = () =&gt; {&#10;            setConnected(false);&#10;        };&#10;&#10;        ws.current.onerror = (error) =&gt; {&#10;            console.error('Erro WebSocket:', error);&#10;        };&#10;&#10;        return () =&gt; {&#10;            if (heartbeatInterval.current) {&#10;                clearInterval(heartbeatInterval.current);&#10;            }&#10;            if (ws.current) {&#10;                ws.current.close();&#10;            }&#10;        };&#10;    }, [playerName]);&#10;&#10;    const sendPositionUpdate = (position, rotation, carModel, physicsData = {}) =&gt; {&#10;        if (ws.current &amp;&amp; ws.current.readyState === WebSocket.OPEN) {&#10;            ws.current.send(JSON.stringify({&#10;                type: 'UPDATE_POSITION',&#10;                position,&#10;                rotation,&#10;                carModel,&#10;                mass: physicsData.mass || 1.0,&#10;                velocity: physicsData.velocity || 0,&#10;                acceleration: physicsData.acceleration || 0&#10;            }));&#10;        }&#10;    };&#10;&#10;    const sendPlayerFell = () =&gt; {&#10;        if (ws.current &amp;&amp; ws.current.readyState === WebSocket.OPEN) {&#10;            ws.current.send(JSON.stringify({&#10;                type: 'PLAYER_FELL'&#10;            }));&#10;        }&#10;    };&#10;&#10;    const sendPlayerRespawn = (position, rotation, carModel) =&gt; {&#10;        if (ws.current &amp;&amp; ws.current.readyState === WebSocket.OPEN) {&#10;            ws.current.send(JSON.stringify({&#10;                type: 'RESPAWN',&#10;                position,&#10;                rotation,&#10;                carModel&#10;            }));&#10;        }&#10;    };&#10;&#10;    const updateSelfPlayer = (position, rotation, carModel) =&gt; {&#10;        if (currentPlayerId) {&#10;            setPlayers(prev =&gt; {&#10;                const newMap = new Map(prev);&#10;                const player = newMap.get(currentPlayerId);&#10;                if (player) {&#10;                    newMap.set(currentPlayerId, {&#10;                        ...player,&#10;                        position,&#10;                        rotation,&#10;                        carModel&#10;                    });&#10;                }&#10;                return newMap;&#10;            });&#10;        }&#10;    };&#10;&#10;    const incrementSelfFalls = () =&gt; {&#10;        if (currentPlayerId) {&#10;            setPlayerStats(prev =&gt; {&#10;                const newStats = new Map(prev);&#10;                const playerStat = newStats.get(currentPlayerId);&#10;                if (playerStat) {&#10;                    // Remover a lógica de falls já que agora usamos survival time&#10;                    // Esta função pode ser mantida para compatibilidade mas não faz nada&#10;                }&#10;                return newStats;&#10;            });&#10;        }&#10;    };&#10;&#10;    // Modificar o useEffect para parar o tempo quando cair&#10;    useEffect(() =&gt; {&#10;        if (!isWaitingForRound &amp;&amp; currentPlayerId) {&#10;            // Definir tempo de início quando a rodada começar&#10;            const startTime = Date.now();&#10;&#10;            setPlayerStats(prev =&gt; {&#10;                const newStats = new Map(prev);&#10;                const playerStat = newStats.get(currentPlayerId);&#10;                if (playerStat) {&#10;                    newStats.set(currentPlayerId, {&#10;                        ...playerStat,&#10;                        startTime: startTime,&#10;                        currentTime: 0,&#10;                        isFalling: false&#10;                    });&#10;                }&#10;                return newStats;&#10;            });&#10;&#10;            // Iniciar intervalo para atualizar tempo atual e verificar recordes&#10;            const timeInterval = setInterval(() =&gt; {&#10;                if (!isWaitingForRound &amp;&amp; currentPlayerId) {&#10;                    setPlayerStats(prev =&gt; {&#10;                        const newStats = new Map(prev);&#10;                        const playerStat = newStats.get(currentPlayerId);&#10;                        // Só atualizar o tempo se não estiver caindo&#10;                        if (playerStat &amp;&amp; playerStat.startTime &amp;&amp; !playerStat.isFalling) {&#10;                            const currentTime = Date.now() - playerStat.startTime;&#10;&#10;                            // Verificar se é um novo recorde enquanto joga&#10;                            let newBestTime = playerStat.bestTime;&#10;                            if (currentTime &gt; playerStat.bestTime) {&#10;                                newBestTime = currentTime;&#10;                                // Salvar o novo recorde no localStorage&#10;                                savePlayerRecord(playerStat.name, currentTime);&#10;                            }&#10;&#10;                            newStats.set(currentPlayerId, {&#10;                                ...playerStat,&#10;                                currentTime: currentTime,&#10;                                bestTime: newBestTime&#10;                            });&#10;                        }&#10;                        return newStats;&#10;                    });&#10;                }&#10;            }, 100);&#10;&#10;            return () =&gt; clearInterval(timeInterval);&#10;        } else if (isWaitingForRound &amp;&amp; currentPlayerId) {&#10;            // Quando estiver esperando rodada, resetar o tempo atual para 0&#10;            setPlayerStats(prev =&gt; {&#10;                const newStats = new Map(prev);&#10;                const playerStat = newStats.get(currentPlayerId);&#10;                if (playerStat) {&#10;                    newStats.set(currentPlayerId, {&#10;                        ...playerStat,&#10;                        currentTime: 0,&#10;                        startTime: null,&#10;                        isFalling: false&#10;                    });&#10;                }&#10;                return newStats;&#10;            });&#10;        }&#10;    }, [isWaitingForRound, currentPlayerId]);&#10;&#10;    // Função para parar o tempo quando o jogador começar a cair&#10;    const stopPlayerTime = () =&gt; {&#10;        if (currentPlayerId) {&#10;            setPlayerStats(prev =&gt; {&#10;                const newStats = new Map(prev);&#10;                const playerStat = newStats.get(currentPlayerId);&#10;                if (playerStat &amp;&amp; !playerStat.isFalling) {&#10;                    newStats.set(currentPlayerId, {&#10;                        ...playerStat,&#10;                        isFalling: true&#10;                    });&#10;                }&#10;                return newStats;&#10;            });&#10;        }&#10;    };&#10;&#10;    return {&#10;        players,&#10;        connected,&#10;        currentPlayerId,&#10;        playerStats,&#10;        platformSize,&#10;        isWaitingForRound,&#10;        waitingCountdown,&#10;        currentRound,&#10;        sendPositionUpdate,&#10;        sendPlayerFell,&#10;        sendPlayerRespawn,&#10;        updateSelfPlayer,&#10;        incrementSelfFalls,&#10;        stopPlayerTime&#10;    };&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/package.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/package.json" />
              <option name="originalContent" value="{&#10;  &quot;name&quot;: &quot;formula-js-server&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;Servidor multiplayer para jogo de Fórmula 1&quot;,&#10;  &quot;main&quot;: &quot;server.js&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;start&quot;: &quot;node server.js&quot;,&#10;    &quot;dev&quot;: &quot;nodemon server.js&quot;&#10;  },&#10;  &quot;dependencies&quot;: {&#10;    &quot;ws&quot;: &quot;^8.14.2&quot;,&#10;    &quot;uuid&quot;: &quot;^9.0.1&quot;&#10;  },&#10;  &quot;devDependencies&quot;: {&#10;    &quot;nodemon&quot;: &quot;^3.0.1&quot;&#10;  }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;name&quot;: &quot;formula-js-server&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;Servidor multiplayer para jogo de Fórmula 1&quot;,&#10;  &quot;main&quot;: &quot;server.js&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;start&quot;: &quot;node server.js&quot;,&#10;    &quot;dev&quot;: &quot;nodemon server.js&quot;&#10;  },&#10;  &quot;dependencies&quot;: {&#10;    &quot;ws&quot;: &quot;^8.14.2&quot;,&#10;    &quot;uuid&quot;: &quot;^9.0.1&quot;&#10;  },&#10;  &quot;devDependencies&quot;: {&#10;    &quot;nodemon&quot;: &quot;^3.0.1&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/server.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/server.js" />
              <option name="originalContent" value="const WebSocket = require('ws');&#10;const { v4: uuidv4 } = require('uuid');&#10;&#10;const wss = new WebSocket.Server({ port: 8888 });&#10;&#10;const players = new Map();&#10;const rooms = new Map();&#10;const gameStates = new Map();&#10;const gameIntervals = new Map(); // Adicionar para controlar intervalos&#10;&#10;&#10;setInterval(() =&gt; {&#10;    const now = Date.now();&#10;    players.forEach((player, playerId) =&gt; {&#10;        if (now - player.lastHeartbeat &gt; 15000) {&#10;&#10;            if (player.ws.readyState === WebSocket.OPEN) {&#10;                player.ws.send(JSON.stringify({ type: 'KICKED' }));&#10;                player.ws.close();&#10;            }&#10;&#10;            handlePlayerDisconnect(playerId);&#10;        }&#10;    });&#10;}, 10000);&#10;&#10;wss.on('connection', (ws) =&gt; {&#10;    const playerId = uuidv4();&#10;&#10;    ws.on('message', (message) =&gt; {&#10;        try {&#10;            const data = JSON.parse(message);&#10;&#10;            switch (data.type) {&#10;                case 'JOIN':&#10;                    handlePlayerJoin(ws, playerId, data);&#10;                    break;&#10;                case 'UPDATE_POSITION':&#10;                    handlePositionUpdate(playerId, data);&#10;                    break;&#10;                case 'PLAYER_FELL':&#10;                    handlePlayerFell(playerId, data);&#10;                    break;&#10;                case 'RESPAWN':&#10;                    handlePlayerRespawn(playerId, data);&#10;                    break;&#10;                case 'HEARTBEAT':&#10;                    handleHeartbeat(playerId, data);&#10;                    break;&#10;                case 'PING':&#10;                    ws.send(JSON.stringify({ type: 'PONG' }));&#10;                    break;&#10;            }&#10;        } catch (error) {&#10;            console.error(`[${new Date().toISOString()}] Erro ao processar mensagem:`, error);&#10;        }&#10;    });&#10;&#10;    ws.on('close', () =&gt; {&#10;        handlePlayerDisconnect(playerId);&#10;    });&#10;&#10;    ws.on('error', (error) =&gt; {&#10;    });&#10;});&#10;&#10;function initializeGameState(roomId) {&#10;&#10;    // Limpar intervalo anterior se existir&#10;    if (gameIntervals.has(roomId)) {&#10;        clearInterval(gameIntervals.get(roomId));&#10;        gameIntervals.delete(roomId);&#10;    }&#10;&#10;    const gameState = {&#10;        platformSize: 200,&#10;        minPlatformSize: 0,&#10;        shrinkRate: 3.33, // 200/60 = 3.33 para chegar a 0 em 60 segundos&#10;        gameStartTime: Date.now(),&#10;        isActive: false, // Começa inativo&#10;        isWaitingToStart: true,&#10;        waitStartTime: Date.now(),&#10;        waitDuration: 5000, // 5 segundos de espera&#10;        roundNumber: 0&#10;    };&#10;&#10;    gameStates.set(roomId, gameState);&#10;    startGameCycle(roomId);&#10;}&#10;&#10;function startGameCycle(roomId) {&#10;&#10;    // Verificar se já existe um intervalo ativo&#10;    if (gameIntervals.has(roomId)) {&#10;        return;&#10;    }&#10;&#10;    const gameInterval = setInterval(() =&gt; {&#10;        const gameState = gameStates.get(roomId);&#10;        const room = rooms.get(roomId);&#10;&#10;        if (!gameState || !room) {&#10;            clearInterval(gameInterval);&#10;            gameIntervals.delete(roomId);&#10;            return;&#10;        }&#10;&#10;        // Se não há jogadores, pausar o ciclo&#10;        if (room.size === 0) {&#10;            return;&#10;        }&#10;&#10;        // Fase de espera antes de iniciar nova rodada&#10;        if (gameState.isWaitingToStart) {&#10;            const waitElapsed = Date.now() - gameState.waitStartTime;&#10;            const remainingWait = Math.max(0, Math.ceil((gameState.waitDuration - waitElapsed) / 1000));&#10;&#10;            // Broadcast do countdown&#10;            broadcastToRoom(roomId, {&#10;                type: 'WAITING_NEW_ROUND',&#10;                countdown: remainingWait,&#10;                roundNumber: gameState.roundNumber + 1&#10;            });&#10;&#10;            if (waitElapsed &gt;= gameState.waitDuration) {&#10;                // Iniciar nova rodada&#10;                startNewRound(roomId);&#10;            }&#10;            return;&#10;        }&#10;&#10;        // Fase ativa - diminuir plataforma&#10;        if (gameState.isActive) {&#10;            const oldSize = gameState.platformSize;&#10;            gameState.platformSize = Math.max(&#10;                gameState.minPlatformSize,&#10;                gameState.platformSize - gameState.shrinkRate&#10;            );&#10;&#10;&#10;            broadcastToRoom(roomId, {&#10;                type: 'PLATFORM_UPDATE',&#10;                platformSize: gameState.platformSize,&#10;                roundNumber: gameState.roundNumber&#10;            });&#10;&#10;            // Quando a plataforma chegar a 0&#10;            if (gameState.platformSize &lt;= 0) {&#10;                endCurrentRound(roomId);&#10;            }&#10;        }&#10;    }, 1000);&#10;&#10;    // Armazenar o intervalo&#10;    gameIntervals.set(roomId, gameInterval);&#10;}&#10;&#10;function startNewRound(roomId) {&#10;    const gameState = gameStates.get(roomId);&#10;    const room = rooms.get(roomId);&#10;&#10;    if (!gameState || !room) return;&#10;&#10;&#10;    // Resetar estado do jogo&#10;    gameState.platformSize = 200;&#10;    gameState.isActive = true;&#10;    gameState.isWaitingToStart = false;&#10;    gameState.gameStartTime = Date.now();&#10;    gameState.roundNumber += 1;&#10;&#10;    // Resetar todos os jogadores&#10;    room.forEach(playerId =&gt; {&#10;        const player = players.get(playerId);&#10;        if (player) {&#10;            const randomX = (Math.random() - 0.5) * 120;&#10;            const randomZ = (Math.random() - 0.5) * 120;&#10;            const randomAngle = Math.random() * Math.PI * 2;&#10;&#10;            player.position = [randomX, 1, randomZ];&#10;            player.rotation = randomAngle;&#10;            player.falling = false;&#10;            player.survivalTime = 0;&#10;            player.joinTime = Date.now();&#10;            player.isWaitingForRound = false;&#10;        }&#10;    });&#10;&#10;    // Notificar todos os jogadores&#10;    broadcastToRoom(roomId, {&#10;        type: 'NEW_ROUND_STARTED',&#10;        platformSize: 200,&#10;        roundNumber: gameState.roundNumber&#10;    });&#10;}&#10;&#10;function endCurrentRound(roomId) {&#10;    const gameState = gameStates.get(roomId);&#10;    const room = rooms.get(roomId);&#10;&#10;    if (!gameState || !room) return;&#10;&#10;&#10;    // Marcar todos os jogadores vivos como caídos&#10;    room.forEach(playerId =&gt; {&#10;        const player = players.get(playerId);&#10;        if (player &amp;&amp; !player.falling) {&#10;            player.falling = true;&#10;            player.survivalTime = Date.now() - gameState.gameStartTime;&#10;            player.isWaitingForRound = true;&#10;&#10;            broadcastToRoom(roomId, {&#10;                type: 'PLAYER_FELL',&#10;                playerId: playerId,&#10;                survivalTime: player.survivalTime&#10;            });&#10;        }&#10;    });&#10;&#10;    // Preparar para próxima rodada&#10;    gameState.isActive = false;&#10;    gameState.isWaitingToStart = true;&#10;    gameState.waitStartTime = Date.now();&#10;&#10;    broadcastToRoom(roomId, {&#10;        type: 'ROUND_ENDED',&#10;        roundNumber: gameState.roundNumber&#10;    });&#10;}&#10;&#10;function handlePlayerJoin(ws, playerId, data) {&#10;    const roomId = data.roomId || 'default';&#10;&#10;    if (!rooms.has(roomId)) {&#10;        rooms.set(roomId, new Set());&#10;        initializeGameState(roomId);&#10;    }&#10;&#10;    const gameState = gameStates.get(roomId);&#10;    const isWaitingForRound = gameState.isWaitingToStart || !gameState.isActive;&#10;&#10;    const player = {&#10;        id: playerId,&#10;        name: data.playerName,&#10;        ws: ws,&#10;        roomId: roomId,&#10;        position: [0, 1, 0],&#10;        rotation: 0,&#10;        carModel: String(data.carModel),&#10;        falling: false,&#10;        survivalTime: 0,&#10;        joinTime: Date.now(),&#10;        lastHeartbeat: Date.now(),&#10;        inactive: false,&#10;        inactiveTime: null,&#10;        isWaitingForRound: isWaitingForRound&#10;    };&#10;&#10;    players.set(playerId, player);&#10;    rooms.get(roomId).add(playerId);&#10;&#10;    ws.send(JSON.stringify({&#10;        type: 'JOIN_SUCCESS',&#10;        playerId: playerId,&#10;        platformSize: gameState ? gameState.platformSize : 200,&#10;        isWaitingForRound: isWaitingForRound,&#10;        roundNumber: gameState ? gameState.roundNumber : 0&#10;    }));&#10;&#10;    const existingPlayers = Array.from(rooms.get(roomId))&#10;        .filter(id =&gt; id !== playerId)&#10;        .map(id =&gt; {&#10;            const p = players.get(id);&#10;            const currentSurvivalTime = p.falling ? p.survivalTime : (Date.now() - p.joinTime);&#10;            return {&#10;                id: p.id,&#10;                name: p.name,&#10;                position: p.position,&#10;                rotation: p.rotation,&#10;                carModel: String(p.carModel),&#10;                falling: p.falling,&#10;                survivalTime: currentSurvivalTime,&#10;                isWaitingForRound: p.isWaitingForRound&#10;            };&#10;        });&#10;&#10;    ws.send(JSON.stringify({&#10;        type: 'EXISTING_PLAYERS',&#10;        players: existingPlayers&#10;    }));&#10;&#10;    broadcastToRoom(roomId, {&#10;        type: 'PLAYER_JOINED',&#10;        player: {&#10;            id: playerId,&#10;            name: player.name,&#10;            position: player.position,&#10;            rotation: player.rotation,&#10;            carModel: String(player.carModel),&#10;            falling: player.falling,&#10;            survivalTime: 0,&#10;            isWaitingForRound: isWaitingForRound&#10;        }&#10;    }, playerId);&#10;}&#10;&#10;function handlePositionUpdate(playerId, data) {&#10;    const player = players.get(playerId);&#10;    if (!player || player.isWaitingForRound) return; // Não atualizar se estiver esperando&#10;&#10;    player.position = data.position;&#10;    player.rotation = data.rotation;&#10;    player.carModel = String(data.carModel);&#10;&#10;    broadcastToRoom(player.roomId, {&#10;        type: 'PLAYER_UPDATE',&#10;        playerId: playerId,&#10;        position: data.position,&#10;        rotation: data.rotation,&#10;        carModel: String(data.carModel)&#10;    }, playerId);&#10;}&#10;&#10;function handlePlayerFell(playerId, data) {&#10;    const player = players.get(playerId);&#10;    if (!player || player.falling) return;&#10;&#10;    player.falling = true;&#10;    player.survivalTime = Date.now() - player.joinTime;&#10;    player.isWaitingForRound = true; // Esperar próxima rodada&#10;&#10;    broadcastToRoom(player.roomId, {&#10;        type: 'PLAYER_FELL',&#10;        playerId: playerId,&#10;        survivalTime: player.survivalTime&#10;    }, playerId);&#10;&#10;    // Verificar se todos caíram&#10;    checkGameEnd(player.roomId);&#10;}&#10;&#10;function checkGameEnd(roomId) {&#10;    const room = rooms.get(roomId);&#10;    if (!room) return;&#10;&#10;    const alivePlayers = Array.from(room).filter(playerId =&gt; {&#10;        const player = players.get(playerId);&#10;        return player &amp;&amp; !player.falling;&#10;    });&#10;&#10;    if (alivePlayers.length === 0) {&#10;        // Todos caíram, preparar para próxima rodada&#10;        const gameState = gameStates.get(roomId);&#10;        if (gameState) {&#10;            gameState.isActive = false;&#10;            gameState.isWaitingToStart = true;&#10;            gameState.waitStartTime = Date.now();&#10;&#10;            broadcastToRoom(roomId, {&#10;                type: 'ROUND_ENDED',&#10;                roundNumber: gameState.roundNumber&#10;            });&#10;        }&#10;    }&#10;}&#10;&#10;function restartGame(roomId) {&#10;    // Esta função não é mais necessária, pois o ciclo do jogo gerencia tudo&#10;    // Remover ou deixar vazia para compatibilidade&#10;    console.log(`[${new Date().toISOString()}] restartGame chamado para sala: ${roomId} - gerenciado pelo ciclo`);&#10;}&#10;&#10;function handlePlayerRespawn(playerId, data) {&#10;    const player = players.get(playerId);&#10;    if (!player) return;&#10;&#10;    player.position = data.position;&#10;    player.rotation = data.rotation;&#10;    player.carModel = String(data.carModel);&#10;    player.falling = false;&#10;&#10;    broadcastToRoom(player.roomId, {&#10;        type: 'PLAYER_RESPAWN',&#10;        playerId: playerId,&#10;        position: data.position,&#10;        rotation: data.rotation,&#10;        carModel: String(data.carModel)&#10;    }, playerId);&#10;}&#10;&#10;function handlePlayerDisconnect(playerId) {&#10;    const player = players.get(playerId);&#10;    if (!player) return;&#10;&#10;    if (rooms.has(player.roomId)) {&#10;        rooms.get(player.roomId).delete(playerId);&#10;        if (rooms.get(player.roomId).size === 0) {&#10;            // Limpar intervalo quando sala fica vazia&#10;            if (gameIntervals.has(player.roomId)) {&#10;                clearInterval(gameIntervals.get(player.roomId));&#10;                gameIntervals.delete(player.roomId);&#10;            }&#10;            rooms.delete(player.roomId);&#10;            gameStates.delete(player.roomId);&#10;        }&#10;    }&#10;&#10;    broadcastToRoom(player.roomId, {&#10;        type: 'PLAYER_LEFT',&#10;        playerId: playerId&#10;    });&#10;&#10;    players.delete(playerId);&#10;}&#10;&#10;function handleHeartbeat(playerId, data) {&#10;    const player = players.get(playerId);&#10;    if (!player) return;&#10;&#10;    player.lastHeartbeat = Date.now();&#10;    player.ws.send(JSON.stringify({ type: 'PONG' }));&#10;}&#10;&#10;function broadcastToRoom(roomId, message, excludePlayerId = null) {&#10;    if (!rooms.has(roomId)) return;&#10;&#10;    const room = rooms.get(roomId);&#10;    room.forEach(playerId =&gt; {&#10;        if (playerId === excludePlayerId) return;&#10;&#10;        const player = players.get(playerId);&#10;        if (player &amp;&amp; player.ws.readyState === WebSocket.OPEN) {&#10;            player.ws.send(JSON.stringify(message));&#10;        }&#10;    });&#10;}&#10;" />
              <option name="updatedContent" value="const WebSocket = require('ws');&#10;const { v4: uuidv4 } = require('uuid');&#10;&#10;const wss = new WebSocket.Server({ port: 8888 });&#10;&#10;const players = new Map();&#10;const rooms = new Map();&#10;const gameStates = new Map();&#10;const gameIntervals = new Map(); // Adicionar para controlar intervalos&#10;&#10;&#10;setInterval(() =&gt; {&#10;    const now = Date.now();&#10;    players.forEach((player, playerId) =&gt; {&#10;        if (now - player.lastHeartbeat &gt; 15000) {&#10;&#10;            if (player.ws.readyState === WebSocket.OPEN) {&#10;                player.ws.send(JSON.stringify({ type: 'KICKED' }));&#10;                player.ws.close();&#10;            }&#10;&#10;            handlePlayerDisconnect(playerId);&#10;        }&#10;    });&#10;}, 10000);&#10;&#10;wss.on('connection', (ws) =&gt; {&#10;    const playerId = uuidv4();&#10;&#10;    ws.on('message', (message) =&gt; {&#10;        try {&#10;            const data = JSON.parse(message);&#10;&#10;            switch (data.type) {&#10;                case 'JOIN':&#10;                    handlePlayerJoin(ws, playerId, data);&#10;                    break;&#10;                case 'UPDATE_POSITION':&#10;                    handlePositionUpdate(playerId, data);&#10;                    break;&#10;                case 'PLAYER_FELL':&#10;                    handlePlayerFell(playerId, data);&#10;                    break;&#10;                case 'RESPAWN':&#10;                    handlePlayerRespawn(playerId, data);&#10;                    break;&#10;                case 'HEARTBEAT':&#10;                    handleHeartbeat(playerId, data);&#10;                    break;&#10;                case 'PING':&#10;                    ws.send(JSON.stringify({ type: 'PONG' }));&#10;                    break;&#10;            }&#10;        } catch (error) {&#10;            console.error(`[${new Date().toISOString()}] Erro ao processar mensagem:`, error);&#10;        }&#10;    });&#10;&#10;    ws.on('close', () =&gt; {&#10;        handlePlayerDisconnect(playerId);&#10;    });&#10;&#10;    ws.on('error', (error) =&gt; {&#10;    });&#10;});&#10;&#10;function initializeGameState(roomId) {&#10;&#10;    // Limpar intervalo anterior se existir&#10;    if (gameIntervals.has(roomId)) {&#10;        clearInterval(gameIntervals.get(roomId));&#10;        gameIntervals.delete(roomId);&#10;    }&#10;&#10;    const gameState = {&#10;        platformSize: 200,&#10;        minPlatformSize: 0,&#10;        shrinkRate: 3.33, // 200/60 = 3.33 para chegar a 0 em 60 segundos&#10;        gameStartTime: Date.now(),&#10;        isActive: false, // Começa inativo&#10;        isWaitingToStart: true,&#10;        waitStartTime: Date.now(),&#10;        waitDuration: 5000, // 5 segundos de espera&#10;        roundNumber: 0&#10;    };&#10;&#10;    gameStates.set(roomId, gameState);&#10;    startGameCycle(roomId);&#10;}&#10;&#10;function startGameCycle(roomId) {&#10;&#10;    // Verificar se já existe um intervalo ativo&#10;    if (gameIntervals.has(roomId)) {&#10;        return;&#10;    }&#10;&#10;    const gameInterval = setInterval(() =&gt; {&#10;        const gameState = gameStates.get(roomId);&#10;        const room = rooms.get(roomId);&#10;&#10;        if (!gameState || !room) {&#10;            clearInterval(gameInterval);&#10;            gameIntervals.delete(roomId);&#10;            return;&#10;        }&#10;&#10;        // Se não há jogadores, pausar o ciclo&#10;        if (room.size === 0) {&#10;            return;&#10;        }&#10;&#10;        // Fase de espera antes de iniciar nova rodada&#10;        if (gameState.isWaitingToStart) {&#10;            const waitElapsed = Date.now() - gameState.waitStartTime;&#10;            const remainingWait = Math.max(0, Math.ceil((gameState.waitDuration - waitElapsed) / 1000));&#10;&#10;            // Broadcast do countdown&#10;            broadcastToRoom(roomId, {&#10;                type: 'WAITING_NEW_ROUND',&#10;                countdown: remainingWait,&#10;                roundNumber: gameState.roundNumber + 1&#10;            });&#10;&#10;            if (waitElapsed &gt;= gameState.waitDuration) {&#10;                // Iniciar nova rodada&#10;                startNewRound(roomId);&#10;            }&#10;            return;&#10;        }&#10;&#10;        // Fase ativa - diminuir plataforma&#10;        if (gameState.isActive) {&#10;            const oldSize = gameState.platformSize;&#10;            gameState.platformSize = Math.max(&#10;                gameState.minPlatformSize,&#10;                gameState.platformSize - gameState.shrinkRate&#10;            );&#10;&#10;&#10;            broadcastToRoom(roomId, {&#10;                type: 'PLATFORM_UPDATE',&#10;                platformSize: gameState.platformSize,&#10;                roundNumber: gameState.roundNumber&#10;            });&#10;&#10;            // Quando a plataforma chegar a 0&#10;            if (gameState.platformSize &lt;= 0) {&#10;                endCurrentRound(roomId);&#10;            }&#10;        }&#10;    }, 1000);&#10;&#10;    // Armazenar o intervalo&#10;    gameIntervals.set(roomId, gameInterval);&#10;}&#10;&#10;function startNewRound(roomId) {&#10;    const gameState = gameStates.get(roomId);&#10;    const room = rooms.get(roomId);&#10;&#10;    if (!gameState || !room) return;&#10;&#10;&#10;    // Resetar estado do jogo&#10;    gameState.platformSize = 200;&#10;    gameState.isActive = true;&#10;    gameState.isWaitingToStart = false;&#10;    gameState.gameStartTime = Date.now();&#10;    gameState.roundNumber += 1;&#10;&#10;    // Resetar todos os jogadores&#10;    room.forEach(playerId =&gt; {&#10;        const player = players.get(playerId);&#10;        if (player) {&#10;            const randomX = (Math.random() - 0.5) * 120;&#10;            const randomZ = (Math.random() - 0.5) * 120;&#10;            const randomAngle = Math.random() * Math.PI * 2;&#10;&#10;            player.position = [randomX, 1, randomZ];&#10;            player.rotation = randomAngle;&#10;            player.falling = false;&#10;            player.survivalTime = 0;&#10;            player.joinTime = Date.now();&#10;            player.isWaitingForRound = false;&#10;        }&#10;    });&#10;&#10;    // Notificar todos os jogadores&#10;    broadcastToRoom(roomId, {&#10;        type: 'NEW_ROUND_STARTED',&#10;        platformSize: 200,&#10;        roundNumber: gameState.roundNumber&#10;    });&#10;}&#10;&#10;function endCurrentRound(roomId) {&#10;    const gameState = gameStates.get(roomId);&#10;    const room = rooms.get(roomId);&#10;&#10;    if (!gameState || !room) return;&#10;&#10;&#10;    // Marcar todos os jogadores vivos como caídos&#10;    room.forEach(playerId =&gt; {&#10;        const player = players.get(playerId);&#10;        if (player &amp;&amp; !player.falling) {&#10;            player.falling = true;&#10;            player.survivalTime = Date.now() - gameState.gameStartTime;&#10;            player.isWaitingForRound = true;&#10;&#10;            broadcastToRoom(roomId, {&#10;                type: 'PLAYER_FELL',&#10;                playerId: playerId,&#10;                survivalTime: player.survivalTime&#10;            });&#10;        }&#10;    });&#10;&#10;    // Preparar para próxima rodada&#10;    gameState.isActive = false;&#10;    gameState.isWaitingToStart = true;&#10;    gameState.waitStartTime = Date.now();&#10;&#10;    broadcastToRoom(roomId, {&#10;        type: 'ROUND_ENDED',&#10;        roundNumber: gameState.roundNumber&#10;    });&#10;}&#10;&#10;function handlePlayerJoin(ws, playerId, data) {&#10;    const roomId = data.roomId || 'default';&#10;&#10;    if (!rooms.has(roomId)) {&#10;        rooms.set(roomId, new Set());&#10;        initializeGameState(roomId);&#10;    }&#10;&#10;    const gameState = gameStates.get(roomId);&#10;    const isWaitingForRound = gameState.isWaitingToStart || !gameState.isActive;&#10;&#10;    const player = {&#10;        id: playerId,&#10;        name: data.playerName,&#10;        ws: ws,&#10;        roomId: roomId,&#10;        position: [0, 1, 0],&#10;        rotation: 0,&#10;        carModel: String(data.carModel),&#10;        falling: false,&#10;        survivalTime: 0,&#10;        joinTime: Date.now(),&#10;        lastHeartbeat: Date.now(),&#10;        inactive: false,&#10;        inactiveTime: null,&#10;        isWaitingForRound: isWaitingForRound&#10;    };&#10;&#10;    players.set(playerId, player);&#10;    rooms.get(roomId).add(playerId);&#10;&#10;    ws.send(JSON.stringify({&#10;        type: 'JOIN_SUCCESS',&#10;        playerId: playerId,&#10;        platformSize: gameState ? gameState.platformSize : 200,&#10;        isWaitingForRound: isWaitingForRound,&#10;        roundNumber: gameState ? gameState.roundNumber : 0&#10;    }));&#10;&#10;    const existingPlayers = Array.from(rooms.get(roomId))&#10;        .filter(id =&gt; id !== playerId)&#10;        .map(id =&gt; {&#10;            const p = players.get(id);&#10;            const currentSurvivalTime = p.falling ? p.survivalTime : (Date.now() - p.joinTime);&#10;            return {&#10;                id: p.id,&#10;                name: p.name,&#10;                position: p.position,&#10;                rotation: p.rotation,&#10;                carModel: String(p.carModel),&#10;                falling: p.falling,&#10;                survivalTime: currentSurvivalTime,&#10;                isWaitingForRound: p.isWaitingForRound&#10;            };&#10;        });&#10;&#10;    ws.send(JSON.stringify({&#10;        type: 'EXISTING_PLAYERS',&#10;        players: existingPlayers&#10;    }));&#10;&#10;    broadcastToRoom(roomId, {&#10;        type: 'PLAYER_JOINED',&#10;        player: {&#10;            id: playerId,&#10;            name: player.name,&#10;            position: player.position,&#10;            rotation: player.rotation,&#10;            carModel: String(player.carModel),&#10;            falling: player.falling,&#10;            survivalTime: 0,&#10;            isWaitingForRound: isWaitingForRound&#10;        }&#10;    }, playerId);&#10;}&#10;&#10;function handlePositionUpdate(playerId, data) {&#10;    const player = players.get(playerId);&#10;    if (!player || player.isWaitingForRound) return;&#10;&#10;    // Validar posição antes de aplicar&#10;    if (!Array.isArray(data.position) || data.position.length !== 3) return;&#10;    if (isNaN(data.position[0]) || isNaN(data.position[1]) || isNaN(data.position[2])) return;&#10;&#10;    const oldPosition = player.position || [0, 0, 0];&#10;    const newPosition = data.position;&#10;    &#10;    // Calcular velocidade baseada na mudança de posição&#10;    const deltaX = newPosition[0] - oldPosition[0];&#10;    const deltaZ = newPosition[2] - oldPosition[2];&#10;    const velocity = Math.sqrt(deltaX * deltaX + deltaZ * deltaZ);&#10;    &#10;    // Limitar mudanças muito bruscas de posição&#10;    const maxMovement = 3.0;&#10;    if (velocity &gt; maxMovement) {&#10;        return;&#10;    }&#10;&#10;    player.position = data.position;&#10;    player.rotation = data.rotation;&#10;    player.carModel = String(data.carModel);&#10;    player.velocity = Math.min(velocity, 2.0);&#10;    player.mass = Math.max(0.8, Math.min(2.5, data.mass || 1.0));&#10;    player.lastUpdate = Date.now();&#10;&#10;    // Verificar colisões com throttling&#10;    if (!player.lastCollisionCheck || Date.now() - player.lastCollisionCheck &gt; 80) {&#10;        checkPlayerCollisions(playerId, player);&#10;        player.lastCollisionCheck = Date.now();&#10;    }&#10;&#10;    broadcastToRoom(player.roomId, {&#10;        type: 'PLAYER_UPDATE',&#10;        playerId: playerId,&#10;        position: data.position,&#10;        rotation: data.rotation,&#10;        carModel: String(data.carModel),&#10;        velocity: player.velocity&#10;    }, playerId);&#10;}&#10;&#10;function checkPlayerCollisions(playerId, player) {&#10;    const room = rooms.get(player.roomId);&#10;    if (!room) return;&#10;&#10;    const collisionRadius = 4.5;&#10;    const playerPos = player.position;&#10;&#10;    room.forEach(otherPlayerId =&gt; {&#10;        if (otherPlayerId === playerId) return;&#10;        &#10;        const otherPlayer = players.get(otherPlayerId);&#10;        if (!otherPlayer || otherPlayer.falling || otherPlayer.isWaitingForRound) return;&#10;&#10;        const otherPos = otherPlayer.position;&#10;        &#10;        // Verificação rápida de distância&#10;        const roughDistance = Math.abs(playerPos[0] - otherPos[0]) + Math.abs(playerPos[2] - otherPos[2]);&#10;        if (roughDistance &gt; collisionRadius * 1.5) return;&#10;        &#10;        const distance = Math.sqrt(&#10;            Math.pow(playerPos[0] - otherPos[0], 2) + &#10;            Math.pow(playerPos[2] - otherPos[2], 2)&#10;        );&#10;&#10;        if (distance &lt; collisionRadius &amp;&amp; distance &gt; 0.1) {&#10;            handleServerCollision(playerId, player, otherPlayerId, otherPlayer, distance);&#10;        }&#10;    });&#10;}&#10;&#10;function handleServerCollision(playerId1, player1, playerId2, player2, distance) {&#10;    const collisionRadius = 4.5;&#10;    const separationDistance = collisionRadius - distance;&#10;    &#10;    if (separationDistance &lt;= 0) return;&#10;&#10;    // Cooldown entre colisões&#10;    const now = Date.now();&#10;    const cooldown = 100;&#10;    &#10;    if (player1.lastCollision &amp;&amp; now - player1.lastCollision &lt; cooldown) return;&#10;    if (player2.lastCollision &amp;&amp; now - player2.lastCollision &lt; cooldown) return;&#10;    &#10;    player1.lastCollision = now;&#10;    player2.lastCollision = now;&#10;&#10;    // Calcular direção da colisão (vetor de player2 para player1)&#10;    const dx = player1.position[0] - player2.position[0];&#10;    const dz = player1.position[2] - player2.position[2];&#10;    const length = Math.sqrt(dx * dx + dz * dz);&#10;    &#10;    if (length &lt; 0.1) return;&#10;&#10;    const normalX = dx / length;&#10;    const normalZ = dz / length;&#10;&#10;    // Calcular velocidades e determinar quem está se movendo mais rápido&#10;    const velocity1 = player1.velocity || 0;&#10;    const velocity2 = player2.velocity || 0;&#10;    &#10;    // Determinar direção de movimento de cada jogador&#10;    const player1Direction = {&#10;        x: Math.sin(player1.rotation),&#10;        z: Math.cos(player1.rotation)&#10;    };&#10;    &#10;    const player2Direction = {&#10;        x: Math.sin(player2.rotation), &#10;        z: Math.cos(player2.rotation)&#10;    };&#10;    &#10;    // Calcular velocidade relativa na direção da colisão&#10;    const relativeVelocity1 = velocity1 * (player1Direction.x * normalX + player1Direction.z * normalZ);&#10;    const relativeVelocity2 = velocity2 * (player2Direction.x * (-normalX) + player2Direction.z * (-normalZ));&#10;    &#10;    // Determinar quem está &quot;atacando&quot; (se movendo em direção ao outro)&#10;    const player1Attacking = relativeVelocity1 &gt; 0;&#10;    const player2Attacking = relativeVelocity2 &gt; 0;&#10;    &#10;    // Calcular força baseada na velocidade e direção&#10;    let forceMultiplier = 1.0;&#10;    &#10;    if (player1Attacking &amp;&amp; !player2Attacking) {&#10;        // Player1 está atacando player2&#10;        forceMultiplier = 1.5 + velocity1 * 2.0;&#10;    } else if (player2Attacking &amp;&amp; !player1Attacking) {&#10;        // Player2 está atacando player1&#10;        forceMultiplier = 1.5 + velocity2 * 2.0;&#10;    } else if (player1Attacking &amp;&amp; player2Attacking) {&#10;        // Colisão frontal&#10;        forceMultiplier = 2.0 + (velocity1 + velocity2) * 1.5;&#10;    } else {&#10;        // Nenhum está atacando (colisão lateral/traseira)&#10;        forceMultiplier = 0.8 + Math.max(velocity1, velocity2) * 1.0;&#10;    }&#10;    &#10;    forceMultiplier = Math.min(forceMultiplier, 8.0); // Limitar força máxima&#10;    &#10;    // Aplicar separação baseada na força&#10;    const baseForce = separationDistance * 1.2;&#10;    &#10;    // Quem está atacando recebe menos força, quem está sendo atacado recebe mais&#10;    let force1, force2;&#10;    &#10;    if (player1Attacking &amp;&amp; !player2Attacking) {&#10;        force1 = baseForce * 0.3; // Atacante recebe pouca força&#10;        force2 = baseForce * forceMultiplier; // Defendente recebe muita força&#10;    } else if (player2Attacking &amp;&amp; !player1Attacking) {&#10;        force1 = baseForce * forceMultiplier;&#10;        force2 = baseForce * 0.3;&#10;    } else {&#10;        // Colisão equilibrada - dividir força baseada nas massas&#10;        const mass1 = player1.mass || 1.0;&#10;        const mass2 = player2.mass || 1.0;&#10;        const totalMass = mass1 + mass2;&#10;        &#10;        force1 = baseForce * (mass2 / totalMass) * forceMultiplier;&#10;        force2 = baseForce * (mass1 / totalMass) * forceMultiplier;&#10;    }&#10;    &#10;    // Aplicar forças (empurrar para lados opostos)&#10;    const newPos1 = [&#10;        player1.position[0] + normalX * force1,&#10;        player1.position[1],&#10;        player1.position[2] + normalZ * force1&#10;    ];&#10;    &#10;    const newPos2 = [&#10;        player2.position[0] - normalX * force2,&#10;        player2.position[1], &#10;        player2.position[2] - normalZ * force2&#10;    ];&#10;&#10;    // Verificar limites da plataforma&#10;    const gameState = gameStates.get(player1.roomId);&#10;    const platformRadius = gameState ? gameState.platformSize / 2 : 100;&#10;    &#10;    const dist1 = Math.sqrt(newPos1[0] * newPos1[0] + newPos1[2] * newPos1[2]);&#10;    const dist2 = Math.sqrt(newPos2[0] * newPos2[0] + newPos2[2] * newPos2[2]);&#10;    &#10;    // Aplicar novas posições (permitir sair da plataforma se a força for alta)&#10;    if (dist1 &lt;= platformRadius || forceMultiplier &gt; 4.0) {&#10;        player1.position = newPos1;&#10;    }&#10;    &#10;    if (dist2 &lt;= platformRadius || forceMultiplier &gt; 4.0) {&#10;        player2.position = newPos2;&#10;    }&#10;&#10;    // Broadcast da colisão&#10;    broadcastToRoom(player1.roomId, {&#10;        type: 'COLLISION',&#10;        player1Id: playerId1,&#10;        player2Id: playerId2,&#10;        player1Position: player1.position,&#10;        player2Position: player2.position,&#10;        force: forceMultiplier,&#10;        impactDirection: {&#10;            x: normalX,&#10;            z: normalZ&#10;        },&#10;        attackingPlayer: player1Attacking ? 1 : (player2Attacking ? 2 : 0)&#10;    });&#10;}&#10;&#10;function handlePlayerFell(playerId, data) {&#10;    const player = players.get(playerId);&#10;    if (!player || player.falling) return;&#10;&#10;    player.falling = true;&#10;    player.survivalTime = Date.now() - player.joinTime;&#10;    player.isWaitingForRound = true; // Esperar próxima rodada&#10;&#10;    broadcastToRoom(player.roomId, {&#10;        type: 'PLAYER_FELL',&#10;        playerId: playerId,&#10;        survivalTime: player.survivalTime&#10;    }, playerId);&#10;&#10;    // Verificar se todos caíram&#10;    checkGameEnd(player.roomId);&#10;}&#10;&#10;function checkGameEnd(roomId) {&#10;    const room = rooms.get(roomId);&#10;    if (!room) return;&#10;&#10;    const alivePlayers = Array.from(room).filter(playerId =&gt; {&#10;        const player = players.get(playerId);&#10;        return player &amp;&amp; !player.falling;&#10;    });&#10;&#10;    if (alivePlayers.length === 0) {&#10;        // Todos caíram, preparar para próxima rodada&#10;        const gameState = gameStates.get(roomId);&#10;        if (gameState) {&#10;            gameState.isActive = false;&#10;            gameState.isWaitingToStart = true;&#10;            gameState.waitStartTime = Date.now();&#10;&#10;            broadcastToRoom(roomId, {&#10;                type: 'ROUND_ENDED',&#10;                roundNumber: gameState.roundNumber&#10;            });&#10;        }&#10;    }&#10;}&#10;&#10;function restartGame(roomId) {&#10;    // Esta função não é mais necessária, pois o ciclo do jogo gerencia tudo&#10;    // Remover ou deixar vazia para compatibilidade&#10;    console.log(`[${new Date().toISOString()}] restartGame chamado para sala: ${roomId} - gerenciado pelo ciclo`);&#10;}&#10;&#10;function handlePlayerRespawn(playerId, data) {&#10;    const player = players.get(playerId);&#10;    if (!player) return;&#10;&#10;    player.position = data.position;&#10;    player.rotation = data.rotation;&#10;    player.carModel = String(data.carModel);&#10;    player.falling = false;&#10;&#10;    broadcastToRoom(player.roomId, {&#10;        type: 'PLAYER_RESPAWN',&#10;        playerId: playerId,&#10;        position: data.position,&#10;        rotation: data.rotation,&#10;        carModel: String(data.carModel)&#10;    }, playerId);&#10;}&#10;&#10;function handlePlayerDisconnect(playerId) {&#10;    const player = players.get(playerId);&#10;    if (!player) return;&#10;&#10;    if (rooms.has(player.roomId)) {&#10;        rooms.get(player.roomId).delete(playerId);&#10;        if (rooms.get(player.roomId).size === 0) {&#10;            // Limpar intervalo quando sala fica vazia&#10;            if (gameIntervals.has(player.roomId)) {&#10;                clearInterval(gameIntervals.get(player.roomId));&#10;                gameIntervals.delete(player.roomId);&#10;            }&#10;            rooms.delete(player.roomId);&#10;            gameStates.delete(player.roomId);&#10;        }&#10;    }&#10;&#10;    broadcastToRoom(player.roomId, {&#10;        type: 'PLAYER_LEFT',&#10;        playerId: playerId&#10;    });&#10;&#10;    players.delete(playerId);&#10;}&#10;&#10;function handleHeartbeat(playerId, data) {&#10;    const player = players.get(playerId);&#10;    if (!player) return;&#10;&#10;    player.lastHeartbeat = Date.now();&#10;    player.ws.send(JSON.stringify({ type: 'PONG' }));&#10;}&#10;&#10;function broadcastToRoom(roomId, message, excludePlayerId = null) {&#10;    if (!rooms.has(roomId)) return;&#10;&#10;    const room = rooms.get(roomId);&#10;    room.forEach(playerId =&gt; {&#10;        if (playerId === excludePlayerId) return;&#10;&#10;        const player = players.get(playerId);&#10;        if (player &amp;&amp; player.ws.readyState === WebSocket.OPEN) {&#10;            player.ws.send(JSON.stringify(message));&#10;        }&#10;    });&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/App.jsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/App.jsx" />
              <option name="originalContent" value="import React, { useRef, useState } from &quot;react&quot;;&#10;import { Canvas } from &quot;@react-three/fiber&quot;;&#10;import Car from &quot;./components/Car&quot;;&#10;import Track from &quot;./components/Track&quot;;&#10;import Camera from &quot;./components/Camera&quot;;&#10;import Timer from &quot;./components/Timer&quot;;&#10;import PlayerName from &quot;./components/PlayerName&quot;;&#10;import PlayerNameLabel from &quot;./components/PlayerNameLabel&quot;;&#10;&#10;function App() {&#10;    const carRef = useRef();&#10;    const [playerName, setPlayerName] = useState(&quot;&quot;);&#10;    const [carPosition, setCarPosition] = useState([0, 1, 0]);&#10;&#10;    return (&#10;        &lt;div style={{ width: &quot;100vw&quot;, height: &quot;100vh&quot;, backgroundColor: &quot;white&quot; }}&gt;&#10;            &lt;PlayerName onNameSet={setPlayerName} /&gt;&#10;            &lt;Timer /&gt;&#10;            &lt;Canvas shadows camera={{ position: [0, 8, 15], fov: 60 }}&gt;&#10;                {/* Iluminação */}&#10;                &lt;ambientLight intensity={0.6} /&gt;&#10;                &lt;directionalLight&#10;                    position={[20, 20, 10]}&#10;                    intensity={1.5}&#10;                    castShadow&#10;                    shadow-mapSize-width={2048}&#10;                    shadow-mapSize-height={2048}&#10;                    shadow-camera-left={-50}&#10;                    shadow-camera-right={50}&#10;                    shadow-camera-top={50}&#10;                    shadow-camera-bottom={-50}&#10;                /&gt;&#10;&#10;                {/* Componentes do jogo */}&#10;                &lt;Track /&gt;&#10;                &lt;Car&#10;                    ref={carRef}&#10;                    position={[0, 1, 0]}&#10;                    onPositionChange={setCarPosition}&#10;                /&gt;&#10;                &lt;Camera target={carRef} /&gt;&#10;&#10;                {/* Label do jogador */}&#10;                {playerName &amp;&amp; (&#10;                    &lt;PlayerNameLabel&#10;                        position={carPosition}&#10;                        playerName={playerName}&#10;                    /&gt;&#10;                )}&#10;            &lt;/Canvas&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;export default App;" />
              <option name="updatedContent" value="import React, { useRef, useState } from &quot;react&quot;;&#10;import { Canvas } from &quot;@react-three/fiber&quot;;&#10;import Car from &quot;./components/Car&quot;;&#10;import Track from &quot;./components/Track&quot;;&#10;import Camera from &quot;./components/Camera&quot;;&#10;import Timer from &quot;./components/Timer&quot;;&#10;import PlayerName from &quot;./components/PlayerName&quot;;&#10;import PlayerNameLabel from &quot;./components/PlayerNameLabel&quot;;&#10;&#10;function App() {&#10;    const carRef = useRef();&#10;    const [playerName, setPlayerName] = useState(&quot;&quot;);&#10;    const [carPosition, setCarPosition] = useState([0, 1, 0]);&#10;    const [carRotation, setCarRotation] = useState(0);&#10;&#10;    const handlePositionChange = (position, rotation) =&gt; {&#10;        setCarPosition(position);&#10;        setCarRotation(rotation);&#10;    };&#10;&#10;    return (&#10;        &lt;div style={{ width: &quot;100vw&quot;, height: &quot;100vh&quot;, backgroundColor: &quot;white&quot; }}&gt;&#10;            &lt;PlayerName onNameSet={setPlayerName} /&gt;&#10;            &lt;Timer /&gt;&#10;            &lt;Canvas shadows camera={{ position: [0, 8, 15], fov: 60 }}&gt;&#10;                {/* Iluminação */}&#10;                &lt;ambientLight intensity={0.6} /&gt;&#10;                &lt;directionalLight&#10;                    position={[20, 20, 10]}&#10;                    intensity={1.5}&#10;                    castShadow&#10;                    shadow-mapSize-width={2048}&#10;                    shadow-mapSize-height={2048}&#10;                    shadow-camera-left={-50}&#10;                    shadow-camera-right={50}&#10;                    shadow-camera-top={50}&#10;                    shadow-camera-bottom={-50}&#10;                /&gt;&#10;&#10;                {/* Componentes do jogo */}&#10;                &lt;Track /&gt;&#10;                &lt;Car&#10;                    ref={carRef}&#10;                    position={[0, 1, 0]}&#10;                    onPositionChange={handlePositionChange}&#10;                /&gt;&#10;                &lt;Camera target={carRef} /&gt;&#10;&#10;                {/* Label do jogador */}&#10;                {playerName &amp;&amp; (&#10;                    &lt;PlayerNameLabel&#10;                        position={carPosition}&#10;                        playerName={playerName}&#10;                        carRotation={carRotation}&#10;                    /&gt;&#10;                )}&#10;            &lt;/Canvas&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;export default App;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/Camera.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/Camera.tsx" />
              <option name="originalContent" value="import { useFrame, useThree } from &quot;@react-three/fiber&quot;;&#10;import React, { useRef } from &quot;react&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type CameraProps = {&#10;    target: React.RefObject&lt;THREE.Group&gt;;&#10;};&#10;&#10;export default function Camera({ target }: CameraProps) {&#10;    const { camera } = useThree();&#10;    const tempPos = new THREE.Vector3();&#10;    const tempTarget = new THREE.Vector3();&#10;    const currentFov = useRef(50); // FOV atual da câmera&#10;&#10;    useFrame(() =&gt; {&#10;        if (!target.current) return;&#10;&#10;        const carPos = target.current.position;&#10;        const carRot = target.current.rotation.y;&#10;&#10;        // Calcula velocidade aproximada baseada na posição anterior&#10;        const velocity = target.current.userData.velocity || new THREE.Vector3();&#10;        const speed = velocity.length();&#10;&#10;        // Ajusta FOV baseado na velocidade (zoom out quando acelera)&#10;        const baseFov = 50;&#10;        const maxSpeedFov = 85; // FOV máximo quando em alta velocidade&#10;        const targetFov = baseFov + (speed * 1); // multiplicador mais suave&#10;        const clampedFov = Math.min(targetFov, maxSpeedFov);&#10;&#10;        // Suaviza a transição do FOV&#10;        currentFov.current = THREE.MathUtils.lerp(currentFov.current, clampedFov, 0.05);&#10;        camera.fov = currentFov.current;&#10;        camera.updateProjectionMatrix();&#10;&#10;        // Ajusta distância da câmera baseada na velocidade&#10;        const baseDistance = 8;&#10;        const speedDistance = speed * 1; // distância adicional por velocidade&#10;        const totalDistance = baseDistance + speedDistance;&#10;&#10;        // offset atrás do carro com distância dinâmica&#10;        const offset = new THREE.Vector3(0, 5, -totalDistance);&#10;        const rotatedOffset = offset.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), carRot);&#10;        tempPos.copy(carPos).add(rotatedOffset);&#10;&#10;        // suaviza movimento da câmera&#10;        camera.position.lerp(tempPos, 0.1); // lerp mais suave&#10;&#10;        // olha para o carro&#10;        camera.lookAt(carPos);&#10;    });&#10;&#10;    return null;&#10;}&#10;" />
              <option name="updatedContent" value="import { useFrame, useThree } from &quot;@react-three/fiber&quot;;&#10;import React, { useRef } from &quot;react&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type CameraProps = {&#10;    target: React.RefObject&lt;THREE.Group&gt;;&#10;};&#10;&#10;export default function Camera({ target }: CameraProps) {&#10;    const { camera } = useThree();&#10;    const tempPos = new THREE.Vector3();&#10;    const tempTarget = new THREE.Vector3();&#10;    const currentFov = useRef(45); // FOV base menor (era 50)&#10;&#10;    useFrame(() =&gt; {&#10;        if (!target.current) return;&#10;&#10;        const carPos = target.current.position;&#10;        const carRot = target.current.rotation.y;&#10;&#10;        // Calcula velocidade aproximada baseada na posição anterior&#10;        const velocity = target.current.userData.velocity || new THREE.Vector3();&#10;        const speed = velocity.length();&#10;&#10;        // Ajusta FOV baseado na velocidade com menos variação&#10;        const baseFov = 45; // FOV base menor&#10;        const maxSpeedFov = 55; // FOV máximo menor (era 85)&#10;        const targetFov = baseFov + (speed * 0.5); // multiplicador muito mais suave (era 1)&#10;        const clampedFov = Math.min(targetFov, maxSpeedFov);&#10;&#10;        // Suaviza a transição do FOV ainda mais&#10;        currentFov.current = THREE.MathUtils.lerp(currentFov.current, clampedFov, 0.02); // mais suave (era 0.05)&#10;        camera.fov = currentFov.current;&#10;        camera.updateProjectionMatrix();&#10;&#10;        // Ajusta distância da câmera com menos variação&#10;        const baseDistance = 10; // distância base maior&#10;        const speedDistance = speed * 0.5; // menos variação por velocidade (era 1)&#10;        const totalDistance = baseDistance + speedDistance;&#10;&#10;        // offset atrás do carro&#10;        const offset = new THREE.Vector3(0, 4, -totalDistance); // altura menor (era 5)&#10;        const rotatedOffset = offset.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), carRot);&#10;        tempPos.copy(carPos).add(rotatedOffset);&#10;&#10;        // movimento da câmera muito mais suave&#10;        camera.position.lerp(tempPos, 0.05); // muito mais suave (era 0.1)&#10;&#10;        // olha para o carro&#10;        camera.lookAt(carPos);&#10;    });&#10;&#10;    return null;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/Car.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/Car.tsx" />
              <option name="originalContent" value="import React, { useRef, useEffect, useState, forwardRef, useMemo } from &quot;react&quot;;&#10;import { useFrame } from &quot;@react-three/fiber&quot;;&#10;import { useGLTF } from &quot;@react-three/drei&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type CarProps = {&#10;    position?: [number, number, number];&#10;    onPositionChange?: (position: [number, number, number], rotation: number) =&gt; void;&#10;};&#10;&#10;const Car = forwardRef&lt;THREE.Group, CarProps&gt;(({ position = [0, 0.5, 0], onPositionChange }, ref) =&gt; {&#10;    const groupRef = useRef&lt;THREE.Group&gt;(null);&#10;    const [keys, setKeys] = useState&lt;{ [key: string]: boolean }&gt;({});&#10;    const velocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const angleRef = useRef(0);&#10;    const fallingRef = useRef(false);&#10;    const fallTimeRef = useRef(0);&#10;    const rotationVelocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const initialPosition = useRef(new THREE.Vector3(...position));&#10;    const [selectedCar, setSelectedCar] = useState(() =&gt; {&#10;        const carNumber = Math.floor(Math.random() * 4) + 1;&#10;        console.log(`Carro selecionado: car${carNumber}.glb`);&#10;        return `/models/car${carNumber}.glb`;&#10;    });&#10;&#10;    // Carrega o modelo GLB randomizado&#10;    const { scene } = useGLTF(selectedCar);&#10;&#10;    useEffect(() =&gt; {&#10;        if (!ref || !groupRef.current) return;&#10;        if (typeof ref === &quot;function&quot;) ref(groupRef.current);&#10;        else ref.current = groupRef.current;&#10;    }, [ref]);&#10;&#10;    useEffect(() =&gt; {&#10;        const down = (e: KeyboardEvent) =&gt; setKeys(k =&gt; ({ ...k, [e.key]: true }));&#10;        const up = (e: KeyboardEvent) =&gt; setKeys(k =&gt; ({ ...k, [e.key]: false }));&#10;        window.addEventListener(&quot;keydown&quot;, down);&#10;        window.addEventListener(&quot;keyup&quot;, up);&#10;        return () =&gt; {&#10;            window.removeEventListener(&quot;keydown&quot;, down);&#10;            window.removeEventListener(&quot;keyup&quot;, up);&#10;        };&#10;    }, []);&#10;&#10;    useFrame((state, delta) =&gt; {&#10;        const current = groupRef.current;&#10;        if (!current) return;&#10;&#10;        // Se está caindo, apenas aplica gravidade e rotação&#10;        if (fallingRef.current) {&#10;            velocityRef.current.y -= 9.8 * delta; // gravidade&#10;&#10;            // Continua movimento horizontal durante a queda&#10;            const direction = new THREE.Vector3(&#10;                Math.sin(angleRef.current) * velocityRef.current.z,&#10;                0,&#10;                Math.cos(angleRef.current) * velocityRef.current.z&#10;            );&#10;            current.position.add(direction);&#10;            current.position.add(new THREE.Vector3(0, velocityRef.current.y * delta, 0));&#10;&#10;            // Rotação realista durante a queda (frente cai primeiro)&#10;            rotationVelocityRef.current.x += 2 * delta;&#10;            current.rotation.x += rotationVelocityRef.current.x * delta;&#10;&#10;            fallTimeRef.current += delta;&#10;&#10;            // Respawn após 3 segundos&#10;            if (fallTimeRef.current &gt;= 3) {&#10;                // Posição aleatória na plataforma (evita bordas)&#10;                const randomX = (Math.random() - 0.5) * 120; // 120 de 200 para evitar bordas&#10;                const randomZ = (Math.random() - 0.5) * 120;&#10;                const randomAngle = Math.random() * Math.PI * 2; // rotação aleatória&#10;&#10;                current.position.set(randomX, initialPosition.current.y, randomZ);&#10;                velocityRef.current.set(0, 0, 0);&#10;                rotationVelocityRef.current.set(0, 0, 0);&#10;                angleRef.current = randomAngle;&#10;                current.rotation.set(0, randomAngle, 0);&#10;                fallingRef.current = false;&#10;                fallTimeRef.current = 0;&#10;&#10;                // Muda o carro no respawn&#10;                const carNumber = Math.floor(Math.random() * 4) + 1;&#10;                const newCarPath = `/models/car${carNumber}.glb`;&#10;                console.log(`Novo carro selecionado: car${carNumber}.glb`);&#10;                setSelectedCar(newCarPath);&#10;            }&#10;            return;&#10;        }&#10;&#10;        const velocity = velocityRef.current;&#10;        let angle = angleRef.current;&#10;&#10;        const acceleration = 0.02;&#10;        const maxSpeed = 0.5;&#10;        const turnSpeed = 0.03;&#10;        const friction = 0.99;&#10;        const brakeForce = 0.08; // força do freio (mais fraca que aceleração)&#10;        const reverseAcceleration = 0.01; // aceleração em ré (mais lenta)&#10;        const maxReverseSpeed = 0.2; // velocidade máxima em ré (mais baixa)&#10;&#10;        if (keys[&quot;ArrowUp&quot;] || keys[&quot;w&quot;]) {&#10;            velocity.z = Math.min(velocity.z + acceleration, maxSpeed);&#10;        }&#10;&#10;        if (keys[&quot;ArrowDown&quot;] || keys[&quot;s&quot;]) {&#10;            // Se está indo para frente, aplica freio gradual&#10;            if (velocity.z &gt; 0.8) { // threshold mínimo para considerar &quot;parado&quot;&#10;                velocity.z = Math.max(velocity.z - brakeForce, 0);&#10;            }&#10;            // Só permite ré quando realmente parou&#10;            else if (velocity.z &lt;= 0.2 &amp;&amp; velocity.z &gt;= -0.1) {&#10;                velocity.z = Math.max(velocity.z - reverseAcceleration, -maxReverseSpeed);&#10;            }&#10;        }&#10;&#10;        const speedFactor = Math.abs(velocity.z) / maxSpeed;&#10;        if ((keys[&quot;ArrowLeft&quot;] || keys[&quot;a&quot;]) &amp;&amp; speedFactor &gt; 0.1) {&#10;            angle += turnSpeed * speedFactor;&#10;        }&#10;        if ((keys[&quot;ArrowRight&quot;] || keys[&quot;d&quot;]) &amp;&amp; speedFactor &gt; 0.1) {&#10;            angle -= turnSpeed * speedFactor;&#10;        }&#10;&#10;        velocity.multiplyScalar(friction);&#10;&#10;        const direction = new THREE.Vector3(&#10;            Math.sin(angle) * velocity.z,&#10;            0,&#10;            Math.cos(angle) * velocity.z&#10;        );&#10;&#10;        current.position.add(direction);&#10;        current.rotation.y = angle;&#10;&#10;        // Verifica se a frente do carro saiu da plataforma (física mais realista)&#10;        const trackSize = 200;&#10;        const carLength = 3; // comprimento aproximado do carro&#10;&#10;        // Calcula posição da frente do carro&#10;        const frontX = current.position.x + Math.sin(angle) * carLength;&#10;        const frontZ = current.position.z + Math.cos(angle) * carLength;&#10;&#10;        if (Math.abs(frontX) &gt; trackSize/2 || Math.abs(frontZ) &gt; trackSize/2) {&#10;            if (!fallingRef.current) {&#10;                fallingRef.current = true;&#10;                velocityRef.current.y = 0; // inicia queda&#10;                rotationVelocityRef.current.set(0, 0, 0);&#10;            }&#10;        }&#10;&#10;        // Armazena velocidade para a câmera acessar&#10;        current.userData.velocity = velocity.clone();&#10;&#10;        // Atualiza posição para o label do jogador&#10;        if (onPositionChange) {&#10;            onPositionChange([current.position.x, current.position.y, current.position.z], angle);&#10;        }&#10;&#10;        angleRef.current = angle;&#10;    });&#10;&#10;    return (&#10;        &lt;group ref={groupRef} position={position} castShadow&gt;&#10;            &lt;primitive object={scene.clone()} scale={[5, 5, 5]} rotation={[0, Math.PI / 2, 0]} /&gt;&#10;        &lt;/group&gt;&#10;    );&#10;});&#10;&#10;for (let i = 1; i &lt;= 4; i++) {&#10;    useGLTF.preload(`/models/car${i}.glb`);&#10;}&#10;&#10;export default Car;&#10;&#10;" />
              <option name="updatedContent" value="import React, { useRef, useEffect, useState, forwardRef, useMemo } from &quot;react&quot;;&#10;import { useFrame } from &quot;@react-three/fiber&quot;;&#10;import { useGLTF } from &quot;@react-three/drei&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type CarProps = {&#10;    position?: [number, number, number];&#10;    onPositionChange?: (position: [number, number, number], rotation: number) =&gt; void;&#10;};&#10;&#10;const Car = forwardRef&lt;THREE.Group, CarProps&gt;(({ position = [0, 0.5, 0], onPositionChange }, ref) =&gt; {&#10;    const groupRef = useRef&lt;THREE.Group&gt;(null);&#10;    const [keys, setKeys] = useState&lt;{ [key: string]: boolean }&gt;({});&#10;    const velocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const angleRef = useRef(0);&#10;    const fallingRef = useRef(false);&#10;    const fallTimeRef = useRef(0);&#10;    const rotationVelocityRef = useRef(new THREE.Vector3(0, 0, 0));&#10;    const initialPosition = useRef(new THREE.Vector3(...position));&#10;    const [selectedCar, setSelectedCar] = useState(() =&gt; {&#10;        const carNumber = Math.floor(Math.random() * 4) + 1;&#10;        console.log(`Carro selecionado: car${carNumber}.glb`);&#10;        return `/models/car${carNumber}.glb`;&#10;    });&#10;&#10;    // Carrega o modelo GLB randomizado&#10;    const { scene } = useGLTF(selectedCar);&#10;&#10;    useEffect(() =&gt; {&#10;        if (!ref || !groupRef.current) return;&#10;        if (typeof ref === &quot;function&quot;) ref(groupRef.current);&#10;        else ref.current = groupRef.current;&#10;    }, [ref]);&#10;&#10;    useEffect(() =&gt; {&#10;        const down = (e: KeyboardEvent) =&gt; setKeys(k =&gt; ({ ...k, [e.key]: true }));&#10;        const up = (e: KeyboardEvent) =&gt; setKeys(k =&gt; ({ ...k, [e.key]: false }));&#10;        window.addEventListener(&quot;keydown&quot;, down);&#10;        window.addEventListener(&quot;keyup&quot;, up);&#10;        return () =&gt; {&#10;            window.removeEventListener(&quot;keydown&quot;, down);&#10;            window.removeEventListener(&quot;keyup&quot;, up);&#10;        };&#10;    }, []);&#10;&#10;    useFrame((state, delta) =&gt; {&#10;        const current = groupRef.current;&#10;        if (!current) return;&#10;&#10;        // Se está caindo, apenas aplica gravidade e rotação&#10;        if (fallingRef.current) {&#10;            velocityRef.current.y -= 9.8 * delta; // gravidade&#10;&#10;            // Continua movimento horizontal durante a queda&#10;            const direction = new THREE.Vector3(&#10;                Math.sin(angleRef.current) * velocityRef.current.z,&#10;                0,&#10;                Math.cos(angleRef.current) * velocityRef.current.z&#10;            );&#10;            current.position.add(direction);&#10;            current.position.add(new THREE.Vector3(0, velocityRef.current.y * delta, 0));&#10;&#10;            // Rotação realista durante a queda (frente cai primeiro)&#10;            rotationVelocityRef.current.x += 2 * delta;&#10;            current.rotation.x -= rotationVelocityRef.current.x * delta; // mudança aqui: menos ao invés de mais&#10;&#10;            fallTimeRef.current += delta;&#10;&#10;            // Respawn após 3 segundos&#10;            if (fallTimeRef.current &gt;= 3) {&#10;                // Posição aleatória na plataforma (evita bordas)&#10;                const randomX = (Math.random() - 0.5) * 120; // 120 de 200 para evitar bordas&#10;                const randomZ = (Math.random() - 0.5) * 120;&#10;                const randomAngle = Math.random() * Math.PI * 2; // rotação aleatória&#10;&#10;                current.position.set(randomX, initialPosition.current.y, randomZ);&#10;                velocityRef.current.set(0, 0, 0);&#10;                rotationVelocityRef.current.set(0, 0, 0);&#10;                angleRef.current = randomAngle;&#10;                current.rotation.set(0, randomAngle, 0);&#10;                fallingRef.current = false;&#10;                fallTimeRef.current = 0;&#10;&#10;                // Muda o carro no respawn&#10;                const carNumber = Math.floor(Math.random() * 4) + 1;&#10;                const newCarPath = `/models/car${carNumber}.glb`;&#10;                console.log(`Novo carro selecionado: car${carNumber}.glb`);&#10;                setSelectedCar(newCarPath);&#10;            }&#10;            return;&#10;        }&#10;&#10;        const velocity = velocityRef.current;&#10;        let angle = angleRef.current;&#10;&#10;        const acceleration = 0.02;&#10;        const maxSpeed = 0.5;&#10;        const turnSpeed = 0.03;&#10;        const friction = 0.99;&#10;        const brakeForce = 0.08; // força do freio (mais fraca que aceleração)&#10;        const reverseAcceleration = 0.01; // aceleração em ré (mais lenta)&#10;        const maxReverseSpeed = 0.2; // velocidade máxima em ré (mais baixa)&#10;&#10;        if (keys[&quot;ArrowUp&quot;] || keys[&quot;w&quot;]) {&#10;            velocity.z = Math.min(velocity.z + acceleration, maxSpeed);&#10;        }&#10;&#10;        if (keys[&quot;ArrowDown&quot;] || keys[&quot;s&quot;]) {&#10;            // Se está indo para frente, aplica freio gradual&#10;            if (velocity.z &gt; 0.8) { // threshold mínimo para considerar &quot;parado&quot;&#10;                velocity.z = Math.max(velocity.z - brakeForce, 0);&#10;            }&#10;            // Só permite ré quando realmente parou&#10;            else if (velocity.z &lt;= 0.2 &amp;&amp; velocity.z &gt;= -0.1) {&#10;                velocity.z = Math.max(velocity.z - reverseAcceleration, -maxReverseSpeed);&#10;            }&#10;        }&#10;&#10;        const speedFactor = Math.abs(velocity.z) / maxSpeed;&#10;        if ((keys[&quot;ArrowLeft&quot;] || keys[&quot;a&quot;]) &amp;&amp; speedFactor &gt; 0.1) {&#10;            angle += turnSpeed * speedFactor;&#10;        }&#10;        if ((keys[&quot;ArrowRight&quot;] || keys[&quot;d&quot;]) &amp;&amp; speedFactor &gt; 0.1) {&#10;            angle -= turnSpeed * speedFactor;&#10;        }&#10;&#10;        velocity.multiplyScalar(friction);&#10;&#10;        const direction = new THREE.Vector3(&#10;            Math.sin(angle) * velocity.z,&#10;            0,&#10;            Math.cos(angle) * velocity.z&#10;        );&#10;&#10;        current.position.add(direction);&#10;        current.rotation.y = angle;&#10;&#10;        // Verifica se a frente do carro saiu da plataforma (física mais realista)&#10;        const trackSize = 200;&#10;        const carLength = 3; // comprimento aproximado do carro&#10;&#10;        // Calcula posição da frente do carro&#10;        const frontX = current.position.x + Math.sin(angle) * carLength;&#10;        const frontZ = current.position.z + Math.cos(angle) * carLength;&#10;&#10;        if (Math.abs(frontX) &gt; trackSize/2 || Math.abs(frontZ) &gt; trackSize/2) {&#10;            if (!fallingRef.current) {&#10;                fallingRef.current = true;&#10;                velocityRef.current.y = 0; // inicia queda&#10;                rotationVelocityRef.current.set(0, 0, 0);&#10;            }&#10;        }&#10;&#10;        // Armazena velocidade para a câmera acessar&#10;        current.userData.velocity = velocity.clone();&#10;&#10;        // Atualiza posição para o label do jogador&#10;        if (onPositionChange) {&#10;            onPositionChange([current.position.x, current.position.y, current.position.z], angle);&#10;        }&#10;&#10;        angleRef.current = angle;&#10;    });&#10;&#10;    return (&#10;        &lt;group ref={groupRef} position={position} castShadow&gt;&#10;            &lt;primitive object={scene.clone()} scale={[5, 5, 5]} rotation={[0, Math.PI / 2, 0]} /&gt;&#10;        &lt;/group&gt;&#10;    );&#10;});&#10;&#10;for (let i = 1; i &lt;= 4; i++) {&#10;    useGLTF.preload(`/models/car${i}.glb`);&#10;}&#10;&#10;export default Car;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/PlayerName.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/PlayerName.tsx" />
              <option name="updatedContent" value="import React, { useState, useEffect } from &quot;react&quot;;&#10;&#10;type PlayerNameProps = {&#10;    onNameSet: (name: string) =&gt; void;&#10;};&#10;&#10;export default function PlayerName({ onNameSet }: PlayerNameProps) {&#10;    const [name, setName] = useState(&quot;&quot;);&#10;    const [showInput, setShowInput] = useState(false);&#10;&#10;    useEffect(() =&gt; {&#10;        const savedName = localStorage.getItem(&quot;playerName&quot;);&#10;        if (savedName) {&#10;            onNameSet(savedName);&#10;        } else {&#10;            setShowInput(true);&#10;        }&#10;    }, [onNameSet]);&#10;&#10;    const handleSubmit = (e: React.FormEvent) =&gt; {&#10;        e.preventDefault();&#10;        if (name.trim()) {&#10;            localStorage.setItem(&quot;playerName&quot;, name.trim());&#10;            onNameSet(name.trim());&#10;            setShowInput(false);&#10;        }&#10;    };&#10;&#10;    if (!showInput) return null;&#10;&#10;    return (&#10;        &lt;div style={{&#10;            position: &quot;fixed&quot;,&#10;            top: 0,&#10;            left: 0,&#10;            width: &quot;100vw&quot;,&#10;            height: &quot;100vh&quot;,&#10;            backgroundColor: &quot;rgba(0, 0, 0, 0.7)&quot;,&#10;            display: &quot;flex&quot;,&#10;            alignItems: &quot;center&quot;,&#10;            justifyContent: &quot;center&quot;,&#10;            zIndex: 1000&#10;        }}&gt;&#10;            &lt;div style={{&#10;                backgroundColor: &quot;white&quot;,&#10;                padding: &quot;30px&quot;,&#10;                borderRadius: &quot;10px&quot;,&#10;                textAlign: &quot;center&quot;,&#10;                minWidth: &quot;300px&quot;&#10;            }}&gt;&#10;                &lt;h2 style={{ marginBottom: &quot;20px&quot;, color: &quot;#333&quot; }}&gt;&#10;                    Bem-vindo ao Jogo!&#10;                &lt;/h2&gt;&#10;                &lt;form onSubmit={handleSubmit}&gt;&#10;                    &lt;input&#10;                        type=&quot;text&quot;&#10;                        value={name}&#10;                        onChange={(e) =&gt; setName(e.target.value)}&#10;                        placeholder=&quot;Digite seu nome&quot;&#10;                        style={{&#10;                            padding: &quot;10px&quot;,&#10;                            fontSize: &quot;16px&quot;,&#10;                            border: &quot;2px solid #ddd&quot;,&#10;                            borderRadius: &quot;5px&quot;,&#10;                            marginBottom: &quot;20px&quot;,&#10;                            width: &quot;100%&quot;,&#10;                            outline: &quot;none&quot;&#10;                        }}&#10;                        autoFocus&#10;                    /&gt;&#10;                    &lt;button&#10;                        type=&quot;submit&quot;&#10;                        style={{&#10;                            padding: &quot;10px 20px&quot;,&#10;                            fontSize: &quot;16px&quot;,&#10;                            backgroundColor: &quot;#007bff&quot;,&#10;                            color: &quot;white&quot;,&#10;                            border: &quot;none&quot;,&#10;                            borderRadius: &quot;5px&quot;,&#10;                            cursor: &quot;pointer&quot;&#10;                        }}&#10;                    &gt;&#10;                        Começar Jogo&#10;                    &lt;/button&gt;&#10;                &lt;/form&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/PlayerNameLabel.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/PlayerNameLabel.tsx" />
              <option name="originalContent" value="import React from &quot;react&quot;;&#10;import { Text } from &quot;@react-three/drei&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type PlayerNameLabelProps = {&#10;    position: [number, number, number];&#10;    playerName: string;&#10;    carRotation: number;&#10;};&#10;&#10;export default function PlayerNameLabel({ position, playerName, carRotation }: PlayerNameLabelProps) {&#10;    // @ts-ignore&#10;    return (&#10;        &lt;group position={[position[0], position[1] + 6, position[2]]} rotation={[0, carRotation + Math.PI, 0]}&gt;&#10;            {/* Fundo retangular cinza */}&#10;            &lt;mesh&gt;&#10;                &lt;planeGeometry args={[playerName.length * 0.2 + 0.3, 0.5]} /&gt;&#10;                &lt;meshBasicMaterial color=&quot;#666666&quot; transparent opacity={0.3} /&gt;&#10;            &lt;/mesh&gt;&#10;&#10;            {/* Texto do nome */}&#10;            &lt;Text&#10;                position={[0, 0, 0.01]}&#10;                fontSize={0.3}&#10;                color=&quot;#ffffff&quot;&#10;                anchorX=&quot;center&quot;&#10;                anchorY=&quot;middle&quot;&#10;                material-transparent={true}&#10;                material-opacity={0.9}&#10;            &gt;&#10;                {playerName}&#10;            &lt;/Text&gt;&#10;        &lt;/group&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="import React from &quot;react&quot;;&#10;import { Text } from &quot;@react-three/drei&quot;;&#10;import * as THREE from &quot;three&quot;;&#10;&#10;type PlayerNameLabelProps = {&#10;    position: [number, number, number];&#10;    playerName: string;&#10;    carRotation: number;&#10;};&#10;&#10;export default function PlayerNameLabel({ position, playerName, carRotation }: PlayerNameLabelProps) {&#10;    // @ts-ignore&#10;    return (&#10;        &lt;group position={[position[0], position[1] + 3, position[2]]} rotation={[0, carRotation + Math.PI, 0]}&gt;&#10;            {/* Fundo retangular cinza */}&#10;            &lt;mesh&gt;&#10;                &lt;planeGeometry args={[playerName.length * 0.2 + 0.3, 0.5]} /&gt;&#10;                &lt;meshBasicMaterial color=&quot;#666666&quot; transparent opacity={0.3} /&gt;&#10;            &lt;/mesh&gt;&#10;&#10;            {/* Texto do nome */}&#10;            &lt;Text&#10;                position={[0, 0, 0.01]}&#10;                fontSize={0.3}&#10;                color=&quot;#ffffff&quot;&#10;                anchorX=&quot;center&quot;&#10;                anchorY=&quot;middle&quot;&#10;                material-transparent={true}&#10;                material-opacity={0.9}&#10;            &gt;&#10;                {playerName}&#10;            &lt;/Text&gt;&#10;        &lt;/group&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/Timer.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/Timer.tsx" />
              <option name="originalContent" value="import React, { useEffect, useState } from &quot;react&quot;;&#10;&#10;export default function Timer() {&#10;    const [time, setTime] = useState(0);&#10;&#10;    useEffect(() =&gt; {&#10;        const interval = setInterval(() =&gt; setTime(prev =&gt; prev + 0.01), 10);&#10;        return () =&gt; clearInterval(interval);&#10;    }, []);&#10;&#10;    const formatTime = (t: number) =&gt; {&#10;        const minutes = Math.floor(t / 60);&#10;        const seconds = (t % 60).toFixed(2);&#10;        return `${minutes}:${seconds.padStart(5, &quot;0&quot;)}`;&#10;    };&#10;&#10;    return (&#10;        &lt;div style={{ position: &quot;absolute&quot;, top: 20, left: 20, color: &quot;white&quot;, fontSize: &quot;24px&quot; }}&gt;&#10;            {formatTime(time)}&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="import React, { useEffect, useState } from &quot;react&quot;;&#10;&#10;export default function Timer() {&#10;    const [time, setTime] = useState(0);&#10;&#10;    useEffect(() =&gt; {&#10;        const interval = setInterval(() =&gt; setTime(prev =&gt; prev + 0.01), 10);&#10;        return () =&gt; clearInterval(interval);&#10;    }, []);&#10;&#10;    const formatTime = (t: number) =&gt; {&#10;        const minutes = Math.floor(t / 60);&#10;        const seconds = (t % 60).toFixed(2);&#10;        return `${minutes}:${seconds.padStart(5, &quot;0&quot;)}`;&#10;    };&#10;&#10;    return (&#10;        &lt;div style={{ position: &quot;absolute&quot;, top: 20, left: 20, color: &quot;black&quot;, fontSize: &quot;24px&quot; }}&gt;&#10;            {formatTime(time)}&#10;        &lt;/div&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/Track.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/Track.tsx" />
              <option name="originalContent" value="import React from &quot;react&quot;;&#10;&#10;export default function Track() {&#10;    const trackSize = 100; // plataforma quadrada 100x100&#10;&#10;    return (&#10;        &lt;group&gt;&#10;            {/* Plataforma principal quadrada */}&#10;            &lt;mesh position={[0, -1, 0]} receiveShadow&gt;&#10;                &lt;boxGeometry args={[trackSize, 2, trackSize]} /&gt;&#10;                &lt;meshStandardMaterial color=&quot;#2c2c2c&quot; /&gt;&#10;            &lt;/mesh&gt;&#10;        &lt;/group&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="import React from &quot;react&quot;;&#10;&#10;export default function Track() {&#10;    const trackSize = 200; // plataforma muito maior: 200x200&#10;&#10;    return (&#10;        &lt;group&gt;&#10;            {/* Plataforma principal quadrada */}&#10;            &lt;mesh position={[0, -1, 0]} receiveShadow&gt;&#10;                &lt;boxGeometry args={[trackSize, 2, trackSize]} /&gt;&#10;                &lt;meshStandardMaterial color=&quot;#808080&quot; /&gt;&#10;            &lt;/mesh&gt;&#10;        &lt;/group&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>